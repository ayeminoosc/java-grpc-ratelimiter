// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/transport_sockets/tls/v3/tls.proto

package io.envoyproxy.envoy.extensions.transport_sockets.tls.v3;

public interface CommonTlsContextOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.transport_sockets.tls.v3.CommonTlsContext)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * TLS protocol versions, cipher suites etc.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1;</code>
   * @return Whether the tlsParams field is set.
   */
  boolean hasTlsParams();
  /**
   * <pre>
   * TLS protocol versions, cipher suites etc.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1;</code>
   * @return The tlsParams.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.TlsParameters getTlsParams();
  /**
   * <pre>
   * TLS protocol versions, cipher suites etc.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.TlsParametersOrBuilder getTlsParamsOrBuilder();

  /**
   * <pre>
   * :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select&gt;` can be associated with the
   * same context to allow both RSA and ECDSA certificates.
   * Only a single TLS certificate is supported in client contexts. In server contexts, the first
   * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
   * used for clients that support ECDSA.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;</code>
   */
  java.util.List<io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.TlsCertificate> 
      getTlsCertificatesList();
  /**
   * <pre>
   * :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select&gt;` can be associated with the
   * same context to allow both RSA and ECDSA certificates.
   * Only a single TLS certificate is supported in client contexts. In server contexts, the first
   * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
   * used for clients that support ECDSA.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.TlsCertificate getTlsCertificates(int index);
  /**
   * <pre>
   * :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select&gt;` can be associated with the
   * same context to allow both RSA and ECDSA certificates.
   * Only a single TLS certificate is supported in client contexts. In server contexts, the first
   * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
   * used for clients that support ECDSA.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;</code>
   */
  int getTlsCertificatesCount();
  /**
   * <pre>
   * :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select&gt;` can be associated with the
   * same context to allow both RSA and ECDSA certificates.
   * Only a single TLS certificate is supported in client contexts. In server contexts, the first
   * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
   * used for clients that support ECDSA.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.TlsCertificateOrBuilder> 
      getTlsCertificatesOrBuilderList();
  /**
   * <pre>
   * :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select&gt;` can be associated with the
   * same context to allow both RSA and ECDSA certificates.
   * Only a single TLS certificate is supported in client contexts. In server contexts, the first
   * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
   * used for clients that support ECDSA.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.TlsCertificateOrBuilder getTlsCertificatesOrBuilder(
      int index);

  /**
   * <pre>
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6 [(.validate.rules) = { ... }</code>
   */
  java.util.List<io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig> 
      getTlsCertificateSdsSecretConfigsList();
  /**
   * <pre>
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig getTlsCertificateSdsSecretConfigs(int index);
  /**
   * <pre>
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6 [(.validate.rules) = { ... }</code>
   */
  int getTlsCertificateSdsSecretConfigsCount();
  /**
   * <pre>
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6 [(.validate.rules) = { ... }</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfigOrBuilder> 
      getTlsCertificateSdsSecretConfigsOrBuilderList();
  /**
   * <pre>
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>repeated .envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfigOrBuilder getTlsCertificateSdsSecretConfigsOrBuilder(
      int index);

  /**
   * <pre>
   * Certificate provider for fetching TLS certificates.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9;</code>
   * @return Whether the tlsCertificateCertificateProvider field is set.
   */
  boolean hasTlsCertificateCertificateProvider();
  /**
   * <pre>
   * Certificate provider for fetching TLS certificates.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9;</code>
   * @return The tlsCertificateCertificateProvider.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider getTlsCertificateCertificateProvider();
  /**
   * <pre>
   * Certificate provider for fetching TLS certificates.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderOrBuilder getTlsCertificateCertificateProviderOrBuilder();

  /**
   * <pre>
   * Certificate provider instance for fetching TLS certificates.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11;</code>
   * @return Whether the tlsCertificateCertificateProviderInstance field is set.
   */
  boolean hasTlsCertificateCertificateProviderInstance();
  /**
   * <pre>
   * Certificate provider instance for fetching TLS certificates.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11;</code>
   * @return The tlsCertificateCertificateProviderInstance.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance getTlsCertificateCertificateProviderInstance();
  /**
   * <pre>
   * Certificate provider instance for fetching TLS certificates.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstanceOrBuilder getTlsCertificateCertificateProviderInstanceOrBuilder();

  /**
   * <pre>
   * How to validate peer certificates.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3;</code>
   * @return Whether the validationContext field is set.
   */
  boolean hasValidationContext();
  /**
   * <pre>
   * How to validate peer certificates.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3;</code>
   * @return The validationContext.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext getValidationContext();
  /**
   * <pre>
   * How to validate peer certificates.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CertificateValidationContextOrBuilder getValidationContextOrBuilder();

  /**
   * <pre>
   * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
   * @return Whether the validationContextSdsSecretConfig field is set.
   */
  boolean hasValidationContextSdsSecretConfig();
  /**
   * <pre>
   * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
   * @return The validationContextSdsSecretConfig.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig getValidationContextSdsSecretConfig();
  /**
   * <pre>
   * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder();

  /**
   * <pre>
   * Combined certificate validation context holds a default CertificateValidationContext
   * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
   * and default CertificateValidationContext are merged into a new CertificateValidationContext
   * for validation. This merge is done by Message::MergeFrom(), so dynamic
   * CertificateValidationContext overwrites singular fields in default
   * CertificateValidationContext, and concatenates repeated fields to default
   * CertificateValidationContext, and logical OR is applied to boolean fields.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
   * @return Whether the combinedValidationContext field is set.
   */
  boolean hasCombinedValidationContext();
  /**
   * <pre>
   * Combined certificate validation context holds a default CertificateValidationContext
   * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
   * and default CertificateValidationContext are merged into a new CertificateValidationContext
   * for validation. This merge is done by Message::MergeFrom(), so dynamic
   * CertificateValidationContext overwrites singular fields in default
   * CertificateValidationContext, and concatenates repeated fields to default
   * CertificateValidationContext, and logical OR is applied to boolean fields.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
   * @return The combinedValidationContext.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext getCombinedValidationContext();
  /**
   * <pre>
   * Combined certificate validation context holds a default CertificateValidationContext
   * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
   * and default CertificateValidationContext are merged into a new CertificateValidationContext
   * for validation. This merge is done by Message::MergeFrom(), so dynamic
   * CertificateValidationContext overwrites singular fields in default
   * CertificateValidationContext, and concatenates repeated fields to default
   * CertificateValidationContext, and logical OR is applied to boolean fields.
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContextOrBuilder getCombinedValidationContextOrBuilder();

  /**
   * <pre>
   * Certificate provider for fetching validation context.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10;</code>
   * @return Whether the validationContextCertificateProvider field is set.
   */
  boolean hasValidationContextCertificateProvider();
  /**
   * <pre>
   * Certificate provider for fetching validation context.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10;</code>
   * @return The validationContextCertificateProvider.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider getValidationContextCertificateProvider();
  /**
   * <pre>
   * Certificate provider for fetching validation context.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderOrBuilder getValidationContextCertificateProviderOrBuilder();

  /**
   * <pre>
   * Certificate provider instance for fetching validation context.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12;</code>
   * @return Whether the validationContextCertificateProviderInstance field is set.
   */
  boolean hasValidationContextCertificateProviderInstance();
  /**
   * <pre>
   * Certificate provider instance for fetching validation context.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12;</code>
   * @return The validationContextCertificateProviderInstance.
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance getValidationContextCertificateProviderInstance();
  /**
   * <pre>
   * Certificate provider instance for fetching validation context.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12;</code>
   */
  io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstanceOrBuilder getValidationContextCertificateProviderInstanceOrBuilder();

  /**
   * <pre>
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type&gt;`
   * parameter in the HTTP connection manager for more information):
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   * </pre>
   *
   * <code>repeated string alpn_protocols = 4;</code>
   * @return A list containing the alpnProtocols.
   */
  java.util.List<java.lang.String>
      getAlpnProtocolsList();
  /**
   * <pre>
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type&gt;`
   * parameter in the HTTP connection manager for more information):
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   * </pre>
   *
   * <code>repeated string alpn_protocols = 4;</code>
   * @return The count of alpnProtocols.
   */
  int getAlpnProtocolsCount();
  /**
   * <pre>
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type&gt;`
   * parameter in the HTTP connection manager for more information):
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   * </pre>
   *
   * <code>repeated string alpn_protocols = 4;</code>
   * @param index The index of the element to return.
   * @return The alpnProtocols at the given index.
   */
  java.lang.String getAlpnProtocols(int index);
  /**
   * <pre>
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type&gt;`
   * parameter in the HTTP connection manager for more information):
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   * </pre>
   *
   * <code>repeated string alpn_protocols = 4;</code>
   * @param index The index of the value to return.
   * @return The bytes of the alpnProtocols at the given index.
   */
  com.google.protobuf.ByteString
      getAlpnProtocolsBytes(int index);

  /**
   * <pre>
   * Custom TLS handshaker. If empty, defaults to native TLS handshaking
   * behavior.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13;</code>
   * @return Whether the customHandshaker field is set.
   */
  boolean hasCustomHandshaker();
  /**
   * <pre>
   * Custom TLS handshaker. If empty, defaults to native TLS handshaking
   * behavior.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13;</code>
   * @return The customHandshaker.
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getCustomHandshaker();
  /**
   * <pre>
   * Custom TLS handshaker. If empty, defaults to native TLS handshaking
   * behavior.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getCustomHandshakerOrBuilder();

  public io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.ValidationContextTypeCase getValidationContextTypeCase();
}
