// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto

package io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3;

/**
 * <pre>
 * [#next-free-field: 43]
 * </pre>
 *
 * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager}
 */
public final class HttpConnectionManager extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
    HttpConnectionManagerOrBuilder {
private static final long serialVersionUID = 0L;
  // Use HttpConnectionManager.newBuilder() to construct.
  private HttpConnectionManager(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private HttpConnectionManager() {
    codecType_ = 0;
    statPrefix_ = "";
    httpFilters_ = java.util.Collections.emptyList();
    serverName_ = "";
    serverHeaderTransformation_ = 0;
    accessLog_ = java.util.Collections.emptyList();
    via_ = "";
    forwardClientCertDetails_ = 0;
    upgradeConfigs_ = java.util.Collections.emptyList();
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new HttpConnectionManager();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private HttpConnectionManager(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {
            int rawValue = input.readEnum();

            codecType_ = rawValue;
            break;
          }
          case 18: {
            java.lang.String s = input.readStringRequireUtf8();

            statPrefix_ = s;
            break;
          }
          case 26: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder subBuilder = null;
            if (routeSpecifierCase_ == 3) {
              subBuilder = ((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_).toBuilder();
            }
            routeSpecifier_ =
                input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_);
              routeSpecifier_ = subBuilder.buildPartial();
            }
            routeSpecifierCase_ = 3;
            break;
          }
          case 34: {
            io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder subBuilder = null;
            if (routeSpecifierCase_ == 4) {
              subBuilder = ((io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_).toBuilder();
            }
            routeSpecifier_ =
                input.readMessage(io.envoyproxy.envoy.config.route.v3.RouteConfiguration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_);
              routeSpecifier_ = subBuilder.buildPartial();
            }
            routeSpecifierCase_ = 4;
            break;
          }
          case 42: {
            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
              httpFilters_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter>();
              mutable_bitField0_ |= 0x00000001;
            }
            httpFilters_.add(
                input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.parser(), extensionRegistry));
            break;
          }
          case 50: {
            com.google.protobuf.BoolValue.Builder subBuilder = null;
            if (addUserAgent_ != null) {
              subBuilder = addUserAgent_.toBuilder();
            }
            addUserAgent_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(addUserAgent_);
              addUserAgent_ = subBuilder.buildPartial();
            }

            break;
          }
          case 58: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder subBuilder = null;
            if (tracing_ != null) {
              subBuilder = tracing_.toBuilder();
            }
            tracing_ = input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(tracing_);
              tracing_ = subBuilder.buildPartial();
            }

            break;
          }
          case 66: {
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder subBuilder = null;
            if (httpProtocolOptions_ != null) {
              subBuilder = httpProtocolOptions_.toBuilder();
            }
            httpProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(httpProtocolOptions_);
              httpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 74: {
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder subBuilder = null;
            if (http2ProtocolOptions_ != null) {
              subBuilder = http2ProtocolOptions_.toBuilder();
            }
            http2ProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(http2ProtocolOptions_);
              http2ProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 82: {
            java.lang.String s = input.readStringRequireUtf8();

            serverName_ = s;
            break;
          }
          case 98: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (drainTimeout_ != null) {
              subBuilder = drainTimeout_.toBuilder();
            }
            drainTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(drainTimeout_);
              drainTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 106: {
            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
              accessLog_ = new java.util.ArrayList<io.envoyproxy.envoy.config.accesslog.v3.AccessLog>();
              mutable_bitField0_ |= 0x00000002;
            }
            accessLog_.add(
                input.readMessage(io.envoyproxy.envoy.config.accesslog.v3.AccessLog.parser(), extensionRegistry));
            break;
          }
          case 114: {
            com.google.protobuf.BoolValue.Builder subBuilder = null;
            if (useRemoteAddress_ != null) {
              subBuilder = useRemoteAddress_.toBuilder();
            }
            useRemoteAddress_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(useRemoteAddress_);
              useRemoteAddress_ = subBuilder.buildPartial();
            }

            break;
          }
          case 122: {
            com.google.protobuf.BoolValue.Builder subBuilder = null;
            if (generateRequestId_ != null) {
              subBuilder = generateRequestId_.toBuilder();
            }
            generateRequestId_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(generateRequestId_);
              generateRequestId_ = subBuilder.buildPartial();
            }

            break;
          }
          case 128: {
            int rawValue = input.readEnum();

            forwardClientCertDetails_ = rawValue;
            break;
          }
          case 138: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder subBuilder = null;
            if (setCurrentClientCertDetails_ != null) {
              subBuilder = setCurrentClientCertDetails_.toBuilder();
            }
            setCurrentClientCertDetails_ = input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(setCurrentClientCertDetails_);
              setCurrentClientCertDetails_ = subBuilder.buildPartial();
            }

            break;
          }
          case 144: {

            proxy100Continue_ = input.readBool();
            break;
          }
          case 152: {

            xffNumTrustedHops_ = input.readUInt32();
            break;
          }
          case 160: {

            representIpv4RemoteAddressAsIpv4MappedIpv6_ = input.readBool();
            break;
          }
          case 168: {

            skipXffAppend_ = input.readBool();
            break;
          }
          case 178: {
            java.lang.String s = input.readStringRequireUtf8();

            via_ = s;
            break;
          }
          case 186: {
            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
              upgradeConfigs_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig>();
              mutable_bitField0_ |= 0x00000004;
            }
            upgradeConfigs_.add(
                input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.parser(), extensionRegistry));
            break;
          }
          case 194: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (streamIdleTimeout_ != null) {
              subBuilder = streamIdleTimeout_.toBuilder();
            }
            streamIdleTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(streamIdleTimeout_);
              streamIdleTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 202: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder subBuilder = null;
            if (internalAddressConfig_ != null) {
              subBuilder = internalAddressConfig_.toBuilder();
            }
            internalAddressConfig_ = input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(internalAddressConfig_);
              internalAddressConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 210: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (delayedCloseTimeout_ != null) {
              subBuilder = delayedCloseTimeout_.toBuilder();
            }
            delayedCloseTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(delayedCloseTimeout_);
              delayedCloseTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 226: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (requestTimeout_ != null) {
              subBuilder = requestTimeout_.toBuilder();
            }
            requestTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(requestTimeout_);
              requestTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 234: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (maxRequestHeadersKb_ != null) {
              subBuilder = maxRequestHeadersKb_.toBuilder();
            }
            maxRequestHeadersKb_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(maxRequestHeadersKb_);
              maxRequestHeadersKb_ = subBuilder.buildPartial();
            }

            break;
          }
          case 242: {
            com.google.protobuf.BoolValue.Builder subBuilder = null;
            if (normalizePath_ != null) {
              subBuilder = normalizePath_.toBuilder();
            }
            normalizePath_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(normalizePath_);
              normalizePath_ = subBuilder.buildPartial();
            }

            break;
          }
          case 250: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder subBuilder = null;
            if (routeSpecifierCase_ == 31) {
              subBuilder = ((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_).toBuilder();
            }
            routeSpecifier_ =
                input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_);
              routeSpecifier_ = subBuilder.buildPartial();
            }
            routeSpecifierCase_ = 31;
            break;
          }
          case 256: {

            preserveExternalRequestId_ = input.readBool();
            break;
          }
          case 264: {

            mergeSlashes_ = input.readBool();
            break;
          }
          case 272: {
            int rawValue = input.readEnum();

            serverHeaderTransformation_ = rawValue;
            break;
          }
          case 282: {
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder subBuilder = null;
            if (commonHttpProtocolOptions_ != null) {
              subBuilder = commonHttpProtocolOptions_.toBuilder();
            }
            commonHttpProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(commonHttpProtocolOptions_);
              commonHttpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 290: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder subBuilder = null;
            if (requestIdExtension_ != null) {
              subBuilder = requestIdExtension_.toBuilder();
            }
            requestIdExtension_ = input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(requestIdExtension_);
              requestIdExtension_ = subBuilder.buildPartial();
            }

            break;
          }
          case 296: {

            alwaysSetRequestIdInResponse_ = input.readBool();
            break;
          }
          case 306: {
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder subBuilder = null;
            if (localReplyConfig_ != null) {
              subBuilder = localReplyConfig_.toBuilder();
            }
            localReplyConfig_ = input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(localReplyConfig_);
              localReplyConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 312: {

            stripMatchingHostPort_ = input.readBool();
            break;
          }
          case 322: {
            com.google.protobuf.BoolValue.Builder subBuilder = null;
            if (streamErrorOnInvalidHttpMessage_ != null) {
              subBuilder = streamErrorOnInvalidHttpMessage_.toBuilder();
            }
            streamErrorOnInvalidHttpMessage_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(streamErrorOnInvalidHttpMessage_);
              streamErrorOnInvalidHttpMessage_ = subBuilder.buildPartial();
            }

            break;
          }
          case 330: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (requestHeadersTimeout_ != null) {
              subBuilder = requestHeadersTimeout_.toBuilder();
            }
            requestHeadersTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(requestHeadersTimeout_);
              requestHeadersTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 336: {
            stripPortModeCase_ = 42;
            stripPortMode_ = input.readBool();
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000001) != 0)) {
        httpFilters_ = java.util.Collections.unmodifiableList(httpFilters_);
      }
      if (((mutable_bitField0_ & 0x00000002) != 0)) {
        accessLog_ = java.util.Collections.unmodifiableList(accessLog_);
      }
      if (((mutable_bitField0_ & 0x00000004) != 0)) {
        upgradeConfigs_ = java.util.Collections.unmodifiableList(upgradeConfigs_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Builder.class);
  }

  /**
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType}
   */
  public enum CodecType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * For every new connection, the connection manager will determine which
     * codec to use. This mode supports both ALPN for TLS listeners as well as
     * protocol inference for plaintext listeners. If ALPN data is available, it
     * is preferred, otherwise protocol inference is used. In almost all cases,
     * this is the right option to choose for this setting.
     * </pre>
     *
     * <code>AUTO = 0;</code>
     */
    AUTO(0),
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/1.1.
     * </pre>
     *
     * <code>HTTP1 = 1;</code>
     */
    HTTP1(1),
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/2
     * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
     * Prior knowledge is allowed).
     * </pre>
     *
     * <code>HTTP2 = 2;</code>
     */
    HTTP2(2),
    /**
     * <pre>
     * [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
     * caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
     * to distinguish HTTP1 and HTTP2 traffic.
     * </pre>
     *
     * <code>HTTP3 = 3;</code>
     */
    HTTP3(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * For every new connection, the connection manager will determine which
     * codec to use. This mode supports both ALPN for TLS listeners as well as
     * protocol inference for plaintext listeners. If ALPN data is available, it
     * is preferred, otherwise protocol inference is used. In almost all cases,
     * this is the right option to choose for this setting.
     * </pre>
     *
     * <code>AUTO = 0;</code>
     */
    public static final int AUTO_VALUE = 0;
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/1.1.
     * </pre>
     *
     * <code>HTTP1 = 1;</code>
     */
    public static final int HTTP1_VALUE = 1;
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/2
     * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
     * Prior knowledge is allowed).
     * </pre>
     *
     * <code>HTTP2 = 2;</code>
     */
    public static final int HTTP2_VALUE = 2;
    /**
     * <pre>
     * [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
     * caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
     * to distinguish HTTP1 and HTTP2 traffic.
     * </pre>
     *
     * <code>HTTP3 = 3;</code>
     */
    public static final int HTTP3_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CodecType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CodecType forNumber(int value) {
      switch (value) {
        case 0: return AUTO;
        case 1: return HTTP1;
        case 2: return HTTP2;
        case 3: return HTTP3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CodecType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CodecType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CodecType>() {
            public CodecType findValueByNumber(int number) {
              return CodecType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(0);
    }

    private static final CodecType[] VALUES = values();

    public static CodecType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CodecType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType)
  }

  /**
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation}
   */
  public enum ServerHeaderTransformation
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Overwrite any Server header with the contents of server_name.
     * </pre>
     *
     * <code>OVERWRITE = 0;</code>
     */
    OVERWRITE(0),
    /**
     * <pre>
     * If no Server header is present, append Server server_name
     * If a Server header is present, pass it through.
     * </pre>
     *
     * <code>APPEND_IF_ABSENT = 1;</code>
     */
    APPEND_IF_ABSENT(1),
    /**
     * <pre>
     * Pass through the value of the server header, and do not append a header
     * if none is present.
     * </pre>
     *
     * <code>PASS_THROUGH = 2;</code>
     */
    PASS_THROUGH(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Overwrite any Server header with the contents of server_name.
     * </pre>
     *
     * <code>OVERWRITE = 0;</code>
     */
    public static final int OVERWRITE_VALUE = 0;
    /**
     * <pre>
     * If no Server header is present, append Server server_name
     * If a Server header is present, pass it through.
     * </pre>
     *
     * <code>APPEND_IF_ABSENT = 1;</code>
     */
    public static final int APPEND_IF_ABSENT_VALUE = 1;
    /**
     * <pre>
     * Pass through the value of the server header, and do not append a header
     * if none is present.
     * </pre>
     *
     * <code>PASS_THROUGH = 2;</code>
     */
    public static final int PASS_THROUGH_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ServerHeaderTransformation valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerHeaderTransformation forNumber(int value) {
      switch (value) {
        case 0: return OVERWRITE;
        case 1: return APPEND_IF_ABSENT;
        case 2: return PASS_THROUGH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerHeaderTransformation>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ServerHeaderTransformation> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServerHeaderTransformation>() {
            public ServerHeaderTransformation findValueByNumber(int number) {
              return ServerHeaderTransformation.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(1);
    }

    private static final ServerHeaderTransformation[] VALUES = values();

    public static ServerHeaderTransformation valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerHeaderTransformation(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation)
  }

  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails}
   */
  public enum ForwardClientCertDetails
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Do not send the XFCC header to the next hop. This is the default value.
     * </pre>
     *
     * <code>SANITIZE = 0;</code>
     */
    SANITIZE(0),
    /**
     * <pre>
     * When the client connection is mTLS (Mutual TLS), forward the XFCC header
     * in the request.
     * </pre>
     *
     * <code>FORWARD_ONLY = 1;</code>
     */
    FORWARD_ONLY(1),
    /**
     * <pre>
     * When the client connection is mTLS, append the client certificate
     * information to the request’s XFCC header and forward it.
     * </pre>
     *
     * <code>APPEND_FORWARD = 2;</code>
     */
    APPEND_FORWARD(2),
    /**
     * <pre>
     * When the client connection is mTLS, reset the XFCC header with the client
     * certificate information and send it to the next hop.
     * </pre>
     *
     * <code>SANITIZE_SET = 3;</code>
     */
    SANITIZE_SET(3),
    /**
     * <pre>
     * Always forward the XFCC header in the request, regardless of whether the
     * client connection is mTLS.
     * </pre>
     *
     * <code>ALWAYS_FORWARD_ONLY = 4;</code>
     */
    ALWAYS_FORWARD_ONLY(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Do not send the XFCC header to the next hop. This is the default value.
     * </pre>
     *
     * <code>SANITIZE = 0;</code>
     */
    public static final int SANITIZE_VALUE = 0;
    /**
     * <pre>
     * When the client connection is mTLS (Mutual TLS), forward the XFCC header
     * in the request.
     * </pre>
     *
     * <code>FORWARD_ONLY = 1;</code>
     */
    public static final int FORWARD_ONLY_VALUE = 1;
    /**
     * <pre>
     * When the client connection is mTLS, append the client certificate
     * information to the request’s XFCC header and forward it.
     * </pre>
     *
     * <code>APPEND_FORWARD = 2;</code>
     */
    public static final int APPEND_FORWARD_VALUE = 2;
    /**
     * <pre>
     * When the client connection is mTLS, reset the XFCC header with the client
     * certificate information and send it to the next hop.
     * </pre>
     *
     * <code>SANITIZE_SET = 3;</code>
     */
    public static final int SANITIZE_SET_VALUE = 3;
    /**
     * <pre>
     * Always forward the XFCC header in the request, regardless of whether the
     * client connection is mTLS.
     * </pre>
     *
     * <code>ALWAYS_FORWARD_ONLY = 4;</code>
     */
    public static final int ALWAYS_FORWARD_ONLY_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ForwardClientCertDetails valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ForwardClientCertDetails forNumber(int value) {
      switch (value) {
        case 0: return SANITIZE;
        case 1: return FORWARD_ONLY;
        case 2: return APPEND_FORWARD;
        case 3: return SANITIZE_SET;
        case 4: return ALWAYS_FORWARD_ONLY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ForwardClientCertDetails>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ForwardClientCertDetails> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ForwardClientCertDetails>() {
            public ForwardClientCertDetails findValueByNumber(int number) {
              return ForwardClientCertDetails.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(2);
    }

    private static final ForwardClientCertDetails[] VALUES = values();

    public static ForwardClientCertDetails valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ForwardClientCertDetails(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails)
  }

  public interface TracingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return Whether the clientSampling field is set.
     */
    boolean hasClientSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return The clientSampling.
     */
    io.envoyproxy.envoy.type.v3.Percent getClientSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getClientSamplingOrBuilder();

    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return Whether the randomSampling field is set.
     */
    boolean hasRandomSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return The randomSampling.
     */
    io.envoyproxy.envoy.type.v3.Percent getRandomSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getRandomSamplingOrBuilder();

    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return Whether the overallSampling field is set.
     */
    boolean hasOverallSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return The overallSampling.
     */
    io.envoyproxy.envoy.type.v3.Percent getOverallSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getOverallSamplingOrBuilder();

    /**
     * <pre>
     * Whether to annotate spans with additional data. If true, spans will include logs for stream
     * events.
     * </pre>
     *
     * <code>bool verbose = 6;</code>
     * @return The verbose.
     */
    boolean getVerbose();

    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return Whether the maxPathTagLength field is set.
     */
    boolean hasMaxPathTagLength();
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return The maxPathTagLength.
     */
    com.google.protobuf.UInt32Value getMaxPathTagLength();
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     */
    com.google.protobuf.UInt32ValueOrBuilder getMaxPathTagLengthOrBuilder();

    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> 
        getCustomTagsList();
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    io.envoyproxy.envoy.type.tracing.v3.CustomTag getCustomTags(int index);
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    int getCustomTagsCount();
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
        getCustomTagsOrBuilderList();
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder getCustomTagsOrBuilder(
        int index);

    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return Whether the provider field is set.
     */
    boolean hasProvider();
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return The provider.
     */
    io.envoyproxy.envoy.config.trace.v3.Tracing.Http getProvider();
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     */
    io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder getProviderOrBuilder();
  }
  /**
   * <pre>
   * [#next-free-field: 10]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing}
   */
  public static final class Tracing extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
      TracingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Tracing.newBuilder() to construct.
    private Tracing(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Tracing() {
      customTags_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Tracing();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Tracing(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 26: {
              io.envoyproxy.envoy.type.v3.Percent.Builder subBuilder = null;
              if (clientSampling_ != null) {
                subBuilder = clientSampling_.toBuilder();
              }
              clientSampling_ = input.readMessage(io.envoyproxy.envoy.type.v3.Percent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(clientSampling_);
                clientSampling_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              io.envoyproxy.envoy.type.v3.Percent.Builder subBuilder = null;
              if (randomSampling_ != null) {
                subBuilder = randomSampling_.toBuilder();
              }
              randomSampling_ = input.readMessage(io.envoyproxy.envoy.type.v3.Percent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(randomSampling_);
                randomSampling_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              io.envoyproxy.envoy.type.v3.Percent.Builder subBuilder = null;
              if (overallSampling_ != null) {
                subBuilder = overallSampling_.toBuilder();
              }
              overallSampling_ = input.readMessage(io.envoyproxy.envoy.type.v3.Percent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(overallSampling_);
                overallSampling_ = subBuilder.buildPartial();
              }

              break;
            }
            case 48: {

              verbose_ = input.readBool();
              break;
            }
            case 58: {
              com.google.protobuf.UInt32Value.Builder subBuilder = null;
              if (maxPathTagLength_ != null) {
                subBuilder = maxPathTagLength_.toBuilder();
              }
              maxPathTagLength_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxPathTagLength_);
                maxPathTagLength_ = subBuilder.buildPartial();
              }

              break;
            }
            case 66: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                customTags_ = new java.util.ArrayList<io.envoyproxy.envoy.type.tracing.v3.CustomTag>();
                mutable_bitField0_ |= 0x00000001;
              }
              customTags_.add(
                  input.readMessage(io.envoyproxy.envoy.type.tracing.v3.CustomTag.parser(), extensionRegistry));
              break;
            }
            case 74: {
              io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder subBuilder = null;
              if (provider_ != null) {
                subBuilder = provider_.toBuilder();
              }
              provider_ = input.readMessage(io.envoyproxy.envoy.config.trace.v3.Tracing.Http.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(provider_);
                provider_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          customTags_ = java.util.Collections.unmodifiableList(customTags_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder.class);
    }

    /**
     * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.OperationName}
     */
    public enum OperationName
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The HTTP listener is used for ingress/incoming requests.
       * </pre>
       *
       * <code>INGRESS = 0;</code>
       */
      INGRESS(0),
      /**
       * <pre>
       * The HTTP listener is used for egress/outgoing requests.
       * </pre>
       *
       * <code>EGRESS = 1;</code>
       */
      EGRESS(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * The HTTP listener is used for ingress/incoming requests.
       * </pre>
       *
       * <code>INGRESS = 0;</code>
       */
      public static final int INGRESS_VALUE = 0;
      /**
       * <pre>
       * The HTTP listener is used for egress/outgoing requests.
       * </pre>
       *
       * <code>EGRESS = 1;</code>
       */
      public static final int EGRESS_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OperationName valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static OperationName forNumber(int value) {
        switch (value) {
          case 0: return INGRESS;
          case 1: return EGRESS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OperationName>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OperationName> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OperationName>() {
              public OperationName findValueByNumber(int number) {
                return OperationName.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDescriptor().getEnumTypes().get(0);
      }

      private static final OperationName[] VALUES = values();

      public static OperationName valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private OperationName(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.OperationName)
    }

    public static final int CLIENT_SAMPLING_FIELD_NUMBER = 3;
    private io.envoyproxy.envoy.type.v3.Percent clientSampling_;
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return Whether the clientSampling field is set.
     */
    @java.lang.Override
    public boolean hasClientSampling() {
      return clientSampling_ != null;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return The clientSampling.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getClientSampling() {
      return clientSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getClientSamplingOrBuilder() {
      return getClientSampling();
    }

    public static final int RANDOM_SAMPLING_FIELD_NUMBER = 4;
    private io.envoyproxy.envoy.type.v3.Percent randomSampling_;
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return Whether the randomSampling field is set.
     */
    @java.lang.Override
    public boolean hasRandomSampling() {
      return randomSampling_ != null;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return The randomSampling.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getRandomSampling() {
      return randomSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getRandomSamplingOrBuilder() {
      return getRandomSampling();
    }

    public static final int OVERALL_SAMPLING_FIELD_NUMBER = 5;
    private io.envoyproxy.envoy.type.v3.Percent overallSampling_;
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return Whether the overallSampling field is set.
     */
    @java.lang.Override
    public boolean hasOverallSampling() {
      return overallSampling_ != null;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return The overallSampling.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getOverallSampling() {
      return overallSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getOverallSamplingOrBuilder() {
      return getOverallSampling();
    }

    public static final int VERBOSE_FIELD_NUMBER = 6;
    private boolean verbose_;
    /**
     * <pre>
     * Whether to annotate spans with additional data. If true, spans will include logs for stream
     * events.
     * </pre>
     *
     * <code>bool verbose = 6;</code>
     * @return The verbose.
     */
    @java.lang.Override
    public boolean getVerbose() {
      return verbose_;
    }

    public static final int MAX_PATH_TAG_LENGTH_FIELD_NUMBER = 7;
    private com.google.protobuf.UInt32Value maxPathTagLength_;
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return Whether the maxPathTagLength field is set.
     */
    @java.lang.Override
    public boolean hasMaxPathTagLength() {
      return maxPathTagLength_ != null;
    }
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return The maxPathTagLength.
     */
    @java.lang.Override
    public com.google.protobuf.UInt32Value getMaxPathTagLength() {
      return maxPathTagLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
    }
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt32ValueOrBuilder getMaxPathTagLengthOrBuilder() {
      return getMaxPathTagLength();
    }

    public static final int CUSTOM_TAGS_FIELD_NUMBER = 8;
    private java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> customTags_;
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> getCustomTagsList() {
      return customTags_;
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
        getCustomTagsOrBuilderList() {
      return customTags_;
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public int getCustomTagsCount() {
      return customTags_.size();
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.tracing.v3.CustomTag getCustomTags(int index) {
      return customTags_.get(index);
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder getCustomTagsOrBuilder(
        int index) {
      return customTags_.get(index);
    }

    public static final int PROVIDER_FIELD_NUMBER = 9;
    private io.envoyproxy.envoy.config.trace.v3.Tracing.Http provider_;
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return Whether the provider field is set.
     */
    @java.lang.Override
    public boolean hasProvider() {
      return provider_ != null;
    }
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return The provider.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.trace.v3.Tracing.Http getProvider() {
      return provider_ == null ? io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
    }
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder getProviderOrBuilder() {
      return getProvider();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (clientSampling_ != null) {
        output.writeMessage(3, getClientSampling());
      }
      if (randomSampling_ != null) {
        output.writeMessage(4, getRandomSampling());
      }
      if (overallSampling_ != null) {
        output.writeMessage(5, getOverallSampling());
      }
      if (verbose_ != false) {
        output.writeBool(6, verbose_);
      }
      if (maxPathTagLength_ != null) {
        output.writeMessage(7, getMaxPathTagLength());
      }
      for (int i = 0; i < customTags_.size(); i++) {
        output.writeMessage(8, customTags_.get(i));
      }
      if (provider_ != null) {
        output.writeMessage(9, getProvider());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (clientSampling_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getClientSampling());
      }
      if (randomSampling_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getRandomSampling());
      }
      if (overallSampling_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getOverallSampling());
      }
      if (verbose_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, verbose_);
      }
      if (maxPathTagLength_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getMaxPathTagLength());
      }
      for (int i = 0; i < customTags_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, customTags_.get(i));
      }
      if (provider_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getProvider());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing) obj;

      if (hasClientSampling() != other.hasClientSampling()) return false;
      if (hasClientSampling()) {
        if (!getClientSampling()
            .equals(other.getClientSampling())) return false;
      }
      if (hasRandomSampling() != other.hasRandomSampling()) return false;
      if (hasRandomSampling()) {
        if (!getRandomSampling()
            .equals(other.getRandomSampling())) return false;
      }
      if (hasOverallSampling() != other.hasOverallSampling()) return false;
      if (hasOverallSampling()) {
        if (!getOverallSampling()
            .equals(other.getOverallSampling())) return false;
      }
      if (getVerbose()
          != other.getVerbose()) return false;
      if (hasMaxPathTagLength() != other.hasMaxPathTagLength()) return false;
      if (hasMaxPathTagLength()) {
        if (!getMaxPathTagLength()
            .equals(other.getMaxPathTagLength())) return false;
      }
      if (!getCustomTagsList()
          .equals(other.getCustomTagsList())) return false;
      if (hasProvider() != other.hasProvider()) return false;
      if (hasProvider()) {
        if (!getProvider()
            .equals(other.getProvider())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasClientSampling()) {
        hash = (37 * hash) + CLIENT_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getClientSampling().hashCode();
      }
      if (hasRandomSampling()) {
        hash = (37 * hash) + RANDOM_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getRandomSampling().hashCode();
      }
      if (hasOverallSampling()) {
        hash = (37 * hash) + OVERALL_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getOverallSampling().hashCode();
      }
      hash = (37 * hash) + VERBOSE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getVerbose());
      if (hasMaxPathTagLength()) {
        hash = (37 * hash) + MAX_PATH_TAG_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getMaxPathTagLength().hashCode();
      }
      if (getCustomTagsCount() > 0) {
        hash = (37 * hash) + CUSTOM_TAGS_FIELD_NUMBER;
        hash = (53 * hash) + getCustomTagsList().hashCode();
      }
      if (hasProvider()) {
        hash = (37 * hash) + PROVIDER_FIELD_NUMBER;
        hash = (53 * hash) + getProvider().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#next-free-field: 10]
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCustomTagsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (clientSamplingBuilder_ == null) {
          clientSampling_ = null;
        } else {
          clientSampling_ = null;
          clientSamplingBuilder_ = null;
        }
        if (randomSamplingBuilder_ == null) {
          randomSampling_ = null;
        } else {
          randomSampling_ = null;
          randomSamplingBuilder_ = null;
        }
        if (overallSamplingBuilder_ == null) {
          overallSampling_ = null;
        } else {
          overallSampling_ = null;
          overallSamplingBuilder_ = null;
        }
        verbose_ = false;

        if (maxPathTagLengthBuilder_ == null) {
          maxPathTagLength_ = null;
        } else {
          maxPathTagLength_ = null;
          maxPathTagLengthBuilder_ = null;
        }
        if (customTagsBuilder_ == null) {
          customTags_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          customTagsBuilder_.clear();
        }
        if (providerBuilder_ == null) {
          provider_ = null;
        } else {
          provider_ = null;
          providerBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing(this);
        int from_bitField0_ = bitField0_;
        if (clientSamplingBuilder_ == null) {
          result.clientSampling_ = clientSampling_;
        } else {
          result.clientSampling_ = clientSamplingBuilder_.build();
        }
        if (randomSamplingBuilder_ == null) {
          result.randomSampling_ = randomSampling_;
        } else {
          result.randomSampling_ = randomSamplingBuilder_.build();
        }
        if (overallSamplingBuilder_ == null) {
          result.overallSampling_ = overallSampling_;
        } else {
          result.overallSampling_ = overallSamplingBuilder_.build();
        }
        result.verbose_ = verbose_;
        if (maxPathTagLengthBuilder_ == null) {
          result.maxPathTagLength_ = maxPathTagLength_;
        } else {
          result.maxPathTagLength_ = maxPathTagLengthBuilder_.build();
        }
        if (customTagsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            customTags_ = java.util.Collections.unmodifiableList(customTags_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.customTags_ = customTags_;
        } else {
          result.customTags_ = customTagsBuilder_.build();
        }
        if (providerBuilder_ == null) {
          result.provider_ = provider_;
        } else {
          result.provider_ = providerBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance()) return this;
        if (other.hasClientSampling()) {
          mergeClientSampling(other.getClientSampling());
        }
        if (other.hasRandomSampling()) {
          mergeRandomSampling(other.getRandomSampling());
        }
        if (other.hasOverallSampling()) {
          mergeOverallSampling(other.getOverallSampling());
        }
        if (other.getVerbose() != false) {
          setVerbose(other.getVerbose());
        }
        if (other.hasMaxPathTagLength()) {
          mergeMaxPathTagLength(other.getMaxPathTagLength());
        }
        if (customTagsBuilder_ == null) {
          if (!other.customTags_.isEmpty()) {
            if (customTags_.isEmpty()) {
              customTags_ = other.customTags_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCustomTagsIsMutable();
              customTags_.addAll(other.customTags_);
            }
            onChanged();
          }
        } else {
          if (!other.customTags_.isEmpty()) {
            if (customTagsBuilder_.isEmpty()) {
              customTagsBuilder_.dispose();
              customTagsBuilder_ = null;
              customTags_ = other.customTags_;
              bitField0_ = (bitField0_ & ~0x00000001);
              customTagsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCustomTagsFieldBuilder() : null;
            } else {
              customTagsBuilder_.addAllMessages(other.customTags_);
            }
          }
        }
        if (other.hasProvider()) {
          mergeProvider(other.getProvider());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.envoyproxy.envoy.type.v3.Percent clientSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> clientSamplingBuilder_;
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       * @return Whether the clientSampling field is set.
       */
      public boolean hasClientSampling() {
        return clientSamplingBuilder_ != null || clientSampling_ != null;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       * @return The clientSampling.
       */
      public io.envoyproxy.envoy.type.v3.Percent getClientSampling() {
        if (clientSamplingBuilder_ == null) {
          return clientSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
        } else {
          return clientSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder setClientSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (clientSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientSampling_ = value;
          onChanged();
        } else {
          clientSamplingBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder setClientSampling(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (clientSamplingBuilder_ == null) {
          clientSampling_ = builderForValue.build();
          onChanged();
        } else {
          clientSamplingBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder mergeClientSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (clientSamplingBuilder_ == null) {
          if (clientSampling_ != null) {
            clientSampling_ =
              io.envoyproxy.envoy.type.v3.Percent.newBuilder(clientSampling_).mergeFrom(value).buildPartial();
          } else {
            clientSampling_ = value;
          }
          onChanged();
        } else {
          clientSamplingBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder clearClientSampling() {
        if (clientSamplingBuilder_ == null) {
          clientSampling_ = null;
          onChanged();
        } else {
          clientSampling_ = null;
          clientSamplingBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getClientSamplingBuilder() {
        
        onChanged();
        return getClientSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getClientSamplingOrBuilder() {
        if (clientSamplingBuilder_ != null) {
          return clientSamplingBuilder_.getMessageOrBuilder();
        } else {
          return clientSampling_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getClientSamplingFieldBuilder() {
        if (clientSamplingBuilder_ == null) {
          clientSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getClientSampling(),
                  getParentForChildren(),
                  isClean());
          clientSampling_ = null;
        }
        return clientSamplingBuilder_;
      }

      private io.envoyproxy.envoy.type.v3.Percent randomSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> randomSamplingBuilder_;
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       * @return Whether the randomSampling field is set.
       */
      public boolean hasRandomSampling() {
        return randomSamplingBuilder_ != null || randomSampling_ != null;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       * @return The randomSampling.
       */
      public io.envoyproxy.envoy.type.v3.Percent getRandomSampling() {
        if (randomSamplingBuilder_ == null) {
          return randomSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
        } else {
          return randomSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder setRandomSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (randomSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          randomSampling_ = value;
          onChanged();
        } else {
          randomSamplingBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder setRandomSampling(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (randomSamplingBuilder_ == null) {
          randomSampling_ = builderForValue.build();
          onChanged();
        } else {
          randomSamplingBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder mergeRandomSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (randomSamplingBuilder_ == null) {
          if (randomSampling_ != null) {
            randomSampling_ =
              io.envoyproxy.envoy.type.v3.Percent.newBuilder(randomSampling_).mergeFrom(value).buildPartial();
          } else {
            randomSampling_ = value;
          }
          onChanged();
        } else {
          randomSamplingBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder clearRandomSampling() {
        if (randomSamplingBuilder_ == null) {
          randomSampling_ = null;
          onChanged();
        } else {
          randomSampling_ = null;
          randomSamplingBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getRandomSamplingBuilder() {
        
        onChanged();
        return getRandomSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getRandomSamplingOrBuilder() {
        if (randomSamplingBuilder_ != null) {
          return randomSamplingBuilder_.getMessageOrBuilder();
        } else {
          return randomSampling_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getRandomSamplingFieldBuilder() {
        if (randomSamplingBuilder_ == null) {
          randomSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getRandomSampling(),
                  getParentForChildren(),
                  isClean());
          randomSampling_ = null;
        }
        return randomSamplingBuilder_;
      }

      private io.envoyproxy.envoy.type.v3.Percent overallSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> overallSamplingBuilder_;
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       * @return Whether the overallSampling field is set.
       */
      public boolean hasOverallSampling() {
        return overallSamplingBuilder_ != null || overallSampling_ != null;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       * @return The overallSampling.
       */
      public io.envoyproxy.envoy.type.v3.Percent getOverallSampling() {
        if (overallSamplingBuilder_ == null) {
          return overallSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
        } else {
          return overallSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder setOverallSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (overallSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          overallSampling_ = value;
          onChanged();
        } else {
          overallSamplingBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder setOverallSampling(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (overallSamplingBuilder_ == null) {
          overallSampling_ = builderForValue.build();
          onChanged();
        } else {
          overallSamplingBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder mergeOverallSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (overallSamplingBuilder_ == null) {
          if (overallSampling_ != null) {
            overallSampling_ =
              io.envoyproxy.envoy.type.v3.Percent.newBuilder(overallSampling_).mergeFrom(value).buildPartial();
          } else {
            overallSampling_ = value;
          }
          onChanged();
        } else {
          overallSamplingBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder clearOverallSampling() {
        if (overallSamplingBuilder_ == null) {
          overallSampling_ = null;
          onChanged();
        } else {
          overallSampling_ = null;
          overallSamplingBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getOverallSamplingBuilder() {
        
        onChanged();
        return getOverallSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getOverallSamplingOrBuilder() {
        if (overallSamplingBuilder_ != null) {
          return overallSamplingBuilder_.getMessageOrBuilder();
        } else {
          return overallSampling_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getOverallSamplingFieldBuilder() {
        if (overallSamplingBuilder_ == null) {
          overallSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getOverallSampling(),
                  getParentForChildren(),
                  isClean());
          overallSampling_ = null;
        }
        return overallSamplingBuilder_;
      }

      private boolean verbose_ ;
      /**
       * <pre>
       * Whether to annotate spans with additional data. If true, spans will include logs for stream
       * events.
       * </pre>
       *
       * <code>bool verbose = 6;</code>
       * @return The verbose.
       */
      @java.lang.Override
      public boolean getVerbose() {
        return verbose_;
      }
      /**
       * <pre>
       * Whether to annotate spans with additional data. If true, spans will include logs for stream
       * events.
       * </pre>
       *
       * <code>bool verbose = 6;</code>
       * @param value The verbose to set.
       * @return This builder for chaining.
       */
      public Builder setVerbose(boolean value) {
        
        verbose_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to annotate spans with additional data. If true, spans will include logs for stream
       * events.
       * </pre>
       *
       * <code>bool verbose = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearVerbose() {
        
        verbose_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.UInt32Value maxPathTagLength_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxPathTagLengthBuilder_;
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       * @return Whether the maxPathTagLength field is set.
       */
      public boolean hasMaxPathTagLength() {
        return maxPathTagLengthBuilder_ != null || maxPathTagLength_ != null;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       * @return The maxPathTagLength.
       */
      public com.google.protobuf.UInt32Value getMaxPathTagLength() {
        if (maxPathTagLengthBuilder_ == null) {
          return maxPathTagLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
        } else {
          return maxPathTagLengthBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder setMaxPathTagLength(com.google.protobuf.UInt32Value value) {
        if (maxPathTagLengthBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxPathTagLength_ = value;
          onChanged();
        } else {
          maxPathTagLengthBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder setMaxPathTagLength(
          com.google.protobuf.UInt32Value.Builder builderForValue) {
        if (maxPathTagLengthBuilder_ == null) {
          maxPathTagLength_ = builderForValue.build();
          onChanged();
        } else {
          maxPathTagLengthBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder mergeMaxPathTagLength(com.google.protobuf.UInt32Value value) {
        if (maxPathTagLengthBuilder_ == null) {
          if (maxPathTagLength_ != null) {
            maxPathTagLength_ =
              com.google.protobuf.UInt32Value.newBuilder(maxPathTagLength_).mergeFrom(value).buildPartial();
          } else {
            maxPathTagLength_ = value;
          }
          onChanged();
        } else {
          maxPathTagLengthBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder clearMaxPathTagLength() {
        if (maxPathTagLengthBuilder_ == null) {
          maxPathTagLength_ = null;
          onChanged();
        } else {
          maxPathTagLength_ = null;
          maxPathTagLengthBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public com.google.protobuf.UInt32Value.Builder getMaxPathTagLengthBuilder() {
        
        onChanged();
        return getMaxPathTagLengthFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public com.google.protobuf.UInt32ValueOrBuilder getMaxPathTagLengthOrBuilder() {
        if (maxPathTagLengthBuilder_ != null) {
          return maxPathTagLengthBuilder_.getMessageOrBuilder();
        } else {
          return maxPathTagLength_ == null ?
              com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
        }
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
          getMaxPathTagLengthFieldBuilder() {
        if (maxPathTagLengthBuilder_ == null) {
          maxPathTagLengthBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                  getMaxPathTagLength(),
                  getParentForChildren(),
                  isClean());
          maxPathTagLength_ = null;
        }
        return maxPathTagLengthBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> customTags_ =
        java.util.Collections.emptyList();
      private void ensureCustomTagsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          customTags_ = new java.util.ArrayList<io.envoyproxy.envoy.type.tracing.v3.CustomTag>(customTags_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.tracing.v3.CustomTag, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder, io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> customTagsBuilder_;

      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> getCustomTagsList() {
        if (customTagsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(customTags_);
        } else {
          return customTagsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public int getCustomTagsCount() {
        if (customTagsBuilder_ == null) {
          return customTags_.size();
        } else {
          return customTagsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag getCustomTags(int index) {
        if (customTagsBuilder_ == null) {
          return customTags_.get(index);
        } else {
          return customTagsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder setCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag value) {
        if (customTagsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCustomTagsIsMutable();
          customTags_.set(index, value);
          onChanged();
        } else {
          customTagsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder setCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder builderForValue) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.set(index, builderForValue.build());
          onChanged();
        } else {
          customTagsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(io.envoyproxy.envoy.type.tracing.v3.CustomTag value) {
        if (customTagsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCustomTagsIsMutable();
          customTags_.add(value);
          onChanged();
        } else {
          customTagsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag value) {
        if (customTagsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCustomTagsIsMutable();
          customTags_.add(index, value);
          onChanged();
        } else {
          customTagsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(
          io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder builderForValue) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.add(builderForValue.build());
          onChanged();
        } else {
          customTagsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder builderForValue) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.add(index, builderForValue.build());
          onChanged();
        } else {
          customTagsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addAllCustomTags(
          java.lang.Iterable<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTag> values) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, customTags_);
          onChanged();
        } else {
          customTagsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder clearCustomTags() {
        if (customTagsBuilder_ == null) {
          customTags_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          customTagsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder removeCustomTags(int index) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.remove(index);
          onChanged();
        } else {
          customTagsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder getCustomTagsBuilder(
          int index) {
        return getCustomTagsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder getCustomTagsOrBuilder(
          int index) {
        if (customTagsBuilder_ == null) {
          return customTags_.get(index);  } else {
          return customTagsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
           getCustomTagsOrBuilderList() {
        if (customTagsBuilder_ != null) {
          return customTagsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(customTags_);
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder addCustomTagsBuilder() {
        return getCustomTagsFieldBuilder().addBuilder(
            io.envoyproxy.envoy.type.tracing.v3.CustomTag.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder addCustomTagsBuilder(
          int index) {
        return getCustomTagsFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.type.tracing.v3.CustomTag.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder> 
           getCustomTagsBuilderList() {
        return getCustomTagsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.tracing.v3.CustomTag, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder, io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
          getCustomTagsFieldBuilder() {
        if (customTagsBuilder_ == null) {
          customTagsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.type.tracing.v3.CustomTag, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder, io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder>(
                  customTags_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          customTags_ = null;
        }
        return customTagsBuilder_;
      }

      private io.envoyproxy.envoy.config.trace.v3.Tracing.Http provider_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.trace.v3.Tracing.Http, io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder, io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder> providerBuilder_;
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       * @return Whether the provider field is set.
       */
      public boolean hasProvider() {
        return providerBuilder_ != null || provider_ != null;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       * @return The provider.
       */
      public io.envoyproxy.envoy.config.trace.v3.Tracing.Http getProvider() {
        if (providerBuilder_ == null) {
          return provider_ == null ? io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
        } else {
          return providerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder setProvider(io.envoyproxy.envoy.config.trace.v3.Tracing.Http value) {
        if (providerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          provider_ = value;
          onChanged();
        } else {
          providerBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder setProvider(
          io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder builderForValue) {
        if (providerBuilder_ == null) {
          provider_ = builderForValue.build();
          onChanged();
        } else {
          providerBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder mergeProvider(io.envoyproxy.envoy.config.trace.v3.Tracing.Http value) {
        if (providerBuilder_ == null) {
          if (provider_ != null) {
            provider_ =
              io.envoyproxy.envoy.config.trace.v3.Tracing.Http.newBuilder(provider_).mergeFrom(value).buildPartial();
          } else {
            provider_ = value;
          }
          onChanged();
        } else {
          providerBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder clearProvider() {
        if (providerBuilder_ == null) {
          provider_ = null;
          onChanged();
        } else {
          provider_ = null;
          providerBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder getProviderBuilder() {
        
        onChanged();
        return getProviderFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder getProviderOrBuilder() {
        if (providerBuilder_ != null) {
          return providerBuilder_.getMessageOrBuilder();
        } else {
          return provider_ == null ?
              io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
        }
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.trace.v3.Tracing.Http, io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder, io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder> 
          getProviderFieldBuilder() {
        if (providerBuilder_ == null) {
          providerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.trace.v3.Tracing.Http, io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder, io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder>(
                  getProvider(),
                  getParentForChildren(),
                  isClean());
          provider_ = null;
        }
        return providerBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Tracing>
        PARSER = new com.google.protobuf.AbstractParser<Tracing>() {
      @java.lang.Override
      public Tracing parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Tracing(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Tracing> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Tracing> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InternalAddressConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether unix socket addresses should be considered internal.
     * </pre>
     *
     * <code>bool unix_sockets = 1;</code>
     * @return The unixSockets.
     */
    boolean getUnixSockets();
  }
  /**
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig}
   */
  public static final class InternalAddressConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
      InternalAddressConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InternalAddressConfig.newBuilder() to construct.
    private InternalAddressConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InternalAddressConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InternalAddressConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private InternalAddressConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              unixSockets_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder.class);
    }

    public static final int UNIX_SOCKETS_FIELD_NUMBER = 1;
    private boolean unixSockets_;
    /**
     * <pre>
     * Whether unix socket addresses should be considered internal.
     * </pre>
     *
     * <code>bool unix_sockets = 1;</code>
     * @return The unixSockets.
     */
    @java.lang.Override
    public boolean getUnixSockets() {
      return unixSockets_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (unixSockets_ != false) {
        output.writeBool(1, unixSockets_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (unixSockets_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, unixSockets_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig) obj;

      if (getUnixSockets()
          != other.getUnixSockets()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + UNIX_SOCKETS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUnixSockets());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        unixSockets_ = false;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig(this);
        result.unixSockets_ = unixSockets_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance()) return this;
        if (other.getUnixSockets() != false) {
          setUnixSockets(other.getUnixSockets());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private boolean unixSockets_ ;
      /**
       * <pre>
       * Whether unix socket addresses should be considered internal.
       * </pre>
       *
       * <code>bool unix_sockets = 1;</code>
       * @return The unixSockets.
       */
      @java.lang.Override
      public boolean getUnixSockets() {
        return unixSockets_;
      }
      /**
       * <pre>
       * Whether unix socket addresses should be considered internal.
       * </pre>
       *
       * <code>bool unix_sockets = 1;</code>
       * @param value The unixSockets to set.
       * @return This builder for chaining.
       */
      public Builder setUnixSockets(boolean value) {
        
        unixSockets_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether unix socket addresses should be considered internal.
       * </pre>
       *
       * <code>bool unix_sockets = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnixSockets() {
        
        unixSockets_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InternalAddressConfig>
        PARSER = new com.google.protobuf.AbstractParser<InternalAddressConfig>() {
      @java.lang.Override
      public InternalAddressConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new InternalAddressConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InternalAddressConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InternalAddressConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SetCurrentClientCertDetailsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return Whether the subject field is set.
     */
    boolean hasSubject();
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return The subject.
     */
    com.google.protobuf.BoolValue getSubject();
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getSubjectOrBuilder();

    /**
     * <pre>
     * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
     * XFCC header comma separated from other values with the value Cert="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool cert = 3;</code>
     * @return The cert.
     */
    boolean getCert();

    /**
     * <pre>
     * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
     * format. This will appear in the XFCC header comma separated from other values with the value
     * Chain="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool chain = 6;</code>
     * @return The chain.
     */
    boolean getChain();

    /**
     * <pre>
     * Whether to forward the DNS type Subject Alternative Names of the client cert.
     * Defaults to false.
     * </pre>
     *
     * <code>bool dns = 4;</code>
     * @return The dns.
     */
    boolean getDns();

    /**
     * <pre>
     * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
     * false.
     * </pre>
     *
     * <code>bool uri = 5;</code>
     * @return The uri.
     */
    boolean getUri();
  }
  /**
   * <pre>
   * [#next-free-field: 7]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails}
   */
  public static final class SetCurrentClientCertDetails extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
      SetCurrentClientCertDetailsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SetCurrentClientCertDetails.newBuilder() to construct.
    private SetCurrentClientCertDetails(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SetCurrentClientCertDetails() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SetCurrentClientCertDetails();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SetCurrentClientCertDetails(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (subject_ != null) {
                subBuilder = subject_.toBuilder();
              }
              subject_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(subject_);
                subject_ = subBuilder.buildPartial();
              }

              break;
            }
            case 24: {

              cert_ = input.readBool();
              break;
            }
            case 32: {

              dns_ = input.readBool();
              break;
            }
            case 40: {

              uri_ = input.readBool();
              break;
            }
            case 48: {

              chain_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder.class);
    }

    public static final int SUBJECT_FIELD_NUMBER = 1;
    private com.google.protobuf.BoolValue subject_;
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return Whether the subject field is set.
     */
    @java.lang.Override
    public boolean hasSubject() {
      return subject_ != null;
    }
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return The subject.
     */
    @java.lang.Override
    public com.google.protobuf.BoolValue getSubject() {
      return subject_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
    }
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.BoolValueOrBuilder getSubjectOrBuilder() {
      return getSubject();
    }

    public static final int CERT_FIELD_NUMBER = 3;
    private boolean cert_;
    /**
     * <pre>
     * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
     * XFCC header comma separated from other values with the value Cert="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool cert = 3;</code>
     * @return The cert.
     */
    @java.lang.Override
    public boolean getCert() {
      return cert_;
    }

    public static final int CHAIN_FIELD_NUMBER = 6;
    private boolean chain_;
    /**
     * <pre>
     * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
     * format. This will appear in the XFCC header comma separated from other values with the value
     * Chain="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool chain = 6;</code>
     * @return The chain.
     */
    @java.lang.Override
    public boolean getChain() {
      return chain_;
    }

    public static final int DNS_FIELD_NUMBER = 4;
    private boolean dns_;
    /**
     * <pre>
     * Whether to forward the DNS type Subject Alternative Names of the client cert.
     * Defaults to false.
     * </pre>
     *
     * <code>bool dns = 4;</code>
     * @return The dns.
     */
    @java.lang.Override
    public boolean getDns() {
      return dns_;
    }

    public static final int URI_FIELD_NUMBER = 5;
    private boolean uri_;
    /**
     * <pre>
     * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
     * false.
     * </pre>
     *
     * <code>bool uri = 5;</code>
     * @return The uri.
     */
    @java.lang.Override
    public boolean getUri() {
      return uri_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (subject_ != null) {
        output.writeMessage(1, getSubject());
      }
      if (cert_ != false) {
        output.writeBool(3, cert_);
      }
      if (dns_ != false) {
        output.writeBool(4, dns_);
      }
      if (uri_ != false) {
        output.writeBool(5, uri_);
      }
      if (chain_ != false) {
        output.writeBool(6, chain_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (subject_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSubject());
      }
      if (cert_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, cert_);
      }
      if (dns_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, dns_);
      }
      if (uri_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, uri_);
      }
      if (chain_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, chain_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails) obj;

      if (hasSubject() != other.hasSubject()) return false;
      if (hasSubject()) {
        if (!getSubject()
            .equals(other.getSubject())) return false;
      }
      if (getCert()
          != other.getCert()) return false;
      if (getChain()
          != other.getChain()) return false;
      if (getDns()
          != other.getDns()) return false;
      if (getUri()
          != other.getUri()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSubject()) {
        hash = (37 * hash) + SUBJECT_FIELD_NUMBER;
        hash = (53 * hash) + getSubject().hashCode();
      }
      hash = (37 * hash) + CERT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getCert());
      hash = (37 * hash) + CHAIN_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getChain());
      hash = (37 * hash) + DNS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getDns());
      hash = (37 * hash) + URI_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUri());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#next-free-field: 7]
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (subjectBuilder_ == null) {
          subject_ = null;
        } else {
          subject_ = null;
          subjectBuilder_ = null;
        }
        cert_ = false;

        chain_ = false;

        dns_ = false;

        uri_ = false;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails(this);
        if (subjectBuilder_ == null) {
          result.subject_ = subject_;
        } else {
          result.subject_ = subjectBuilder_.build();
        }
        result.cert_ = cert_;
        result.chain_ = chain_;
        result.dns_ = dns_;
        result.uri_ = uri_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance()) return this;
        if (other.hasSubject()) {
          mergeSubject(other.getSubject());
        }
        if (other.getCert() != false) {
          setCert(other.getCert());
        }
        if (other.getChain() != false) {
          setChain(other.getChain());
        }
        if (other.getDns() != false) {
          setDns(other.getDns());
        }
        if (other.getUri() != false) {
          setUri(other.getUri());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.BoolValue subject_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> subjectBuilder_;
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       * @return Whether the subject field is set.
       */
      public boolean hasSubject() {
        return subjectBuilder_ != null || subject_ != null;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       * @return The subject.
       */
      public com.google.protobuf.BoolValue getSubject() {
        if (subjectBuilder_ == null) {
          return subject_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
        } else {
          return subjectBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder setSubject(com.google.protobuf.BoolValue value) {
        if (subjectBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          subject_ = value;
          onChanged();
        } else {
          subjectBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder setSubject(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (subjectBuilder_ == null) {
          subject_ = builderForValue.build();
          onChanged();
        } else {
          subjectBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder mergeSubject(com.google.protobuf.BoolValue value) {
        if (subjectBuilder_ == null) {
          if (subject_ != null) {
            subject_ =
              com.google.protobuf.BoolValue.newBuilder(subject_).mergeFrom(value).buildPartial();
          } else {
            subject_ = value;
          }
          onChanged();
        } else {
          subjectBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder clearSubject() {
        if (subjectBuilder_ == null) {
          subject_ = null;
          onChanged();
        } else {
          subject_ = null;
          subjectBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public com.google.protobuf.BoolValue.Builder getSubjectBuilder() {
        
        onChanged();
        return getSubjectFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getSubjectOrBuilder() {
        if (subjectBuilder_ != null) {
          return subjectBuilder_.getMessageOrBuilder();
        } else {
          return subject_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
        }
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getSubjectFieldBuilder() {
        if (subjectBuilder_ == null) {
          subjectBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getSubject(),
                  getParentForChildren(),
                  isClean());
          subject_ = null;
        }
        return subjectBuilder_;
      }

      private boolean cert_ ;
      /**
       * <pre>
       * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
       * XFCC header comma separated from other values with the value Cert="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool cert = 3;</code>
       * @return The cert.
       */
      @java.lang.Override
      public boolean getCert() {
        return cert_;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
       * XFCC header comma separated from other values with the value Cert="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool cert = 3;</code>
       * @param value The cert to set.
       * @return This builder for chaining.
       */
      public Builder setCert(boolean value) {
        
        cert_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
       * XFCC header comma separated from other values with the value Cert="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool cert = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCert() {
        
        cert_ = false;
        onChanged();
        return this;
      }

      private boolean chain_ ;
      /**
       * <pre>
       * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
       * format. This will appear in the XFCC header comma separated from other values with the value
       * Chain="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool chain = 6;</code>
       * @return The chain.
       */
      @java.lang.Override
      public boolean getChain() {
        return chain_;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
       * format. This will appear in the XFCC header comma separated from other values with the value
       * Chain="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool chain = 6;</code>
       * @param value The chain to set.
       * @return This builder for chaining.
       */
      public Builder setChain(boolean value) {
        
        chain_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
       * format. This will appear in the XFCC header comma separated from other values with the value
       * Chain="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool chain = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearChain() {
        
        chain_ = false;
        onChanged();
        return this;
      }

      private boolean dns_ ;
      /**
       * <pre>
       * Whether to forward the DNS type Subject Alternative Names of the client cert.
       * Defaults to false.
       * </pre>
       *
       * <code>bool dns = 4;</code>
       * @return The dns.
       */
      @java.lang.Override
      public boolean getDns() {
        return dns_;
      }
      /**
       * <pre>
       * Whether to forward the DNS type Subject Alternative Names of the client cert.
       * Defaults to false.
       * </pre>
       *
       * <code>bool dns = 4;</code>
       * @param value The dns to set.
       * @return This builder for chaining.
       */
      public Builder setDns(boolean value) {
        
        dns_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the DNS type Subject Alternative Names of the client cert.
       * Defaults to false.
       * </pre>
       *
       * <code>bool dns = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDns() {
        
        dns_ = false;
        onChanged();
        return this;
      }

      private boolean uri_ ;
      /**
       * <pre>
       * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
       * false.
       * </pre>
       *
       * <code>bool uri = 5;</code>
       * @return The uri.
       */
      @java.lang.Override
      public boolean getUri() {
        return uri_;
      }
      /**
       * <pre>
       * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
       * false.
       * </pre>
       *
       * <code>bool uri = 5;</code>
       * @param value The uri to set.
       * @return This builder for chaining.
       */
      public Builder setUri(boolean value) {
        
        uri_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
       * false.
       * </pre>
       *
       * <code>bool uri = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUri() {
        
        uri_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SetCurrentClientCertDetails>
        PARSER = new com.google.protobuf.AbstractParser<SetCurrentClientCertDetails>() {
      @java.lang.Override
      public SetCurrentClientCertDetails parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SetCurrentClientCertDetails(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SetCurrentClientCertDetails> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SetCurrentClientCertDetails> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface UpgradeConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The upgradeType.
     */
    java.lang.String getUpgradeType();
    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The bytes for upgradeType.
     */
    com.google.protobuf.ByteString
        getUpgradeTypeBytes();

    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> 
        getFiltersList();
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getFilters(int index);
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    int getFiltersCount();
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
        getFiltersOrBuilderList();
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getFiltersOrBuilder(
        int index);

    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return Whether the enabled field is set.
     */
    boolean hasEnabled();
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return The enabled.
     */
    com.google.protobuf.BoolValue getEnabled();
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getEnabledOrBuilder();
  }
  /**
   * <pre>
   * The configuration for HTTP upgrades.
   * For each upgrade type desired, an UpgradeConfig must be added.
   * .. warning::
   *    The current implementation of upgrade headers does not handle
   *    multi-valued upgrade headers. Support for multi-valued headers may be
   *    added in the future if needed.
   * .. warning::
   *    The current implementation of upgrade headers does not work with HTTP/2
   *    upstreams.
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig}
   */
  public static final class UpgradeConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
      UpgradeConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use UpgradeConfig.newBuilder() to construct.
    private UpgradeConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private UpgradeConfig() {
      upgradeType_ = "";
      filters_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new UpgradeConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private UpgradeConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              upgradeType_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                filters_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter>();
                mutable_bitField0_ |= 0x00000001;
              }
              filters_.add(
                  input.readMessage(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.parser(), extensionRegistry));
              break;
            }
            case 26: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (enabled_ != null) {
                subBuilder = enabled_.toBuilder();
              }
              enabled_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(enabled_);
                enabled_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          filters_ = java.util.Collections.unmodifiableList(filters_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder.class);
    }

    public static final int UPGRADE_TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object upgradeType_;
    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The upgradeType.
     */
    @java.lang.Override
    public java.lang.String getUpgradeType() {
      java.lang.Object ref = upgradeType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        upgradeType_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The bytes for upgradeType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUpgradeTypeBytes() {
      java.lang.Object ref = upgradeType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        upgradeType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILTERS_FIELD_NUMBER = 2;
    private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> filters_;
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getFiltersList() {
      return filters_;
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
        getFiltersOrBuilderList() {
      return filters_;
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public int getFiltersCount() {
      return filters_.size();
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getFilters(int index) {
      return filters_.get(index);
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getFiltersOrBuilder(
        int index) {
      return filters_.get(index);
    }

    public static final int ENABLED_FIELD_NUMBER = 3;
    private com.google.protobuf.BoolValue enabled_;
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return Whether the enabled field is set.
     */
    @java.lang.Override
    public boolean hasEnabled() {
      return enabled_ != null;
    }
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return The enabled.
     */
    @java.lang.Override
    public com.google.protobuf.BoolValue getEnabled() {
      return enabled_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
    }
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.BoolValueOrBuilder getEnabledOrBuilder() {
      return getEnabled();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getUpgradeTypeBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, upgradeType_);
      }
      for (int i = 0; i < filters_.size(); i++) {
        output.writeMessage(2, filters_.get(i));
      }
      if (enabled_ != null) {
        output.writeMessage(3, getEnabled());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getUpgradeTypeBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, upgradeType_);
      }
      for (int i = 0; i < filters_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, filters_.get(i));
      }
      if (enabled_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getEnabled());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig) obj;

      if (!getUpgradeType()
          .equals(other.getUpgradeType())) return false;
      if (!getFiltersList()
          .equals(other.getFiltersList())) return false;
      if (hasEnabled() != other.hasEnabled()) return false;
      if (hasEnabled()) {
        if (!getEnabled()
            .equals(other.getEnabled())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + UPGRADE_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getUpgradeType().hashCode();
      if (getFiltersCount() > 0) {
        hash = (37 * hash) + FILTERS_FIELD_NUMBER;
        hash = (53 * hash) + getFiltersList().hashCode();
      }
      if (hasEnabled()) {
        hash = (37 * hash) + ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + getEnabled().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The configuration for HTTP upgrades.
     * For each upgrade type desired, an UpgradeConfig must be added.
     * .. warning::
     *    The current implementation of upgrade headers does not handle
     *    multi-valued upgrade headers. Support for multi-valued headers may be
     *    added in the future if needed.
     * .. warning::
     *    The current implementation of upgrade headers does not work with HTTP/2
     *    upstreams.
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getFiltersFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        upgradeType_ = "";

        if (filtersBuilder_ == null) {
          filters_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          filtersBuilder_.clear();
        }
        if (enabledBuilder_ == null) {
          enabled_ = null;
        } else {
          enabled_ = null;
          enabledBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig(this);
        int from_bitField0_ = bitField0_;
        result.upgradeType_ = upgradeType_;
        if (filtersBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            filters_ = java.util.Collections.unmodifiableList(filters_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.filters_ = filters_;
        } else {
          result.filters_ = filtersBuilder_.build();
        }
        if (enabledBuilder_ == null) {
          result.enabled_ = enabled_;
        } else {
          result.enabled_ = enabledBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance()) return this;
        if (!other.getUpgradeType().isEmpty()) {
          upgradeType_ = other.upgradeType_;
          onChanged();
        }
        if (filtersBuilder_ == null) {
          if (!other.filters_.isEmpty()) {
            if (filters_.isEmpty()) {
              filters_ = other.filters_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureFiltersIsMutable();
              filters_.addAll(other.filters_);
            }
            onChanged();
          }
        } else {
          if (!other.filters_.isEmpty()) {
            if (filtersBuilder_.isEmpty()) {
              filtersBuilder_.dispose();
              filtersBuilder_ = null;
              filters_ = other.filters_;
              bitField0_ = (bitField0_ & ~0x00000001);
              filtersBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getFiltersFieldBuilder() : null;
            } else {
              filtersBuilder_.addAllMessages(other.filters_);
            }
          }
        }
        if (other.hasEnabled()) {
          mergeEnabled(other.getEnabled());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object upgradeType_ = "";
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @return The upgradeType.
       */
      public java.lang.String getUpgradeType() {
        java.lang.Object ref = upgradeType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          upgradeType_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @return The bytes for upgradeType.
       */
      public com.google.protobuf.ByteString
          getUpgradeTypeBytes() {
        java.lang.Object ref = upgradeType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          upgradeType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @param value The upgradeType to set.
       * @return This builder for chaining.
       */
      public Builder setUpgradeType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        upgradeType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpgradeType() {
        
        upgradeType_ = getDefaultInstance().getUpgradeType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @param value The bytes for upgradeType to set.
       * @return This builder for chaining.
       */
      public Builder setUpgradeTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        upgradeType_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> filters_ =
        java.util.Collections.emptyList();
      private void ensureFiltersIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          filters_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter>(filters_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> filtersBuilder_;

      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getFiltersList() {
        if (filtersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(filters_);
        } else {
          return filtersBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public int getFiltersCount() {
        if (filtersBuilder_ == null) {
          return filters_.size();
        } else {
          return filtersBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getFilters(int index) {
        if (filtersBuilder_ == null) {
          return filters_.get(index);
        } else {
          return filtersBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder setFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
        if (filtersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFiltersIsMutable();
          filters_.set(index, value);
          onChanged();
        } else {
          filtersBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder setFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.set(index, builderForValue.build());
          onChanged();
        } else {
          filtersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
        if (filtersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFiltersIsMutable();
          filters_.add(value);
          onChanged();
        } else {
          filtersBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
        if (filtersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFiltersIsMutable();
          filters_.add(index, value);
          onChanged();
        } else {
          filtersBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.add(builderForValue.build());
          onChanged();
        } else {
          filtersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.add(index, builderForValue.build());
          onChanged();
        } else {
          filtersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addAllFilters(
          java.lang.Iterable<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> values) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, filters_);
          onChanged();
        } else {
          filtersBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder clearFilters() {
        if (filtersBuilder_ == null) {
          filters_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          filtersBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder removeFilters(int index) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.remove(index);
          onChanged();
        } else {
          filtersBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder getFiltersBuilder(
          int index) {
        return getFiltersFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getFiltersOrBuilder(
          int index) {
        if (filtersBuilder_ == null) {
          return filters_.get(index);  } else {
          return filtersBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
           getFiltersOrBuilderList() {
        if (filtersBuilder_ != null) {
          return filtersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(filters_);
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addFiltersBuilder() {
        return getFiltersFieldBuilder().addBuilder(
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addFiltersBuilder(
          int index) {
        return getFiltersFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder> 
           getFiltersBuilderList() {
        return getFiltersFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
          getFiltersFieldBuilder() {
        if (filtersBuilder_ == null) {
          filtersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder>(
                  filters_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          filters_ = null;
        }
        return filtersBuilder_;
      }

      private com.google.protobuf.BoolValue enabled_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> enabledBuilder_;
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       * @return Whether the enabled field is set.
       */
      public boolean hasEnabled() {
        return enabledBuilder_ != null || enabled_ != null;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       * @return The enabled.
       */
      public com.google.protobuf.BoolValue getEnabled() {
        if (enabledBuilder_ == null) {
          return enabled_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
        } else {
          return enabledBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder setEnabled(com.google.protobuf.BoolValue value) {
        if (enabledBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          enabled_ = value;
          onChanged();
        } else {
          enabledBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder setEnabled(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (enabledBuilder_ == null) {
          enabled_ = builderForValue.build();
          onChanged();
        } else {
          enabledBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder mergeEnabled(com.google.protobuf.BoolValue value) {
        if (enabledBuilder_ == null) {
          if (enabled_ != null) {
            enabled_ =
              com.google.protobuf.BoolValue.newBuilder(enabled_).mergeFrom(value).buildPartial();
          } else {
            enabled_ = value;
          }
          onChanged();
        } else {
          enabledBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder clearEnabled() {
        if (enabledBuilder_ == null) {
          enabled_ = null;
          onChanged();
        } else {
          enabled_ = null;
          enabledBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public com.google.protobuf.BoolValue.Builder getEnabledBuilder() {
        
        onChanged();
        return getEnabledFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getEnabledOrBuilder() {
        if (enabledBuilder_ != null) {
          return enabledBuilder_.getMessageOrBuilder();
        } else {
          return enabled_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
        }
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getEnabledFieldBuilder() {
        if (enabledBuilder_ == null) {
          enabledBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getEnabled(),
                  getParentForChildren(),
                  isClean());
          enabled_ = null;
        }
        return enabledBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<UpgradeConfig>
        PARSER = new com.google.protobuf.AbstractParser<UpgradeConfig>() {
      @java.lang.Override
      public UpgradeConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new UpgradeConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<UpgradeConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<UpgradeConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int routeSpecifierCase_ = 0;
  private java.lang.Object routeSpecifier_;
  public enum RouteSpecifierCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    RDS(3),
    ROUTE_CONFIG(4),
    SCOPED_ROUTES(31),
    ROUTESPECIFIER_NOT_SET(0);
    private final int value;
    private RouteSpecifierCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static RouteSpecifierCase valueOf(int value) {
      return forNumber(value);
    }

    public static RouteSpecifierCase forNumber(int value) {
      switch (value) {
        case 3: return RDS;
        case 4: return ROUTE_CONFIG;
        case 31: return SCOPED_ROUTES;
        case 0: return ROUTESPECIFIER_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public RouteSpecifierCase
  getRouteSpecifierCase() {
    return RouteSpecifierCase.forNumber(
        routeSpecifierCase_);
  }

  private int stripPortModeCase_ = 0;
  private java.lang.Object stripPortMode_;
  public enum StripPortModeCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    STRIP_ANY_HOST_PORT(42),
    STRIPPORTMODE_NOT_SET(0);
    private final int value;
    private StripPortModeCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static StripPortModeCase valueOf(int value) {
      return forNumber(value);
    }

    public static StripPortModeCase forNumber(int value) {
      switch (value) {
        case 42: return STRIP_ANY_HOST_PORT;
        case 0: return STRIPPORTMODE_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public StripPortModeCase
  getStripPortModeCase() {
    return StripPortModeCase.forNumber(
        stripPortModeCase_);
  }

  public static final int CODEC_TYPE_FIELD_NUMBER = 1;
  private int codecType_;
  /**
   * <pre>
   * Supplies the type of codec that the connection manager should use.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for codecType.
   */
  @java.lang.Override public int getCodecTypeValue() {
    return codecType_;
  }
  /**
   * <pre>
   * Supplies the type of codec that the connection manager should use.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
   * @return The codecType.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType getCodecType() {
    @SuppressWarnings("deprecation")
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.valueOf(codecType_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.UNRECOGNIZED : result;
  }

  public static final int STAT_PREFIX_FIELD_NUMBER = 2;
  private volatile java.lang.Object statPrefix_;
  /**
   * <pre>
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
   * more information.
   * </pre>
   *
   * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
   * @return The statPrefix.
   */
  @java.lang.Override
  public java.lang.String getStatPrefix() {
    java.lang.Object ref = statPrefix_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      statPrefix_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
   * more information.
   * </pre>
   *
   * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
   * @return The bytes for statPrefix.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getStatPrefixBytes() {
    java.lang.Object ref = statPrefix_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      statPrefix_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int RDS_FIELD_NUMBER = 3;
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   * @return Whether the rds field is set.
   */
  @java.lang.Override
  public boolean hasRds() {
    return routeSpecifierCase_ == 3;
  }
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   * @return The rds.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds getRds() {
    if (routeSpecifierCase_ == 3) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
  }
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder getRdsOrBuilder() {
    if (routeSpecifierCase_ == 3) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
  }

  public static final int ROUTE_CONFIG_FIELD_NUMBER = 4;
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   * @return Whether the routeConfig field is set.
   */
  @java.lang.Override
  public boolean hasRouteConfig() {
    return routeSpecifierCase_ == 4;
  }
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   * @return The routeConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.route.v3.RouteConfiguration getRouteConfig() {
    if (routeSpecifierCase_ == 4) {
       return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
    }
    return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
  }
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder getRouteConfigOrBuilder() {
    if (routeSpecifierCase_ == 4) {
       return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
    }
    return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
  }

  public static final int SCOPED_ROUTES_FIELD_NUMBER = 31;
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   * @return Whether the scopedRoutes field is set.
   */
  @java.lang.Override
  public boolean hasScopedRoutes() {
    return routeSpecifierCase_ == 31;
  }
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   * @return The scopedRoutes.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes getScopedRoutes() {
    if (routeSpecifierCase_ == 31) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
  }
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder getScopedRoutesOrBuilder() {
    if (routeSpecifierCase_ == 31) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
  }

  public static final int HTTP_FILTERS_FIELD_NUMBER = 5;
  private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> httpFilters_;
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getHttpFiltersList() {
    return httpFilters_;
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
      getHttpFiltersOrBuilderList() {
    return httpFilters_;
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public int getHttpFiltersCount() {
    return httpFilters_.size();
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getHttpFilters(int index) {
    return httpFilters_.get(index);
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getHttpFiltersOrBuilder(
      int index) {
    return httpFilters_.get(index);
  }

  public static final int ADD_USER_AGENT_FIELD_NUMBER = 6;
  private com.google.protobuf.BoolValue addUserAgent_;
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   * @return Whether the addUserAgent field is set.
   */
  @java.lang.Override
  public boolean hasAddUserAgent() {
    return addUserAgent_ != null;
  }
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   * @return The addUserAgent.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getAddUserAgent() {
    return addUserAgent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
  }
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getAddUserAgentOrBuilder() {
    return getAddUserAgent();
  }

  public static final int TRACING_FIELD_NUMBER = 7;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing_;
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   * @return Whether the tracing field is set.
   */
  @java.lang.Override
  public boolean hasTracing() {
    return tracing_ != null;
  }
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   * @return The tracing.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getTracing() {
    return tracing_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
  }
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder getTracingOrBuilder() {
    return getTracing();
  }

  public static final int COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 35;
  private io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions commonHttpProtocolOptions_;
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the commonHttpProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   * @return The commonHttpProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
    return getCommonHttpProtocolOptions();
  }

  public static final int HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 8;
  private io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions httpProtocolOptions_;
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   * @return Whether the httpProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasHttpProtocolOptions() {
    return httpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   * @return The httpProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions() {
    return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
    return getHttpProtocolOptions();
  }

  public static final int HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER = 9;
  private io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions http2ProtocolOptions_;
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the http2ProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasHttp2ProtocolOptions() {
    return http2ProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   * @return The http2ProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions() {
    return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
  }
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
    return getHttp2ProtocolOptions();
  }

  public static final int SERVER_NAME_FIELD_NUMBER = 10;
  private volatile java.lang.Object serverName_;
  /**
   * <pre>
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is *envoy*.
   * </pre>
   *
   * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
   * @return The serverName.
   */
  @java.lang.Override
  public java.lang.String getServerName() {
    java.lang.Object ref = serverName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      serverName_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is *envoy*.
   * </pre>
   *
   * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
   * @return The bytes for serverName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getServerNameBytes() {
    java.lang.Object ref = serverName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      serverName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SERVER_HEADER_TRANSFORMATION_FIELD_NUMBER = 34;
  private int serverHeaderTransformation_;
  /**
   * <pre>
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for serverHeaderTransformation.
   */
  @java.lang.Override public int getServerHeaderTransformationValue() {
    return serverHeaderTransformation_;
  }
  /**
   * <pre>
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
   * @return The serverHeaderTransformation.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation getServerHeaderTransformation() {
    @SuppressWarnings("deprecation")
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.valueOf(serverHeaderTransformation_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.UNRECOGNIZED : result;
  }

  public static final int MAX_REQUEST_HEADERS_KB_FIELD_NUMBER = 29;
  private com.google.protobuf.UInt32Value maxRequestHeadersKb_;
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * The max configurable limit is 96 KiB, based on current implementation
   * constraints.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   * @return Whether the maxRequestHeadersKb field is set.
   */
  @java.lang.Override
  public boolean hasMaxRequestHeadersKb() {
    return maxRequestHeadersKb_ != null;
  }
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * The max configurable limit is 96 KiB, based on current implementation
   * constraints.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   * @return The maxRequestHeadersKb.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getMaxRequestHeadersKb() {
    return maxRequestHeadersKb_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
  }
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * The max configurable limit is 96 KiB, based on current implementation
   * constraints.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestHeadersKbOrBuilder() {
    return getMaxRequestHeadersKb();
  }

  public static final int STREAM_IDLE_TIMEOUT_FIELD_NUMBER = 24;
  private com.google.protobuf.Duration streamIdleTimeout_;
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the streamIdleTimeout field is set.
   */
  @java.lang.Override
  public boolean hasStreamIdleTimeout() {
    return streamIdleTimeout_ != null;
  }
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   * @return The streamIdleTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getStreamIdleTimeout() {
    return streamIdleTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
  }
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getStreamIdleTimeoutOrBuilder() {
    return getStreamIdleTimeout();
  }

  public static final int REQUEST_TIMEOUT_FIELD_NUMBER = 28;
  private com.google.protobuf.Duration requestTimeout_;
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the requestTimeout field is set.
   */
  @java.lang.Override
  public boolean hasRequestTimeout() {
    return requestTimeout_ != null;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   * @return The requestTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getRequestTimeout() {
    return requestTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getRequestTimeoutOrBuilder() {
    return getRequestTimeout();
  }

  public static final int REQUEST_HEADERS_TIMEOUT_FIELD_NUMBER = 41;
  private com.google.protobuf.Duration requestHeadersTimeout_;
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   * @return Whether the requestHeadersTimeout field is set.
   */
  @java.lang.Override
  public boolean hasRequestHeadersTimeout() {
    return requestHeadersTimeout_ != null;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   * @return The requestHeadersTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getRequestHeadersTimeout() {
    return requestHeadersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getRequestHeadersTimeoutOrBuilder() {
    return getRequestHeadersTimeout();
  }

  public static final int DRAIN_TIMEOUT_FIELD_NUMBER = 12;
  private com.google.protobuf.Duration drainTimeout_;
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   * @return Whether the drainTimeout field is set.
   */
  @java.lang.Override
  public boolean hasDrainTimeout() {
    return drainTimeout_ != null;
  }
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   * @return The drainTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getDrainTimeout() {
    return drainTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
  }
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getDrainTimeoutOrBuilder() {
    return getDrainTimeout();
  }

  public static final int DELAYED_CLOSE_TIMEOUT_FIELD_NUMBER = 26;
  private com.google.protobuf.Duration delayedCloseTimeout_;
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   * @return Whether the delayedCloseTimeout field is set.
   */
  @java.lang.Override
  public boolean hasDelayedCloseTimeout() {
    return delayedCloseTimeout_ != null;
  }
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   * @return The delayedCloseTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getDelayedCloseTimeout() {
    return delayedCloseTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
  }
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getDelayedCloseTimeoutOrBuilder() {
    return getDelayedCloseTimeout();
  }

  public static final int ACCESS_LOG_FIELD_NUMBER = 13;
  private java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> accessLog_;
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> getAccessLogList() {
    return accessLog_;
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
      getAccessLogOrBuilderList() {
    return accessLog_;
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public int getAccessLogCount() {
    return accessLog_.size();
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index) {
    return accessLog_.get(index);
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
      int index) {
    return accessLog_.get(index);
  }

  public static final int USE_REMOTE_ADDRESS_FIELD_NUMBER = 14;
  private com.google.protobuf.BoolValue useRemoteAddress_;
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the useRemoteAddress field is set.
   */
  @java.lang.Override
  public boolean hasUseRemoteAddress() {
    return useRemoteAddress_ != null;
  }
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   * @return The useRemoteAddress.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getUseRemoteAddress() {
    return useRemoteAddress_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
  }
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getUseRemoteAddressOrBuilder() {
    return getUseRemoteAddress();
  }

  public static final int XFF_NUM_TRUSTED_HOPS_FIELD_NUMBER = 19;
  private int xffNumTrustedHops_;
  /**
   * <pre>
   * The number of additional ingress proxy hops from the right side of the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
   * determining the origin client's IP address. The default is zero if this option
   * is not specified. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
   * </pre>
   *
   * <code>uint32 xff_num_trusted_hops = 19;</code>
   * @return The xffNumTrustedHops.
   */
  @java.lang.Override
  public int getXffNumTrustedHops() {
    return xffNumTrustedHops_;
  }

  public static final int INTERNAL_ADDRESS_CONFIG_FIELD_NUMBER = 25;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internalAddressConfig_;
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   * @return Whether the internalAddressConfig field is set.
   */
  @java.lang.Override
  public boolean hasInternalAddressConfig() {
    return internalAddressConfig_ != null;
  }
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   * @return The internalAddressConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getInternalAddressConfig() {
    return internalAddressConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
  }
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder getInternalAddressConfigOrBuilder() {
    return getInternalAddressConfig();
  }

  public static final int SKIP_XFF_APPEND_FIELD_NUMBER = 21;
  private boolean skipXffAppend_;
  /**
   * <pre>
   * If set, Envoy will not append the remote address to the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
   * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
   * has mutated the request headers. While :ref:`use_remote_address
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   * will also suppress XFF addition, it has consequences for logging and other
   * Envoy uses of the remote address, so *skip_xff_append* should be used
   * when only an elision of XFF addition is intended.
   * </pre>
   *
   * <code>bool skip_xff_append = 21;</code>
   * @return The skipXffAppend.
   */
  @java.lang.Override
  public boolean getSkipXffAppend() {
    return skipXffAppend_;
  }

  public static final int VIA_FIELD_NUMBER = 22;
  private volatile java.lang.Object via_;
  /**
   * <pre>
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   * </pre>
   *
   * <code>string via = 22;</code>
   * @return The via.
   */
  @java.lang.Override
  public java.lang.String getVia() {
    java.lang.Object ref = via_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      via_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   * </pre>
   *
   * <code>string via = 22;</code>
   * @return The bytes for via.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getViaBytes() {
    java.lang.Object ref = via_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      via_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int GENERATE_REQUEST_ID_FIELD_NUMBER = 15;
  private com.google.protobuf.BoolValue generateRequestId_;
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   * @return Whether the generateRequestId field is set.
   */
  @java.lang.Override
  public boolean hasGenerateRequestId() {
    return generateRequestId_ != null;
  }
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   * @return The generateRequestId.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getGenerateRequestId() {
    return generateRequestId_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
  }
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getGenerateRequestIdOrBuilder() {
    return getGenerateRequestId();
  }

  public static final int PRESERVE_EXTERNAL_REQUEST_ID_FIELD_NUMBER = 32;
  private boolean preserveExternalRequestId_;
  /**
   * <pre>
   * Whether the connection manager will keep the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
   * (Edge request is the request from external clients to front Envoy) and not reset it, which
   * is the current Envoy behaviour. This defaults to false.
   * </pre>
   *
   * <code>bool preserve_external_request_id = 32;</code>
   * @return The preserveExternalRequestId.
   */
  @java.lang.Override
  public boolean getPreserveExternalRequestId() {
    return preserveExternalRequestId_;
  }

  public static final int ALWAYS_SET_REQUEST_ID_IN_RESPONSE_FIELD_NUMBER = 37;
  private boolean alwaysSetRequestIdInResponse_;
  /**
   * <pre>
   * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
   * If this is false or not set, the request ID is returned in responses only if tracing is forced using
   * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
   * </pre>
   *
   * <code>bool always_set_request_id_in_response = 37;</code>
   * @return The alwaysSetRequestIdInResponse.
   */
  @java.lang.Override
  public boolean getAlwaysSetRequestIdInResponse() {
    return alwaysSetRequestIdInResponse_;
  }

  public static final int FORWARD_CLIENT_CERT_DETAILS_FIELD_NUMBER = 16;
  private int forwardClientCertDetails_;
  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for forwardClientCertDetails.
   */
  @java.lang.Override public int getForwardClientCertDetailsValue() {
    return forwardClientCertDetails_;
  }
  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
   * @return The forwardClientCertDetails.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails getForwardClientCertDetails() {
    @SuppressWarnings("deprecation")
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.valueOf(forwardClientCertDetails_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.UNRECOGNIZED : result;
  }

  public static final int SET_CURRENT_CLIENT_CERT_DETAILS_FIELD_NUMBER = 17;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails setCurrentClientCertDetails_;
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
   * *By* is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   * @return Whether the setCurrentClientCertDetails field is set.
   */
  @java.lang.Override
  public boolean hasSetCurrentClientCertDetails() {
    return setCurrentClientCertDetails_ != null;
  }
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
   * *By* is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   * @return The setCurrentClientCertDetails.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getSetCurrentClientCertDetails() {
    return setCurrentClientCertDetails_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
  }
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
   * *By* is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder getSetCurrentClientCertDetailsOrBuilder() {
    return getSetCurrentClientCertDetails();
  }

  public static final int PROXY_100_CONTINUE_FIELD_NUMBER = 18;
  private boolean proxy100Continue_;
  /**
   * <pre>
   * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
   * 100-continue" headers upstream, and forward "100 Continue" responses
   * downstream. If this is false or not set, Envoy will instead strip the
   * "Expect: 100-continue" header, and send a "100 Continue" response itself.
   * </pre>
   *
   * <code>bool proxy_100_continue = 18;</code>
   * @return The proxy100Continue.
   */
  @java.lang.Override
  public boolean getProxy100Continue() {
    return proxy100Continue_;
  }

  public static final int REPRESENT_IPV4_REMOTE_ADDRESS_AS_IPV4_MAPPED_IPV6_FIELD_NUMBER = 20;
  private boolean representIpv4RemoteAddressAsIpv4MappedIpv6_;
  /**
   * <pre>
   * If
   * :ref:`use_remote_address
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
   * an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
   * This is useful for testing compatibility of upstream services that parse the header value. For
   * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
   * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
   * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
   * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
   * control.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
   * @return The representIpv4RemoteAddressAsIpv4MappedIpv6.
   */
  @java.lang.Override
  public boolean getRepresentIpv4RemoteAddressAsIpv4MappedIpv6() {
    return representIpv4RemoteAddressAsIpv4MappedIpv6_;
  }

  public static final int UPGRADE_CONFIGS_FIELD_NUMBER = 23;
  private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> upgradeConfigs_;
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> getUpgradeConfigsList() {
    return upgradeConfigs_;
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
      getUpgradeConfigsOrBuilderList() {
    return upgradeConfigs_;
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public int getUpgradeConfigsCount() {
    return upgradeConfigs_.size();
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getUpgradeConfigs(int index) {
    return upgradeConfigs_.get(index);
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder getUpgradeConfigsOrBuilder(
      int index) {
    return upgradeConfigs_.get(index);
  }

  public static final int NORMALIZE_PATH_FIELD_NUMBER = 30;
  private com.google.protobuf.BoolValue normalizePath_;
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream *:path* header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   * @return Whether the normalizePath field is set.
   */
  @java.lang.Override
  public boolean hasNormalizePath() {
    return normalizePath_ != null;
  }
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream *:path* header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   * @return The normalizePath.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getNormalizePath() {
    return normalizePath_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
  }
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream *:path* header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getNormalizePathOrBuilder() {
    return getNormalizePath();
  }

  public static final int MERGE_SLASHES_FIELD_NUMBER = 33;
  private boolean mergeSlashes_;
  /**
   * <pre>
   * Determines if adjacent slashes in the path are merged into one before any processing of
   * requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
   * setting this option, incoming requests with path `//dir///file` will not match against route
   * with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
   * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * </pre>
   *
   * <code>bool merge_slashes = 33;</code>
   * @return The mergeSlashes.
   */
  @java.lang.Override
  public boolean getMergeSlashes() {
    return mergeSlashes_;
  }

  public static final int REQUEST_ID_EXTENSION_FIELD_NUMBER = 36;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension requestIdExtension_;
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations.
   * If not set, Envoy uses the default UUID-based behavior:
   * 1. Request ID is propagated using *x-request-id* header.
   * 2. Request ID is a universally unique identifier (UUID).
   * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   * @return Whether the requestIdExtension field is set.
   */
  @java.lang.Override
  public boolean hasRequestIdExtension() {
    return requestIdExtension_ != null;
  }
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations.
   * If not set, Envoy uses the default UUID-based behavior:
   * 1. Request ID is propagated using *x-request-id* header.
   * 2. Request ID is a universally unique identifier (UUID).
   * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   * @return The requestIdExtension.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension getRequestIdExtension() {
    return requestIdExtension_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
  }
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations.
   * If not set, Envoy uses the default UUID-based behavior:
   * 1. Request ID is propagated using *x-request-id* header.
   * 2. Request ID is a universally unique identifier (UUID).
   * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder getRequestIdExtensionOrBuilder() {
    return getRequestIdExtension();
  }

  public static final int LOCAL_REPLY_CONFIG_FIELD_NUMBER = 38;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig localReplyConfig_;
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   * @return Whether the localReplyConfig field is set.
   */
  @java.lang.Override
  public boolean hasLocalReplyConfig() {
    return localReplyConfig_ != null;
  }
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   * @return The localReplyConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig getLocalReplyConfig() {
    return localReplyConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
  }
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder getLocalReplyConfigOrBuilder() {
    return getLocalReplyConfig();
  }

  public static final int STRIP_MATCHING_HOST_PORT_FIELD_NUMBER = 39;
  private boolean stripMatchingHostPort_;
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_api_field_config.listener.v3.Listener.address&gt;`
   * local port and request method is not CONNECT. This affects the upstream host header as well.
   * Without setting this option, incoming requests with host `example:443` will not match against
   * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
   * </pre>
   *
   * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The stripMatchingHostPort.
   */
  @java.lang.Override
  public boolean getStripMatchingHostPort() {
    return stripMatchingHostPort_;
  }

  public static final int STRIP_ANY_HOST_PORT_FIELD_NUMBER = 42;
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing. The port would be removed only if request method is not CONNECT.
   * This affects the upstream host header as well.
   * Without setting this option, incoming requests with host `example:443` will not match against
   * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
   * </pre>
   *
   * <code>bool strip_any_host_port = 42;</code>
   * @return Whether the stripAnyHostPort field is set.
   */
  @java.lang.Override
  public boolean hasStripAnyHostPort() {
    return stripPortModeCase_ == 42;
  }
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing. The port would be removed only if request method is not CONNECT.
   * This affects the upstream host header as well.
   * Without setting this option, incoming requests with host `example:443` will not match against
   * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
   * </pre>
   *
   * <code>bool strip_any_host_port = 42;</code>
   * @return The stripAnyHostPort.
   */
  @java.lang.Override
  public boolean getStripAnyHostPort() {
    if (stripPortModeCase_ == 42) {
      return (java.lang.Boolean) stripPortMode_;
    }
    return false;
  }

  public static final int STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER = 40;
  private com.google.protobuf.BoolValue streamErrorOnInvalidHttpMessage_;
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   * @return Whether the streamErrorOnInvalidHttpMessage field is set.
   */
  @java.lang.Override
  public boolean hasStreamErrorOnInvalidHttpMessage() {
    return streamErrorOnInvalidHttpMessage_ != null;
  }
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   * @return The streamErrorOnInvalidHttpMessage.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getStreamErrorOnInvalidHttpMessage() {
    return streamErrorOnInvalidHttpMessage_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
  }
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getStreamErrorOnInvalidHttpMessageOrBuilder() {
    return getStreamErrorOnInvalidHttpMessage();
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (codecType_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.AUTO.getNumber()) {
      output.writeEnum(1, codecType_);
    }
    if (!getStatPrefixBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2, statPrefix_);
    }
    if (routeSpecifierCase_ == 3) {
      output.writeMessage(3, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_);
    }
    if (routeSpecifierCase_ == 4) {
      output.writeMessage(4, (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_);
    }
    for (int i = 0; i < httpFilters_.size(); i++) {
      output.writeMessage(5, httpFilters_.get(i));
    }
    if (addUserAgent_ != null) {
      output.writeMessage(6, getAddUserAgent());
    }
    if (tracing_ != null) {
      output.writeMessage(7, getTracing());
    }
    if (httpProtocolOptions_ != null) {
      output.writeMessage(8, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      output.writeMessage(9, getHttp2ProtocolOptions());
    }
    if (!getServerNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 10, serverName_);
    }
    if (drainTimeout_ != null) {
      output.writeMessage(12, getDrainTimeout());
    }
    for (int i = 0; i < accessLog_.size(); i++) {
      output.writeMessage(13, accessLog_.get(i));
    }
    if (useRemoteAddress_ != null) {
      output.writeMessage(14, getUseRemoteAddress());
    }
    if (generateRequestId_ != null) {
      output.writeMessage(15, getGenerateRequestId());
    }
    if (forwardClientCertDetails_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.SANITIZE.getNumber()) {
      output.writeEnum(16, forwardClientCertDetails_);
    }
    if (setCurrentClientCertDetails_ != null) {
      output.writeMessage(17, getSetCurrentClientCertDetails());
    }
    if (proxy100Continue_ != false) {
      output.writeBool(18, proxy100Continue_);
    }
    if (xffNumTrustedHops_ != 0) {
      output.writeUInt32(19, xffNumTrustedHops_);
    }
    if (representIpv4RemoteAddressAsIpv4MappedIpv6_ != false) {
      output.writeBool(20, representIpv4RemoteAddressAsIpv4MappedIpv6_);
    }
    if (skipXffAppend_ != false) {
      output.writeBool(21, skipXffAppend_);
    }
    if (!getViaBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 22, via_);
    }
    for (int i = 0; i < upgradeConfigs_.size(); i++) {
      output.writeMessage(23, upgradeConfigs_.get(i));
    }
    if (streamIdleTimeout_ != null) {
      output.writeMessage(24, getStreamIdleTimeout());
    }
    if (internalAddressConfig_ != null) {
      output.writeMessage(25, getInternalAddressConfig());
    }
    if (delayedCloseTimeout_ != null) {
      output.writeMessage(26, getDelayedCloseTimeout());
    }
    if (requestTimeout_ != null) {
      output.writeMessage(28, getRequestTimeout());
    }
    if (maxRequestHeadersKb_ != null) {
      output.writeMessage(29, getMaxRequestHeadersKb());
    }
    if (normalizePath_ != null) {
      output.writeMessage(30, getNormalizePath());
    }
    if (routeSpecifierCase_ == 31) {
      output.writeMessage(31, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_);
    }
    if (preserveExternalRequestId_ != false) {
      output.writeBool(32, preserveExternalRequestId_);
    }
    if (mergeSlashes_ != false) {
      output.writeBool(33, mergeSlashes_);
    }
    if (serverHeaderTransformation_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.OVERWRITE.getNumber()) {
      output.writeEnum(34, serverHeaderTransformation_);
    }
    if (commonHttpProtocolOptions_ != null) {
      output.writeMessage(35, getCommonHttpProtocolOptions());
    }
    if (requestIdExtension_ != null) {
      output.writeMessage(36, getRequestIdExtension());
    }
    if (alwaysSetRequestIdInResponse_ != false) {
      output.writeBool(37, alwaysSetRequestIdInResponse_);
    }
    if (localReplyConfig_ != null) {
      output.writeMessage(38, getLocalReplyConfig());
    }
    if (stripMatchingHostPort_ != false) {
      output.writeBool(39, stripMatchingHostPort_);
    }
    if (streamErrorOnInvalidHttpMessage_ != null) {
      output.writeMessage(40, getStreamErrorOnInvalidHttpMessage());
    }
    if (requestHeadersTimeout_ != null) {
      output.writeMessage(41, getRequestHeadersTimeout());
    }
    if (stripPortModeCase_ == 42) {
      output.writeBool(
          42, (boolean)((java.lang.Boolean) stripPortMode_));
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (codecType_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.AUTO.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(1, codecType_);
    }
    if (!getStatPrefixBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, statPrefix_);
    }
    if (routeSpecifierCase_ == 3) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_);
    }
    if (routeSpecifierCase_ == 4) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_);
    }
    for (int i = 0; i < httpFilters_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, httpFilters_.get(i));
    }
    if (addUserAgent_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getAddUserAgent());
    }
    if (tracing_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getTracing());
    }
    if (httpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getHttp2ProtocolOptions());
    }
    if (!getServerNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, serverName_);
    }
    if (drainTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(12, getDrainTimeout());
    }
    for (int i = 0; i < accessLog_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(13, accessLog_.get(i));
    }
    if (useRemoteAddress_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(14, getUseRemoteAddress());
    }
    if (generateRequestId_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(15, getGenerateRequestId());
    }
    if (forwardClientCertDetails_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.SANITIZE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(16, forwardClientCertDetails_);
    }
    if (setCurrentClientCertDetails_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(17, getSetCurrentClientCertDetails());
    }
    if (proxy100Continue_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(18, proxy100Continue_);
    }
    if (xffNumTrustedHops_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(19, xffNumTrustedHops_);
    }
    if (representIpv4RemoteAddressAsIpv4MappedIpv6_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(20, representIpv4RemoteAddressAsIpv4MappedIpv6_);
    }
    if (skipXffAppend_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(21, skipXffAppend_);
    }
    if (!getViaBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, via_);
    }
    for (int i = 0; i < upgradeConfigs_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(23, upgradeConfigs_.get(i));
    }
    if (streamIdleTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(24, getStreamIdleTimeout());
    }
    if (internalAddressConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(25, getInternalAddressConfig());
    }
    if (delayedCloseTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(26, getDelayedCloseTimeout());
    }
    if (requestTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(28, getRequestTimeout());
    }
    if (maxRequestHeadersKb_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(29, getMaxRequestHeadersKb());
    }
    if (normalizePath_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(30, getNormalizePath());
    }
    if (routeSpecifierCase_ == 31) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(31, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_);
    }
    if (preserveExternalRequestId_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(32, preserveExternalRequestId_);
    }
    if (mergeSlashes_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(33, mergeSlashes_);
    }
    if (serverHeaderTransformation_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.OVERWRITE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(34, serverHeaderTransformation_);
    }
    if (commonHttpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(35, getCommonHttpProtocolOptions());
    }
    if (requestIdExtension_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(36, getRequestIdExtension());
    }
    if (alwaysSetRequestIdInResponse_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(37, alwaysSetRequestIdInResponse_);
    }
    if (localReplyConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(38, getLocalReplyConfig());
    }
    if (stripMatchingHostPort_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(39, stripMatchingHostPort_);
    }
    if (streamErrorOnInvalidHttpMessage_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(40, getStreamErrorOnInvalidHttpMessage());
    }
    if (requestHeadersTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(41, getRequestHeadersTimeout());
    }
    if (stripPortModeCase_ == 42) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(
            42, (boolean)((java.lang.Boolean) stripPortMode_));
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)) {
      return super.equals(obj);
    }
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager) obj;

    if (codecType_ != other.codecType_) return false;
    if (!getStatPrefix()
        .equals(other.getStatPrefix())) return false;
    if (!getHttpFiltersList()
        .equals(other.getHttpFiltersList())) return false;
    if (hasAddUserAgent() != other.hasAddUserAgent()) return false;
    if (hasAddUserAgent()) {
      if (!getAddUserAgent()
          .equals(other.getAddUserAgent())) return false;
    }
    if (hasTracing() != other.hasTracing()) return false;
    if (hasTracing()) {
      if (!getTracing()
          .equals(other.getTracing())) return false;
    }
    if (hasCommonHttpProtocolOptions() != other.hasCommonHttpProtocolOptions()) return false;
    if (hasCommonHttpProtocolOptions()) {
      if (!getCommonHttpProtocolOptions()
          .equals(other.getCommonHttpProtocolOptions())) return false;
    }
    if (hasHttpProtocolOptions() != other.hasHttpProtocolOptions()) return false;
    if (hasHttpProtocolOptions()) {
      if (!getHttpProtocolOptions()
          .equals(other.getHttpProtocolOptions())) return false;
    }
    if (hasHttp2ProtocolOptions() != other.hasHttp2ProtocolOptions()) return false;
    if (hasHttp2ProtocolOptions()) {
      if (!getHttp2ProtocolOptions()
          .equals(other.getHttp2ProtocolOptions())) return false;
    }
    if (!getServerName()
        .equals(other.getServerName())) return false;
    if (serverHeaderTransformation_ != other.serverHeaderTransformation_) return false;
    if (hasMaxRequestHeadersKb() != other.hasMaxRequestHeadersKb()) return false;
    if (hasMaxRequestHeadersKb()) {
      if (!getMaxRequestHeadersKb()
          .equals(other.getMaxRequestHeadersKb())) return false;
    }
    if (hasStreamIdleTimeout() != other.hasStreamIdleTimeout()) return false;
    if (hasStreamIdleTimeout()) {
      if (!getStreamIdleTimeout()
          .equals(other.getStreamIdleTimeout())) return false;
    }
    if (hasRequestTimeout() != other.hasRequestTimeout()) return false;
    if (hasRequestTimeout()) {
      if (!getRequestTimeout()
          .equals(other.getRequestTimeout())) return false;
    }
    if (hasRequestHeadersTimeout() != other.hasRequestHeadersTimeout()) return false;
    if (hasRequestHeadersTimeout()) {
      if (!getRequestHeadersTimeout()
          .equals(other.getRequestHeadersTimeout())) return false;
    }
    if (hasDrainTimeout() != other.hasDrainTimeout()) return false;
    if (hasDrainTimeout()) {
      if (!getDrainTimeout()
          .equals(other.getDrainTimeout())) return false;
    }
    if (hasDelayedCloseTimeout() != other.hasDelayedCloseTimeout()) return false;
    if (hasDelayedCloseTimeout()) {
      if (!getDelayedCloseTimeout()
          .equals(other.getDelayedCloseTimeout())) return false;
    }
    if (!getAccessLogList()
        .equals(other.getAccessLogList())) return false;
    if (hasUseRemoteAddress() != other.hasUseRemoteAddress()) return false;
    if (hasUseRemoteAddress()) {
      if (!getUseRemoteAddress()
          .equals(other.getUseRemoteAddress())) return false;
    }
    if (getXffNumTrustedHops()
        != other.getXffNumTrustedHops()) return false;
    if (hasInternalAddressConfig() != other.hasInternalAddressConfig()) return false;
    if (hasInternalAddressConfig()) {
      if (!getInternalAddressConfig()
          .equals(other.getInternalAddressConfig())) return false;
    }
    if (getSkipXffAppend()
        != other.getSkipXffAppend()) return false;
    if (!getVia()
        .equals(other.getVia())) return false;
    if (hasGenerateRequestId() != other.hasGenerateRequestId()) return false;
    if (hasGenerateRequestId()) {
      if (!getGenerateRequestId()
          .equals(other.getGenerateRequestId())) return false;
    }
    if (getPreserveExternalRequestId()
        != other.getPreserveExternalRequestId()) return false;
    if (getAlwaysSetRequestIdInResponse()
        != other.getAlwaysSetRequestIdInResponse()) return false;
    if (forwardClientCertDetails_ != other.forwardClientCertDetails_) return false;
    if (hasSetCurrentClientCertDetails() != other.hasSetCurrentClientCertDetails()) return false;
    if (hasSetCurrentClientCertDetails()) {
      if (!getSetCurrentClientCertDetails()
          .equals(other.getSetCurrentClientCertDetails())) return false;
    }
    if (getProxy100Continue()
        != other.getProxy100Continue()) return false;
    if (getRepresentIpv4RemoteAddressAsIpv4MappedIpv6()
        != other.getRepresentIpv4RemoteAddressAsIpv4MappedIpv6()) return false;
    if (!getUpgradeConfigsList()
        .equals(other.getUpgradeConfigsList())) return false;
    if (hasNormalizePath() != other.hasNormalizePath()) return false;
    if (hasNormalizePath()) {
      if (!getNormalizePath()
          .equals(other.getNormalizePath())) return false;
    }
    if (getMergeSlashes()
        != other.getMergeSlashes()) return false;
    if (hasRequestIdExtension() != other.hasRequestIdExtension()) return false;
    if (hasRequestIdExtension()) {
      if (!getRequestIdExtension()
          .equals(other.getRequestIdExtension())) return false;
    }
    if (hasLocalReplyConfig() != other.hasLocalReplyConfig()) return false;
    if (hasLocalReplyConfig()) {
      if (!getLocalReplyConfig()
          .equals(other.getLocalReplyConfig())) return false;
    }
    if (getStripMatchingHostPort()
        != other.getStripMatchingHostPort()) return false;
    if (hasStreamErrorOnInvalidHttpMessage() != other.hasStreamErrorOnInvalidHttpMessage()) return false;
    if (hasStreamErrorOnInvalidHttpMessage()) {
      if (!getStreamErrorOnInvalidHttpMessage()
          .equals(other.getStreamErrorOnInvalidHttpMessage())) return false;
    }
    if (!getRouteSpecifierCase().equals(other.getRouteSpecifierCase())) return false;
    switch (routeSpecifierCase_) {
      case 3:
        if (!getRds()
            .equals(other.getRds())) return false;
        break;
      case 4:
        if (!getRouteConfig()
            .equals(other.getRouteConfig())) return false;
        break;
      case 31:
        if (!getScopedRoutes()
            .equals(other.getScopedRoutes())) return false;
        break;
      case 0:
      default:
    }
    if (!getStripPortModeCase().equals(other.getStripPortModeCase())) return false;
    switch (stripPortModeCase_) {
      case 42:
        if (getStripAnyHostPort()
            != other.getStripAnyHostPort()) return false;
        break;
      case 0:
      default:
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + CODEC_TYPE_FIELD_NUMBER;
    hash = (53 * hash) + codecType_;
    hash = (37 * hash) + STAT_PREFIX_FIELD_NUMBER;
    hash = (53 * hash) + getStatPrefix().hashCode();
    if (getHttpFiltersCount() > 0) {
      hash = (37 * hash) + HTTP_FILTERS_FIELD_NUMBER;
      hash = (53 * hash) + getHttpFiltersList().hashCode();
    }
    if (hasAddUserAgent()) {
      hash = (37 * hash) + ADD_USER_AGENT_FIELD_NUMBER;
      hash = (53 * hash) + getAddUserAgent().hashCode();
    }
    if (hasTracing()) {
      hash = (37 * hash) + TRACING_FIELD_NUMBER;
      hash = (53 * hash) + getTracing().hashCode();
    }
    if (hasCommonHttpProtocolOptions()) {
      hash = (37 * hash) + COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getCommonHttpProtocolOptions().hashCode();
    }
    if (hasHttpProtocolOptions()) {
      hash = (37 * hash) + HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttpProtocolOptions().hashCode();
    }
    if (hasHttp2ProtocolOptions()) {
      hash = (37 * hash) + HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttp2ProtocolOptions().hashCode();
    }
    hash = (37 * hash) + SERVER_NAME_FIELD_NUMBER;
    hash = (53 * hash) + getServerName().hashCode();
    hash = (37 * hash) + SERVER_HEADER_TRANSFORMATION_FIELD_NUMBER;
    hash = (53 * hash) + serverHeaderTransformation_;
    if (hasMaxRequestHeadersKb()) {
      hash = (37 * hash) + MAX_REQUEST_HEADERS_KB_FIELD_NUMBER;
      hash = (53 * hash) + getMaxRequestHeadersKb().hashCode();
    }
    if (hasStreamIdleTimeout()) {
      hash = (37 * hash) + STREAM_IDLE_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getStreamIdleTimeout().hashCode();
    }
    if (hasRequestTimeout()) {
      hash = (37 * hash) + REQUEST_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getRequestTimeout().hashCode();
    }
    if (hasRequestHeadersTimeout()) {
      hash = (37 * hash) + REQUEST_HEADERS_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getRequestHeadersTimeout().hashCode();
    }
    if (hasDrainTimeout()) {
      hash = (37 * hash) + DRAIN_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getDrainTimeout().hashCode();
    }
    if (hasDelayedCloseTimeout()) {
      hash = (37 * hash) + DELAYED_CLOSE_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getDelayedCloseTimeout().hashCode();
    }
    if (getAccessLogCount() > 0) {
      hash = (37 * hash) + ACCESS_LOG_FIELD_NUMBER;
      hash = (53 * hash) + getAccessLogList().hashCode();
    }
    if (hasUseRemoteAddress()) {
      hash = (37 * hash) + USE_REMOTE_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getUseRemoteAddress().hashCode();
    }
    hash = (37 * hash) + XFF_NUM_TRUSTED_HOPS_FIELD_NUMBER;
    hash = (53 * hash) + getXffNumTrustedHops();
    if (hasInternalAddressConfig()) {
      hash = (37 * hash) + INTERNAL_ADDRESS_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getInternalAddressConfig().hashCode();
    }
    hash = (37 * hash) + SKIP_XFF_APPEND_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getSkipXffAppend());
    hash = (37 * hash) + VIA_FIELD_NUMBER;
    hash = (53 * hash) + getVia().hashCode();
    if (hasGenerateRequestId()) {
      hash = (37 * hash) + GENERATE_REQUEST_ID_FIELD_NUMBER;
      hash = (53 * hash) + getGenerateRequestId().hashCode();
    }
    hash = (37 * hash) + PRESERVE_EXTERNAL_REQUEST_ID_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getPreserveExternalRequestId());
    hash = (37 * hash) + ALWAYS_SET_REQUEST_ID_IN_RESPONSE_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getAlwaysSetRequestIdInResponse());
    hash = (37 * hash) + FORWARD_CLIENT_CERT_DETAILS_FIELD_NUMBER;
    hash = (53 * hash) + forwardClientCertDetails_;
    if (hasSetCurrentClientCertDetails()) {
      hash = (37 * hash) + SET_CURRENT_CLIENT_CERT_DETAILS_FIELD_NUMBER;
      hash = (53 * hash) + getSetCurrentClientCertDetails().hashCode();
    }
    hash = (37 * hash) + PROXY_100_CONTINUE_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getProxy100Continue());
    hash = (37 * hash) + REPRESENT_IPV4_REMOTE_ADDRESS_AS_IPV4_MAPPED_IPV6_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getRepresentIpv4RemoteAddressAsIpv4MappedIpv6());
    if (getUpgradeConfigsCount() > 0) {
      hash = (37 * hash) + UPGRADE_CONFIGS_FIELD_NUMBER;
      hash = (53 * hash) + getUpgradeConfigsList().hashCode();
    }
    if (hasNormalizePath()) {
      hash = (37 * hash) + NORMALIZE_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getNormalizePath().hashCode();
    }
    hash = (37 * hash) + MERGE_SLASHES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getMergeSlashes());
    if (hasRequestIdExtension()) {
      hash = (37 * hash) + REQUEST_ID_EXTENSION_FIELD_NUMBER;
      hash = (53 * hash) + getRequestIdExtension().hashCode();
    }
    if (hasLocalReplyConfig()) {
      hash = (37 * hash) + LOCAL_REPLY_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getLocalReplyConfig().hashCode();
    }
    hash = (37 * hash) + STRIP_MATCHING_HOST_PORT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getStripMatchingHostPort());
    if (hasStreamErrorOnInvalidHttpMessage()) {
      hash = (37 * hash) + STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getStreamErrorOnInvalidHttpMessage().hashCode();
    }
    switch (routeSpecifierCase_) {
      case 3:
        hash = (37 * hash) + RDS_FIELD_NUMBER;
        hash = (53 * hash) + getRds().hashCode();
        break;
      case 4:
        hash = (37 * hash) + ROUTE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getRouteConfig().hashCode();
        break;
      case 31:
        hash = (37 * hash) + SCOPED_ROUTES_FIELD_NUMBER;
        hash = (53 * hash) + getScopedRoutes().hashCode();
        break;
      case 0:
      default:
    }
    switch (stripPortModeCase_) {
      case 42:
        hash = (37 * hash) + STRIP_ANY_HOST_PORT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getStripAnyHostPort());
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * [#next-free-field: 43]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Builder.class);
    }

    // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getHttpFiltersFieldBuilder();
        getAccessLogFieldBuilder();
        getUpgradeConfigsFieldBuilder();
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      codecType_ = 0;

      statPrefix_ = "";

      if (httpFiltersBuilder_ == null) {
        httpFilters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
      } else {
        httpFiltersBuilder_.clear();
      }
      if (addUserAgentBuilder_ == null) {
        addUserAgent_ = null;
      } else {
        addUserAgent_ = null;
        addUserAgentBuilder_ = null;
      }
      if (tracingBuilder_ == null) {
        tracing_ = null;
      } else {
        tracing_ = null;
        tracingBuilder_ = null;
      }
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = null;
      } else {
        commonHttpProtocolOptions_ = null;
        commonHttpProtocolOptionsBuilder_ = null;
      }
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = null;
      } else {
        httpProtocolOptions_ = null;
        httpProtocolOptionsBuilder_ = null;
      }
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = null;
      } else {
        http2ProtocolOptions_ = null;
        http2ProtocolOptionsBuilder_ = null;
      }
      serverName_ = "";

      serverHeaderTransformation_ = 0;

      if (maxRequestHeadersKbBuilder_ == null) {
        maxRequestHeadersKb_ = null;
      } else {
        maxRequestHeadersKb_ = null;
        maxRequestHeadersKbBuilder_ = null;
      }
      if (streamIdleTimeoutBuilder_ == null) {
        streamIdleTimeout_ = null;
      } else {
        streamIdleTimeout_ = null;
        streamIdleTimeoutBuilder_ = null;
      }
      if (requestTimeoutBuilder_ == null) {
        requestTimeout_ = null;
      } else {
        requestTimeout_ = null;
        requestTimeoutBuilder_ = null;
      }
      if (requestHeadersTimeoutBuilder_ == null) {
        requestHeadersTimeout_ = null;
      } else {
        requestHeadersTimeout_ = null;
        requestHeadersTimeoutBuilder_ = null;
      }
      if (drainTimeoutBuilder_ == null) {
        drainTimeout_ = null;
      } else {
        drainTimeout_ = null;
        drainTimeoutBuilder_ = null;
      }
      if (delayedCloseTimeoutBuilder_ == null) {
        delayedCloseTimeout_ = null;
      } else {
        delayedCloseTimeout_ = null;
        delayedCloseTimeoutBuilder_ = null;
      }
      if (accessLogBuilder_ == null) {
        accessLog_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
      } else {
        accessLogBuilder_.clear();
      }
      if (useRemoteAddressBuilder_ == null) {
        useRemoteAddress_ = null;
      } else {
        useRemoteAddress_ = null;
        useRemoteAddressBuilder_ = null;
      }
      xffNumTrustedHops_ = 0;

      if (internalAddressConfigBuilder_ == null) {
        internalAddressConfig_ = null;
      } else {
        internalAddressConfig_ = null;
        internalAddressConfigBuilder_ = null;
      }
      skipXffAppend_ = false;

      via_ = "";

      if (generateRequestIdBuilder_ == null) {
        generateRequestId_ = null;
      } else {
        generateRequestId_ = null;
        generateRequestIdBuilder_ = null;
      }
      preserveExternalRequestId_ = false;

      alwaysSetRequestIdInResponse_ = false;

      forwardClientCertDetails_ = 0;

      if (setCurrentClientCertDetailsBuilder_ == null) {
        setCurrentClientCertDetails_ = null;
      } else {
        setCurrentClientCertDetails_ = null;
        setCurrentClientCertDetailsBuilder_ = null;
      }
      proxy100Continue_ = false;

      representIpv4RemoteAddressAsIpv4MappedIpv6_ = false;

      if (upgradeConfigsBuilder_ == null) {
        upgradeConfigs_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
      } else {
        upgradeConfigsBuilder_.clear();
      }
      if (normalizePathBuilder_ == null) {
        normalizePath_ = null;
      } else {
        normalizePath_ = null;
        normalizePathBuilder_ = null;
      }
      mergeSlashes_ = false;

      if (requestIdExtensionBuilder_ == null) {
        requestIdExtension_ = null;
      } else {
        requestIdExtension_ = null;
        requestIdExtensionBuilder_ = null;
      }
      if (localReplyConfigBuilder_ == null) {
        localReplyConfig_ = null;
      } else {
        localReplyConfig_ = null;
        localReplyConfigBuilder_ = null;
      }
      stripMatchingHostPort_ = false;

      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        streamErrorOnInvalidHttpMessage_ = null;
      } else {
        streamErrorOnInvalidHttpMessage_ = null;
        streamErrorOnInvalidHttpMessageBuilder_ = null;
      }
      routeSpecifierCase_ = 0;
      routeSpecifier_ = null;
      stripPortModeCase_ = 0;
      stripPortMode_ = null;
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_descriptor;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager getDefaultInstanceForType() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDefaultInstance();
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager build() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager buildPartial() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager(this);
      int from_bitField0_ = bitField0_;
      result.codecType_ = codecType_;
      result.statPrefix_ = statPrefix_;
      if (routeSpecifierCase_ == 3) {
        if (rdsBuilder_ == null) {
          result.routeSpecifier_ = routeSpecifier_;
        } else {
          result.routeSpecifier_ = rdsBuilder_.build();
        }
      }
      if (routeSpecifierCase_ == 4) {
        if (routeConfigBuilder_ == null) {
          result.routeSpecifier_ = routeSpecifier_;
        } else {
          result.routeSpecifier_ = routeConfigBuilder_.build();
        }
      }
      if (routeSpecifierCase_ == 31) {
        if (scopedRoutesBuilder_ == null) {
          result.routeSpecifier_ = routeSpecifier_;
        } else {
          result.routeSpecifier_ = scopedRoutesBuilder_.build();
        }
      }
      if (httpFiltersBuilder_ == null) {
        if (((bitField0_ & 0x00000001) != 0)) {
          httpFilters_ = java.util.Collections.unmodifiableList(httpFilters_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.httpFilters_ = httpFilters_;
      } else {
        result.httpFilters_ = httpFiltersBuilder_.build();
      }
      if (addUserAgentBuilder_ == null) {
        result.addUserAgent_ = addUserAgent_;
      } else {
        result.addUserAgent_ = addUserAgentBuilder_.build();
      }
      if (tracingBuilder_ == null) {
        result.tracing_ = tracing_;
      } else {
        result.tracing_ = tracingBuilder_.build();
      }
      if (commonHttpProtocolOptionsBuilder_ == null) {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptions_;
      } else {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptionsBuilder_.build();
      }
      if (httpProtocolOptionsBuilder_ == null) {
        result.httpProtocolOptions_ = httpProtocolOptions_;
      } else {
        result.httpProtocolOptions_ = httpProtocolOptionsBuilder_.build();
      }
      if (http2ProtocolOptionsBuilder_ == null) {
        result.http2ProtocolOptions_ = http2ProtocolOptions_;
      } else {
        result.http2ProtocolOptions_ = http2ProtocolOptionsBuilder_.build();
      }
      result.serverName_ = serverName_;
      result.serverHeaderTransformation_ = serverHeaderTransformation_;
      if (maxRequestHeadersKbBuilder_ == null) {
        result.maxRequestHeadersKb_ = maxRequestHeadersKb_;
      } else {
        result.maxRequestHeadersKb_ = maxRequestHeadersKbBuilder_.build();
      }
      if (streamIdleTimeoutBuilder_ == null) {
        result.streamIdleTimeout_ = streamIdleTimeout_;
      } else {
        result.streamIdleTimeout_ = streamIdleTimeoutBuilder_.build();
      }
      if (requestTimeoutBuilder_ == null) {
        result.requestTimeout_ = requestTimeout_;
      } else {
        result.requestTimeout_ = requestTimeoutBuilder_.build();
      }
      if (requestHeadersTimeoutBuilder_ == null) {
        result.requestHeadersTimeout_ = requestHeadersTimeout_;
      } else {
        result.requestHeadersTimeout_ = requestHeadersTimeoutBuilder_.build();
      }
      if (drainTimeoutBuilder_ == null) {
        result.drainTimeout_ = drainTimeout_;
      } else {
        result.drainTimeout_ = drainTimeoutBuilder_.build();
      }
      if (delayedCloseTimeoutBuilder_ == null) {
        result.delayedCloseTimeout_ = delayedCloseTimeout_;
      } else {
        result.delayedCloseTimeout_ = delayedCloseTimeoutBuilder_.build();
      }
      if (accessLogBuilder_ == null) {
        if (((bitField0_ & 0x00000002) != 0)) {
          accessLog_ = java.util.Collections.unmodifiableList(accessLog_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.accessLog_ = accessLog_;
      } else {
        result.accessLog_ = accessLogBuilder_.build();
      }
      if (useRemoteAddressBuilder_ == null) {
        result.useRemoteAddress_ = useRemoteAddress_;
      } else {
        result.useRemoteAddress_ = useRemoteAddressBuilder_.build();
      }
      result.xffNumTrustedHops_ = xffNumTrustedHops_;
      if (internalAddressConfigBuilder_ == null) {
        result.internalAddressConfig_ = internalAddressConfig_;
      } else {
        result.internalAddressConfig_ = internalAddressConfigBuilder_.build();
      }
      result.skipXffAppend_ = skipXffAppend_;
      result.via_ = via_;
      if (generateRequestIdBuilder_ == null) {
        result.generateRequestId_ = generateRequestId_;
      } else {
        result.generateRequestId_ = generateRequestIdBuilder_.build();
      }
      result.preserveExternalRequestId_ = preserveExternalRequestId_;
      result.alwaysSetRequestIdInResponse_ = alwaysSetRequestIdInResponse_;
      result.forwardClientCertDetails_ = forwardClientCertDetails_;
      if (setCurrentClientCertDetailsBuilder_ == null) {
        result.setCurrentClientCertDetails_ = setCurrentClientCertDetails_;
      } else {
        result.setCurrentClientCertDetails_ = setCurrentClientCertDetailsBuilder_.build();
      }
      result.proxy100Continue_ = proxy100Continue_;
      result.representIpv4RemoteAddressAsIpv4MappedIpv6_ = representIpv4RemoteAddressAsIpv4MappedIpv6_;
      if (upgradeConfigsBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0)) {
          upgradeConfigs_ = java.util.Collections.unmodifiableList(upgradeConfigs_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.upgradeConfigs_ = upgradeConfigs_;
      } else {
        result.upgradeConfigs_ = upgradeConfigsBuilder_.build();
      }
      if (normalizePathBuilder_ == null) {
        result.normalizePath_ = normalizePath_;
      } else {
        result.normalizePath_ = normalizePathBuilder_.build();
      }
      result.mergeSlashes_ = mergeSlashes_;
      if (requestIdExtensionBuilder_ == null) {
        result.requestIdExtension_ = requestIdExtension_;
      } else {
        result.requestIdExtension_ = requestIdExtensionBuilder_.build();
      }
      if (localReplyConfigBuilder_ == null) {
        result.localReplyConfig_ = localReplyConfig_;
      } else {
        result.localReplyConfig_ = localReplyConfigBuilder_.build();
      }
      result.stripMatchingHostPort_ = stripMatchingHostPort_;
      if (stripPortModeCase_ == 42) {
        result.stripPortMode_ = stripPortMode_;
      }
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        result.streamErrorOnInvalidHttpMessage_ = streamErrorOnInvalidHttpMessage_;
      } else {
        result.streamErrorOnInvalidHttpMessage_ = streamErrorOnInvalidHttpMessageBuilder_.build();
      }
      result.routeSpecifierCase_ = routeSpecifierCase_;
      result.stripPortModeCase_ = stripPortModeCase_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager) {
        return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager other) {
      if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDefaultInstance()) return this;
      if (other.codecType_ != 0) {
        setCodecTypeValue(other.getCodecTypeValue());
      }
      if (!other.getStatPrefix().isEmpty()) {
        statPrefix_ = other.statPrefix_;
        onChanged();
      }
      if (httpFiltersBuilder_ == null) {
        if (!other.httpFilters_.isEmpty()) {
          if (httpFilters_.isEmpty()) {
            httpFilters_ = other.httpFilters_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureHttpFiltersIsMutable();
            httpFilters_.addAll(other.httpFilters_);
          }
          onChanged();
        }
      } else {
        if (!other.httpFilters_.isEmpty()) {
          if (httpFiltersBuilder_.isEmpty()) {
            httpFiltersBuilder_.dispose();
            httpFiltersBuilder_ = null;
            httpFilters_ = other.httpFilters_;
            bitField0_ = (bitField0_ & ~0x00000001);
            httpFiltersBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getHttpFiltersFieldBuilder() : null;
          } else {
            httpFiltersBuilder_.addAllMessages(other.httpFilters_);
          }
        }
      }
      if (other.hasAddUserAgent()) {
        mergeAddUserAgent(other.getAddUserAgent());
      }
      if (other.hasTracing()) {
        mergeTracing(other.getTracing());
      }
      if (other.hasCommonHttpProtocolOptions()) {
        mergeCommonHttpProtocolOptions(other.getCommonHttpProtocolOptions());
      }
      if (other.hasHttpProtocolOptions()) {
        mergeHttpProtocolOptions(other.getHttpProtocolOptions());
      }
      if (other.hasHttp2ProtocolOptions()) {
        mergeHttp2ProtocolOptions(other.getHttp2ProtocolOptions());
      }
      if (!other.getServerName().isEmpty()) {
        serverName_ = other.serverName_;
        onChanged();
      }
      if (other.serverHeaderTransformation_ != 0) {
        setServerHeaderTransformationValue(other.getServerHeaderTransformationValue());
      }
      if (other.hasMaxRequestHeadersKb()) {
        mergeMaxRequestHeadersKb(other.getMaxRequestHeadersKb());
      }
      if (other.hasStreamIdleTimeout()) {
        mergeStreamIdleTimeout(other.getStreamIdleTimeout());
      }
      if (other.hasRequestTimeout()) {
        mergeRequestTimeout(other.getRequestTimeout());
      }
      if (other.hasRequestHeadersTimeout()) {
        mergeRequestHeadersTimeout(other.getRequestHeadersTimeout());
      }
      if (other.hasDrainTimeout()) {
        mergeDrainTimeout(other.getDrainTimeout());
      }
      if (other.hasDelayedCloseTimeout()) {
        mergeDelayedCloseTimeout(other.getDelayedCloseTimeout());
      }
      if (accessLogBuilder_ == null) {
        if (!other.accessLog_.isEmpty()) {
          if (accessLog_.isEmpty()) {
            accessLog_ = other.accessLog_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureAccessLogIsMutable();
            accessLog_.addAll(other.accessLog_);
          }
          onChanged();
        }
      } else {
        if (!other.accessLog_.isEmpty()) {
          if (accessLogBuilder_.isEmpty()) {
            accessLogBuilder_.dispose();
            accessLogBuilder_ = null;
            accessLog_ = other.accessLog_;
            bitField0_ = (bitField0_ & ~0x00000002);
            accessLogBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getAccessLogFieldBuilder() : null;
          } else {
            accessLogBuilder_.addAllMessages(other.accessLog_);
          }
        }
      }
      if (other.hasUseRemoteAddress()) {
        mergeUseRemoteAddress(other.getUseRemoteAddress());
      }
      if (other.getXffNumTrustedHops() != 0) {
        setXffNumTrustedHops(other.getXffNumTrustedHops());
      }
      if (other.hasInternalAddressConfig()) {
        mergeInternalAddressConfig(other.getInternalAddressConfig());
      }
      if (other.getSkipXffAppend() != false) {
        setSkipXffAppend(other.getSkipXffAppend());
      }
      if (!other.getVia().isEmpty()) {
        via_ = other.via_;
        onChanged();
      }
      if (other.hasGenerateRequestId()) {
        mergeGenerateRequestId(other.getGenerateRequestId());
      }
      if (other.getPreserveExternalRequestId() != false) {
        setPreserveExternalRequestId(other.getPreserveExternalRequestId());
      }
      if (other.getAlwaysSetRequestIdInResponse() != false) {
        setAlwaysSetRequestIdInResponse(other.getAlwaysSetRequestIdInResponse());
      }
      if (other.forwardClientCertDetails_ != 0) {
        setForwardClientCertDetailsValue(other.getForwardClientCertDetailsValue());
      }
      if (other.hasSetCurrentClientCertDetails()) {
        mergeSetCurrentClientCertDetails(other.getSetCurrentClientCertDetails());
      }
      if (other.getProxy100Continue() != false) {
        setProxy100Continue(other.getProxy100Continue());
      }
      if (other.getRepresentIpv4RemoteAddressAsIpv4MappedIpv6() != false) {
        setRepresentIpv4RemoteAddressAsIpv4MappedIpv6(other.getRepresentIpv4RemoteAddressAsIpv4MappedIpv6());
      }
      if (upgradeConfigsBuilder_ == null) {
        if (!other.upgradeConfigs_.isEmpty()) {
          if (upgradeConfigs_.isEmpty()) {
            upgradeConfigs_ = other.upgradeConfigs_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureUpgradeConfigsIsMutable();
            upgradeConfigs_.addAll(other.upgradeConfigs_);
          }
          onChanged();
        }
      } else {
        if (!other.upgradeConfigs_.isEmpty()) {
          if (upgradeConfigsBuilder_.isEmpty()) {
            upgradeConfigsBuilder_.dispose();
            upgradeConfigsBuilder_ = null;
            upgradeConfigs_ = other.upgradeConfigs_;
            bitField0_ = (bitField0_ & ~0x00000004);
            upgradeConfigsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getUpgradeConfigsFieldBuilder() : null;
          } else {
            upgradeConfigsBuilder_.addAllMessages(other.upgradeConfigs_);
          }
        }
      }
      if (other.hasNormalizePath()) {
        mergeNormalizePath(other.getNormalizePath());
      }
      if (other.getMergeSlashes() != false) {
        setMergeSlashes(other.getMergeSlashes());
      }
      if (other.hasRequestIdExtension()) {
        mergeRequestIdExtension(other.getRequestIdExtension());
      }
      if (other.hasLocalReplyConfig()) {
        mergeLocalReplyConfig(other.getLocalReplyConfig());
      }
      if (other.getStripMatchingHostPort() != false) {
        setStripMatchingHostPort(other.getStripMatchingHostPort());
      }
      if (other.hasStreamErrorOnInvalidHttpMessage()) {
        mergeStreamErrorOnInvalidHttpMessage(other.getStreamErrorOnInvalidHttpMessage());
      }
      switch (other.getRouteSpecifierCase()) {
        case RDS: {
          mergeRds(other.getRds());
          break;
        }
        case ROUTE_CONFIG: {
          mergeRouteConfig(other.getRouteConfig());
          break;
        }
        case SCOPED_ROUTES: {
          mergeScopedRoutes(other.getScopedRoutes());
          break;
        }
        case ROUTESPECIFIER_NOT_SET: {
          break;
        }
      }
      switch (other.getStripPortModeCase()) {
        case STRIP_ANY_HOST_PORT: {
          setStripAnyHostPort(other.getStripAnyHostPort());
          break;
        }
        case STRIPPORTMODE_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int routeSpecifierCase_ = 0;
    private java.lang.Object routeSpecifier_;
    public RouteSpecifierCase
        getRouteSpecifierCase() {
      return RouteSpecifierCase.forNumber(
          routeSpecifierCase_);
    }

    public Builder clearRouteSpecifier() {
      routeSpecifierCase_ = 0;
      routeSpecifier_ = null;
      onChanged();
      return this;
    }

    private int stripPortModeCase_ = 0;
    private java.lang.Object stripPortMode_;
    public StripPortModeCase
        getStripPortModeCase() {
      return StripPortModeCase.forNumber(
          stripPortModeCase_);
    }

    public Builder clearStripPortMode() {
      stripPortModeCase_ = 0;
      stripPortMode_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;

    private int codecType_ = 0;
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for codecType.
     */
    @java.lang.Override public int getCodecTypeValue() {
      return codecType_;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for codecType to set.
     * @return This builder for chaining.
     */
    public Builder setCodecTypeValue(int value) {
      
      codecType_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @return The codecType.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType getCodecType() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.valueOf(codecType_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @param value The codecType to set.
     * @return This builder for chaining.
     */
    public Builder setCodecType(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      codecType_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearCodecType() {
      
      codecType_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object statPrefix_ = "";
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @return The statPrefix.
     */
    public java.lang.String getStatPrefix() {
      java.lang.Object ref = statPrefix_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        statPrefix_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @return The bytes for statPrefix.
     */
    public com.google.protobuf.ByteString
        getStatPrefixBytes() {
      java.lang.Object ref = statPrefix_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        statPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @param value The statPrefix to set.
     * @return This builder for chaining.
     */
    public Builder setStatPrefix(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      statPrefix_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearStatPrefix() {
      
      statPrefix_ = getDefaultInstance().getStatPrefix();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @param value The bytes for statPrefix to set.
     * @return This builder for chaining.
     */
    public Builder setStatPrefixBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      statPrefix_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder> rdsBuilder_;
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     * @return Whether the rds field is set.
     */
    @java.lang.Override
    public boolean hasRds() {
      return routeSpecifierCase_ == 3;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     * @return The rds.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds getRds() {
      if (rdsBuilder_ == null) {
        if (routeSpecifierCase_ == 3) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
      } else {
        if (routeSpecifierCase_ == 3) {
          return rdsBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder setRds(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds value) {
      if (rdsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        routeSpecifier_ = value;
        onChanged();
      } else {
        rdsBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 3;
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder setRds(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder builderForValue) {
      if (rdsBuilder_ == null) {
        routeSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        rdsBuilder_.setMessage(builderForValue.build());
      }
      routeSpecifierCase_ = 3;
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder mergeRds(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds value) {
      if (rdsBuilder_ == null) {
        if (routeSpecifierCase_ == 3 &&
            routeSpecifier_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance()) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.newBuilder((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          routeSpecifier_ = value;
        }
        onChanged();
      } else {
        if (routeSpecifierCase_ == 3) {
          rdsBuilder_.mergeFrom(value);
        }
        rdsBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 3;
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder clearRds() {
      if (rdsBuilder_ == null) {
        if (routeSpecifierCase_ == 3) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
          onChanged();
        }
      } else {
        if (routeSpecifierCase_ == 3) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
        }
        rdsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder getRdsBuilder() {
      return getRdsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder getRdsOrBuilder() {
      if ((routeSpecifierCase_ == 3) && (rdsBuilder_ != null)) {
        return rdsBuilder_.getMessageOrBuilder();
      } else {
        if (routeSpecifierCase_ == 3) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder> 
        getRdsFieldBuilder() {
      if (rdsBuilder_ == null) {
        if (!(routeSpecifierCase_ == 3)) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
        }
        rdsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder>(
                (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_,
                getParentForChildren(),
                isClean());
        routeSpecifier_ = null;
      }
      routeSpecifierCase_ = 3;
      onChanged();;
      return rdsBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.route.v3.RouteConfiguration, io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder, io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder> routeConfigBuilder_;
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     * @return Whether the routeConfig field is set.
     */
    @java.lang.Override
    public boolean hasRouteConfig() {
      return routeSpecifierCase_ == 4;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     * @return The routeConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.route.v3.RouteConfiguration getRouteConfig() {
      if (routeConfigBuilder_ == null) {
        if (routeSpecifierCase_ == 4) {
          return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
        }
        return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
      } else {
        if (routeSpecifierCase_ == 4) {
          return routeConfigBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder setRouteConfig(io.envoyproxy.envoy.config.route.v3.RouteConfiguration value) {
      if (routeConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        routeSpecifier_ = value;
        onChanged();
      } else {
        routeConfigBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 4;
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder setRouteConfig(
        io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder builderForValue) {
      if (routeConfigBuilder_ == null) {
        routeSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        routeConfigBuilder_.setMessage(builderForValue.build());
      }
      routeSpecifierCase_ = 4;
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder mergeRouteConfig(io.envoyproxy.envoy.config.route.v3.RouteConfiguration value) {
      if (routeConfigBuilder_ == null) {
        if (routeSpecifierCase_ == 4 &&
            routeSpecifier_ != io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance()) {
          routeSpecifier_ = io.envoyproxy.envoy.config.route.v3.RouteConfiguration.newBuilder((io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          routeSpecifier_ = value;
        }
        onChanged();
      } else {
        if (routeSpecifierCase_ == 4) {
          routeConfigBuilder_.mergeFrom(value);
        }
        routeConfigBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 4;
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder clearRouteConfig() {
      if (routeConfigBuilder_ == null) {
        if (routeSpecifierCase_ == 4) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
          onChanged();
        }
      } else {
        if (routeSpecifierCase_ == 4) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
        }
        routeConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder getRouteConfigBuilder() {
      return getRouteConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder getRouteConfigOrBuilder() {
      if ((routeSpecifierCase_ == 4) && (routeConfigBuilder_ != null)) {
        return routeConfigBuilder_.getMessageOrBuilder();
      } else {
        if (routeSpecifierCase_ == 4) {
          return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
        }
        return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.route.v3.RouteConfiguration, io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder, io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder> 
        getRouteConfigFieldBuilder() {
      if (routeConfigBuilder_ == null) {
        if (!(routeSpecifierCase_ == 4)) {
          routeSpecifier_ = io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
        }
        routeConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.route.v3.RouteConfiguration, io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder, io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder>(
                (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_,
                getParentForChildren(),
                isClean());
        routeSpecifier_ = null;
      }
      routeSpecifierCase_ = 4;
      onChanged();;
      return routeConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder> scopedRoutesBuilder_;
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     * @return Whether the scopedRoutes field is set.
     */
    @java.lang.Override
    public boolean hasScopedRoutes() {
      return routeSpecifierCase_ == 31;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     * @return The scopedRoutes.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes getScopedRoutes() {
      if (scopedRoutesBuilder_ == null) {
        if (routeSpecifierCase_ == 31) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
      } else {
        if (routeSpecifierCase_ == 31) {
          return scopedRoutesBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder setScopedRoutes(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes value) {
      if (scopedRoutesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        routeSpecifier_ = value;
        onChanged();
      } else {
        scopedRoutesBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 31;
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder setScopedRoutes(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder builderForValue) {
      if (scopedRoutesBuilder_ == null) {
        routeSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        scopedRoutesBuilder_.setMessage(builderForValue.build());
      }
      routeSpecifierCase_ = 31;
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder mergeScopedRoutes(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes value) {
      if (scopedRoutesBuilder_ == null) {
        if (routeSpecifierCase_ == 31 &&
            routeSpecifier_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance()) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.newBuilder((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          routeSpecifier_ = value;
        }
        onChanged();
      } else {
        if (routeSpecifierCase_ == 31) {
          scopedRoutesBuilder_.mergeFrom(value);
        }
        scopedRoutesBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 31;
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder clearScopedRoutes() {
      if (scopedRoutesBuilder_ == null) {
        if (routeSpecifierCase_ == 31) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
          onChanged();
        }
      } else {
        if (routeSpecifierCase_ == 31) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
        }
        scopedRoutesBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder getScopedRoutesBuilder() {
      return getScopedRoutesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder getScopedRoutesOrBuilder() {
      if ((routeSpecifierCase_ == 31) && (scopedRoutesBuilder_ != null)) {
        return scopedRoutesBuilder_.getMessageOrBuilder();
      } else {
        if (routeSpecifierCase_ == 31) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder> 
        getScopedRoutesFieldBuilder() {
      if (scopedRoutesBuilder_ == null) {
        if (!(routeSpecifierCase_ == 31)) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
        }
        scopedRoutesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder>(
                (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_,
                getParentForChildren(),
                isClean());
        routeSpecifier_ = null;
      }
      routeSpecifierCase_ = 31;
      onChanged();;
      return scopedRoutesBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> httpFilters_ =
      java.util.Collections.emptyList();
    private void ensureHttpFiltersIsMutable() {
      if (!((bitField0_ & 0x00000001) != 0)) {
        httpFilters_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter>(httpFilters_);
        bitField0_ |= 0x00000001;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> httpFiltersBuilder_;

    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getHttpFiltersList() {
      if (httpFiltersBuilder_ == null) {
        return java.util.Collections.unmodifiableList(httpFilters_);
      } else {
        return httpFiltersBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public int getHttpFiltersCount() {
      if (httpFiltersBuilder_ == null) {
        return httpFilters_.size();
      } else {
        return httpFiltersBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getHttpFilters(int index) {
      if (httpFiltersBuilder_ == null) {
        return httpFilters_.get(index);
      } else {
        return httpFiltersBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder setHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
      if (httpFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHttpFiltersIsMutable();
        httpFilters_.set(index, value);
        onChanged();
      } else {
        httpFiltersBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder setHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.set(index, builderForValue.build());
        onChanged();
      } else {
        httpFiltersBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
      if (httpFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHttpFiltersIsMutable();
        httpFilters_.add(value);
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
      if (httpFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHttpFiltersIsMutable();
        httpFilters_.add(index, value);
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.add(builderForValue.build());
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.add(index, builderForValue.build());
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addAllHttpFilters(
        java.lang.Iterable<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> values) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, httpFilters_);
        onChanged();
      } else {
        httpFiltersBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder clearHttpFilters() {
      if (httpFiltersBuilder_ == null) {
        httpFilters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
      } else {
        httpFiltersBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder removeHttpFilters(int index) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.remove(index);
        onChanged();
      } else {
        httpFiltersBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder getHttpFiltersBuilder(
        int index) {
      return getHttpFiltersFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getHttpFiltersOrBuilder(
        int index) {
      if (httpFiltersBuilder_ == null) {
        return httpFilters_.get(index);  } else {
        return httpFiltersBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
         getHttpFiltersOrBuilderList() {
      if (httpFiltersBuilder_ != null) {
        return httpFiltersBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(httpFilters_);
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addHttpFiltersBuilder() {
      return getHttpFiltersFieldBuilder().addBuilder(
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addHttpFiltersBuilder(
        int index) {
      return getHttpFiltersFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder> 
         getHttpFiltersBuilderList() {
      return getHttpFiltersFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
        getHttpFiltersFieldBuilder() {
      if (httpFiltersBuilder_ == null) {
        httpFiltersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder>(
                httpFilters_,
                ((bitField0_ & 0x00000001) != 0),
                getParentForChildren(),
                isClean());
        httpFilters_ = null;
      }
      return httpFiltersBuilder_;
    }

    private com.google.protobuf.BoolValue addUserAgent_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> addUserAgentBuilder_;
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     * @return Whether the addUserAgent field is set.
     */
    public boolean hasAddUserAgent() {
      return addUserAgentBuilder_ != null || addUserAgent_ != null;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     * @return The addUserAgent.
     */
    public com.google.protobuf.BoolValue getAddUserAgent() {
      if (addUserAgentBuilder_ == null) {
        return addUserAgent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
      } else {
        return addUserAgentBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder setAddUserAgent(com.google.protobuf.BoolValue value) {
      if (addUserAgentBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        addUserAgent_ = value;
        onChanged();
      } else {
        addUserAgentBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder setAddUserAgent(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (addUserAgentBuilder_ == null) {
        addUserAgent_ = builderForValue.build();
        onChanged();
      } else {
        addUserAgentBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder mergeAddUserAgent(com.google.protobuf.BoolValue value) {
      if (addUserAgentBuilder_ == null) {
        if (addUserAgent_ != null) {
          addUserAgent_ =
            com.google.protobuf.BoolValue.newBuilder(addUserAgent_).mergeFrom(value).buildPartial();
        } else {
          addUserAgent_ = value;
        }
        onChanged();
      } else {
        addUserAgentBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder clearAddUserAgent() {
      if (addUserAgentBuilder_ == null) {
        addUserAgent_ = null;
        onChanged();
      } else {
        addUserAgent_ = null;
        addUserAgentBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public com.google.protobuf.BoolValue.Builder getAddUserAgentBuilder() {
      
      onChanged();
      return getAddUserAgentFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getAddUserAgentOrBuilder() {
      if (addUserAgentBuilder_ != null) {
        return addUserAgentBuilder_.getMessageOrBuilder();
      } else {
        return addUserAgent_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
      }
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getAddUserAgentFieldBuilder() {
      if (addUserAgentBuilder_ == null) {
        addUserAgentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getAddUserAgent(),
                getParentForChildren(),
                isClean());
        addUserAgent_ = null;
      }
      return addUserAgentBuilder_;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder> tracingBuilder_;
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     * @return Whether the tracing field is set.
     */
    public boolean hasTracing() {
      return tracingBuilder_ != null || tracing_ != null;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     * @return The tracing.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getTracing() {
      if (tracingBuilder_ == null) {
        return tracing_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
      } else {
        return tracingBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder setTracing(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing value) {
      if (tracingBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        tracing_ = value;
        onChanged();
      } else {
        tracingBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder setTracing(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder builderForValue) {
      if (tracingBuilder_ == null) {
        tracing_ = builderForValue.build();
        onChanged();
      } else {
        tracingBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder mergeTracing(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing value) {
      if (tracingBuilder_ == null) {
        if (tracing_ != null) {
          tracing_ =
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.newBuilder(tracing_).mergeFrom(value).buildPartial();
        } else {
          tracing_ = value;
        }
        onChanged();
      } else {
        tracingBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder clearTracing() {
      if (tracingBuilder_ == null) {
        tracing_ = null;
        onChanged();
      } else {
        tracing_ = null;
        tracingBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder getTracingBuilder() {
      
      onChanged();
      return getTracingFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder getTracingOrBuilder() {
      if (tracingBuilder_ != null) {
        return tracingBuilder_.getMessageOrBuilder();
      } else {
        return tracing_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
      }
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder> 
        getTracingFieldBuilder() {
      if (tracingBuilder_ == null) {
        tracingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder>(
                getTracing(),
                getParentForChildren(),
                isClean());
        tracing_ = null;
      }
      return tracingBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions commonHttpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder> commonHttpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the commonHttpProtocolOptions field is set.
     */
    public boolean hasCommonHttpProtocolOptions() {
      return commonHttpProtocolOptionsBuilder_ != null || commonHttpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     * @return The commonHttpProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      } else {
        return commonHttpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setCommonHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        commonHttpProtocolOptions_ = value;
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setCommonHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder builderForValue) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeCommonHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (commonHttpProtocolOptions_ != null) {
          commonHttpProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.newBuilder(commonHttpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          commonHttpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = null;
        onChanged();
      } else {
        commonHttpProtocolOptions_ = null;
        commonHttpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder getCommonHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getCommonHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
      if (commonHttpProtocolOptionsBuilder_ != null) {
        return commonHttpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return commonHttpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder> 
        getCommonHttpProtocolOptionsFieldBuilder() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder>(
                getCommonHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        commonHttpProtocolOptions_ = null;
      }
      return commonHttpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions httpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder> httpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     * @return Whether the httpProtocolOptions field is set.
     */
    public boolean hasHttpProtocolOptions() {
      return httpProtocolOptionsBuilder_ != null || httpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     * @return The httpProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      } else {
        return httpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder setHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        httpProtocolOptions_ = value;
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder setHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder builderForValue) {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder mergeHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (httpProtocolOptions_ != null) {
          httpProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.newBuilder(httpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          httpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder clearHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = null;
        onChanged();
      } else {
        httpProtocolOptions_ = null;
        httpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder getHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
      if (httpProtocolOptionsBuilder_ != null) {
        return httpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return httpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder> 
        getHttpProtocolOptionsFieldBuilder() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder>(
                getHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        httpProtocolOptions_ = null;
      }
      return httpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions http2ProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder> http2ProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the http2ProtocolOptions field is set.
     */
    public boolean hasHttp2ProtocolOptions() {
      return http2ProtocolOptionsBuilder_ != null || http2ProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     * @return The http2ProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      } else {
        return http2ProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setHttp2ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        http2ProtocolOptions_ = value;
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setHttp2ProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder builderForValue) {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeHttp2ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (http2ProtocolOptions_ != null) {
          http2ProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.newBuilder(http2ProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          http2ProtocolOptions_ = value;
        }
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = null;
        onChanged();
      } else {
        http2ProtocolOptions_ = null;
        http2ProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder getHttp2ProtocolOptionsBuilder() {
      
      onChanged();
      return getHttp2ProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
      if (http2ProtocolOptionsBuilder_ != null) {
        return http2ProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return http2ProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder> 
        getHttp2ProtocolOptionsFieldBuilder() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder>(
                getHttp2ProtocolOptions(),
                getParentForChildren(),
                isClean());
        http2ProtocolOptions_ = null;
      }
      return http2ProtocolOptionsBuilder_;
    }

    private java.lang.Object serverName_ = "";
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is *envoy*.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @return The serverName.
     */
    public java.lang.String getServerName() {
      java.lang.Object ref = serverName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serverName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is *envoy*.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @return The bytes for serverName.
     */
    public com.google.protobuf.ByteString
        getServerNameBytes() {
      java.lang.Object ref = serverName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serverName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is *envoy*.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @param value The serverName to set.
     * @return This builder for chaining.
     */
    public Builder setServerName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      serverName_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is *envoy*.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearServerName() {
      
      serverName_ = getDefaultInstance().getServerName();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is *envoy*.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @param value The bytes for serverName to set.
     * @return This builder for chaining.
     */
    public Builder setServerNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      serverName_ = value;
      onChanged();
      return this;
    }

    private int serverHeaderTransformation_ = 0;
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for serverHeaderTransformation.
     */
    @java.lang.Override public int getServerHeaderTransformationValue() {
      return serverHeaderTransformation_;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for serverHeaderTransformation to set.
     * @return This builder for chaining.
     */
    public Builder setServerHeaderTransformationValue(int value) {
      
      serverHeaderTransformation_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @return The serverHeaderTransformation.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation getServerHeaderTransformation() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.valueOf(serverHeaderTransformation_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @param value The serverHeaderTransformation to set.
     * @return This builder for chaining.
     */
    public Builder setServerHeaderTransformation(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      serverHeaderTransformation_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearServerHeaderTransformation() {
      
      serverHeaderTransformation_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.UInt32Value maxRequestHeadersKb_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxRequestHeadersKbBuilder_;
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     * @return Whether the maxRequestHeadersKb field is set.
     */
    public boolean hasMaxRequestHeadersKb() {
      return maxRequestHeadersKbBuilder_ != null || maxRequestHeadersKb_ != null;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     * @return The maxRequestHeadersKb.
     */
    public com.google.protobuf.UInt32Value getMaxRequestHeadersKb() {
      if (maxRequestHeadersKbBuilder_ == null) {
        return maxRequestHeadersKb_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
      } else {
        return maxRequestHeadersKbBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder setMaxRequestHeadersKb(com.google.protobuf.UInt32Value value) {
      if (maxRequestHeadersKbBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxRequestHeadersKb_ = value;
        onChanged();
      } else {
        maxRequestHeadersKbBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder setMaxRequestHeadersKb(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (maxRequestHeadersKbBuilder_ == null) {
        maxRequestHeadersKb_ = builderForValue.build();
        onChanged();
      } else {
        maxRequestHeadersKbBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeMaxRequestHeadersKb(com.google.protobuf.UInt32Value value) {
      if (maxRequestHeadersKbBuilder_ == null) {
        if (maxRequestHeadersKb_ != null) {
          maxRequestHeadersKb_ =
            com.google.protobuf.UInt32Value.newBuilder(maxRequestHeadersKb_).mergeFrom(value).buildPartial();
        } else {
          maxRequestHeadersKb_ = value;
        }
        onChanged();
      } else {
        maxRequestHeadersKbBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder clearMaxRequestHeadersKb() {
      if (maxRequestHeadersKbBuilder_ == null) {
        maxRequestHeadersKb_ = null;
        onChanged();
      } else {
        maxRequestHeadersKb_ = null;
        maxRequestHeadersKbBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value.Builder getMaxRequestHeadersKbBuilder() {
      
      onChanged();
      return getMaxRequestHeadersKbFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestHeadersKbOrBuilder() {
      if (maxRequestHeadersKbBuilder_ != null) {
        return maxRequestHeadersKbBuilder_.getMessageOrBuilder();
      } else {
        return maxRequestHeadersKb_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
      }
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * The max configurable limit is 96 KiB, based on current implementation
     * constraints.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getMaxRequestHeadersKbFieldBuilder() {
      if (maxRequestHeadersKbBuilder_ == null) {
        maxRequestHeadersKbBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getMaxRequestHeadersKb(),
                getParentForChildren(),
                isClean());
        maxRequestHeadersKb_ = null;
      }
      return maxRequestHeadersKbBuilder_;
    }

    private com.google.protobuf.Duration streamIdleTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> streamIdleTimeoutBuilder_;
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the streamIdleTimeout field is set.
     */
    public boolean hasStreamIdleTimeout() {
      return streamIdleTimeoutBuilder_ != null || streamIdleTimeout_ != null;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     * @return The streamIdleTimeout.
     */
    public com.google.protobuf.Duration getStreamIdleTimeout() {
      if (streamIdleTimeoutBuilder_ == null) {
        return streamIdleTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
      } else {
        return streamIdleTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setStreamIdleTimeout(com.google.protobuf.Duration value) {
      if (streamIdleTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        streamIdleTimeout_ = value;
        onChanged();
      } else {
        streamIdleTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setStreamIdleTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (streamIdleTimeoutBuilder_ == null) {
        streamIdleTimeout_ = builderForValue.build();
        onChanged();
      } else {
        streamIdleTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeStreamIdleTimeout(com.google.protobuf.Duration value) {
      if (streamIdleTimeoutBuilder_ == null) {
        if (streamIdleTimeout_ != null) {
          streamIdleTimeout_ =
            com.google.protobuf.Duration.newBuilder(streamIdleTimeout_).mergeFrom(value).buildPartial();
        } else {
          streamIdleTimeout_ = value;
        }
        onChanged();
      } else {
        streamIdleTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearStreamIdleTimeout() {
      if (streamIdleTimeoutBuilder_ == null) {
        streamIdleTimeout_ = null;
        onChanged();
      } else {
        streamIdleTimeout_ = null;
        streamIdleTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getStreamIdleTimeoutBuilder() {
      
      onChanged();
      return getStreamIdleTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getStreamIdleTimeoutOrBuilder() {
      if (streamIdleTimeoutBuilder_ != null) {
        return streamIdleTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return streamIdleTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
      }
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getStreamIdleTimeoutFieldBuilder() {
      if (streamIdleTimeoutBuilder_ == null) {
        streamIdleTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getStreamIdleTimeout(),
                getParentForChildren(),
                isClean());
        streamIdleTimeout_ = null;
      }
      return streamIdleTimeoutBuilder_;
    }

    private com.google.protobuf.Duration requestTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> requestTimeoutBuilder_;
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the requestTimeout field is set.
     */
    public boolean hasRequestTimeout() {
      return requestTimeoutBuilder_ != null || requestTimeout_ != null;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     * @return The requestTimeout.
     */
    public com.google.protobuf.Duration getRequestTimeout() {
      if (requestTimeoutBuilder_ == null) {
        return requestTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
      } else {
        return requestTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setRequestTimeout(com.google.protobuf.Duration value) {
      if (requestTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        requestTimeout_ = value;
        onChanged();
      } else {
        requestTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setRequestTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (requestTimeoutBuilder_ == null) {
        requestTimeout_ = builderForValue.build();
        onChanged();
      } else {
        requestTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeRequestTimeout(com.google.protobuf.Duration value) {
      if (requestTimeoutBuilder_ == null) {
        if (requestTimeout_ != null) {
          requestTimeout_ =
            com.google.protobuf.Duration.newBuilder(requestTimeout_).mergeFrom(value).buildPartial();
        } else {
          requestTimeout_ = value;
        }
        onChanged();
      } else {
        requestTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearRequestTimeout() {
      if (requestTimeoutBuilder_ == null) {
        requestTimeout_ = null;
        onChanged();
      } else {
        requestTimeout_ = null;
        requestTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getRequestTimeoutBuilder() {
      
      onChanged();
      return getRequestTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getRequestTimeoutOrBuilder() {
      if (requestTimeoutBuilder_ != null) {
        return requestTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return requestTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getRequestTimeoutFieldBuilder() {
      if (requestTimeoutBuilder_ == null) {
        requestTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getRequestTimeout(),
                getParentForChildren(),
                isClean());
        requestTimeout_ = null;
      }
      return requestTimeoutBuilder_;
    }

    private com.google.protobuf.Duration requestHeadersTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> requestHeadersTimeoutBuilder_;
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     * @return Whether the requestHeadersTimeout field is set.
     */
    public boolean hasRequestHeadersTimeout() {
      return requestHeadersTimeoutBuilder_ != null || requestHeadersTimeout_ != null;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     * @return The requestHeadersTimeout.
     */
    public com.google.protobuf.Duration getRequestHeadersTimeout() {
      if (requestHeadersTimeoutBuilder_ == null) {
        return requestHeadersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
      } else {
        return requestHeadersTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder setRequestHeadersTimeout(com.google.protobuf.Duration value) {
      if (requestHeadersTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        requestHeadersTimeout_ = value;
        onChanged();
      } else {
        requestHeadersTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder setRequestHeadersTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (requestHeadersTimeoutBuilder_ == null) {
        requestHeadersTimeout_ = builderForValue.build();
        onChanged();
      } else {
        requestHeadersTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeRequestHeadersTimeout(com.google.protobuf.Duration value) {
      if (requestHeadersTimeoutBuilder_ == null) {
        if (requestHeadersTimeout_ != null) {
          requestHeadersTimeout_ =
            com.google.protobuf.Duration.newBuilder(requestHeadersTimeout_).mergeFrom(value).buildPartial();
        } else {
          requestHeadersTimeout_ = value;
        }
        onChanged();
      } else {
        requestHeadersTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder clearRequestHeadersTimeout() {
      if (requestHeadersTimeoutBuilder_ == null) {
        requestHeadersTimeout_ = null;
        onChanged();
      } else {
        requestHeadersTimeout_ = null;
        requestHeadersTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getRequestHeadersTimeoutBuilder() {
      
      onChanged();
      return getRequestHeadersTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getRequestHeadersTimeoutOrBuilder() {
      if (requestHeadersTimeoutBuilder_ != null) {
        return requestHeadersTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return requestHeadersTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getRequestHeadersTimeoutFieldBuilder() {
      if (requestHeadersTimeoutBuilder_ == null) {
        requestHeadersTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getRequestHeadersTimeout(),
                getParentForChildren(),
                isClean());
        requestHeadersTimeout_ = null;
      }
      return requestHeadersTimeoutBuilder_;
    }

    private com.google.protobuf.Duration drainTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> drainTimeoutBuilder_;
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     * @return Whether the drainTimeout field is set.
     */
    public boolean hasDrainTimeout() {
      return drainTimeoutBuilder_ != null || drainTimeout_ != null;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     * @return The drainTimeout.
     */
    public com.google.protobuf.Duration getDrainTimeout() {
      if (drainTimeoutBuilder_ == null) {
        return drainTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
      } else {
        return drainTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder setDrainTimeout(com.google.protobuf.Duration value) {
      if (drainTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        drainTimeout_ = value;
        onChanged();
      } else {
        drainTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder setDrainTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (drainTimeoutBuilder_ == null) {
        drainTimeout_ = builderForValue.build();
        onChanged();
      } else {
        drainTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder mergeDrainTimeout(com.google.protobuf.Duration value) {
      if (drainTimeoutBuilder_ == null) {
        if (drainTimeout_ != null) {
          drainTimeout_ =
            com.google.protobuf.Duration.newBuilder(drainTimeout_).mergeFrom(value).buildPartial();
        } else {
          drainTimeout_ = value;
        }
        onChanged();
      } else {
        drainTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder clearDrainTimeout() {
      if (drainTimeoutBuilder_ == null) {
        drainTimeout_ = null;
        onChanged();
      } else {
        drainTimeout_ = null;
        drainTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public com.google.protobuf.Duration.Builder getDrainTimeoutBuilder() {
      
      onChanged();
      return getDrainTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public com.google.protobuf.DurationOrBuilder getDrainTimeoutOrBuilder() {
      if (drainTimeoutBuilder_ != null) {
        return drainTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return drainTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
      }
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getDrainTimeoutFieldBuilder() {
      if (drainTimeoutBuilder_ == null) {
        drainTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getDrainTimeout(),
                getParentForChildren(),
                isClean());
        drainTimeout_ = null;
      }
      return drainTimeoutBuilder_;
    }

    private com.google.protobuf.Duration delayedCloseTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> delayedCloseTimeoutBuilder_;
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     * @return Whether the delayedCloseTimeout field is set.
     */
    public boolean hasDelayedCloseTimeout() {
      return delayedCloseTimeoutBuilder_ != null || delayedCloseTimeout_ != null;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     * @return The delayedCloseTimeout.
     */
    public com.google.protobuf.Duration getDelayedCloseTimeout() {
      if (delayedCloseTimeoutBuilder_ == null) {
        return delayedCloseTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
      } else {
        return delayedCloseTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder setDelayedCloseTimeout(com.google.protobuf.Duration value) {
      if (delayedCloseTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        delayedCloseTimeout_ = value;
        onChanged();
      } else {
        delayedCloseTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder setDelayedCloseTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (delayedCloseTimeoutBuilder_ == null) {
        delayedCloseTimeout_ = builderForValue.build();
        onChanged();
      } else {
        delayedCloseTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder mergeDelayedCloseTimeout(com.google.protobuf.Duration value) {
      if (delayedCloseTimeoutBuilder_ == null) {
        if (delayedCloseTimeout_ != null) {
          delayedCloseTimeout_ =
            com.google.protobuf.Duration.newBuilder(delayedCloseTimeout_).mergeFrom(value).buildPartial();
        } else {
          delayedCloseTimeout_ = value;
        }
        onChanged();
      } else {
        delayedCloseTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder clearDelayedCloseTimeout() {
      if (delayedCloseTimeoutBuilder_ == null) {
        delayedCloseTimeout_ = null;
        onChanged();
      } else {
        delayedCloseTimeout_ = null;
        delayedCloseTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public com.google.protobuf.Duration.Builder getDelayedCloseTimeoutBuilder() {
      
      onChanged();
      return getDelayedCloseTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public com.google.protobuf.DurationOrBuilder getDelayedCloseTimeoutOrBuilder() {
      if (delayedCloseTimeoutBuilder_ != null) {
        return delayedCloseTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return delayedCloseTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
      }
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getDelayedCloseTimeoutFieldBuilder() {
      if (delayedCloseTimeoutBuilder_ == null) {
        delayedCloseTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getDelayedCloseTimeout(),
                getParentForChildren(),
                isClean());
        delayedCloseTimeout_ = null;
      }
      return delayedCloseTimeoutBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> accessLog_ =
      java.util.Collections.emptyList();
    private void ensureAccessLogIsMutable() {
      if (!((bitField0_ & 0x00000002) != 0)) {
        accessLog_ = new java.util.ArrayList<io.envoyproxy.envoy.config.accesslog.v3.AccessLog>(accessLog_);
        bitField0_ |= 0x00000002;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> accessLogBuilder_;

    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> getAccessLogList() {
      if (accessLogBuilder_ == null) {
        return java.util.Collections.unmodifiableList(accessLog_);
      } else {
        return accessLogBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public int getAccessLogCount() {
      if (accessLogBuilder_ == null) {
        return accessLog_.size();
      } else {
        return accessLogBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index) {
      if (accessLogBuilder_ == null) {
        return accessLog_.get(index);
      } else {
        return accessLogBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder setAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.set(index, value);
        onChanged();
      } else {
        accessLogBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder setAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.set(index, builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.add(value);
        onChanged();
      } else {
        accessLogBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.add(index, value);
        onChanged();
      } else {
        accessLogBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.add(builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.add(index, builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAllAccessLog(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLog> values) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, accessLog_);
        onChanged();
      } else {
        accessLogBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder clearAccessLog() {
      if (accessLogBuilder_ == null) {
        accessLog_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
      } else {
        accessLogBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder removeAccessLog(int index) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.remove(index);
        onChanged();
      } else {
        accessLogBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder getAccessLogBuilder(
        int index) {
      return getAccessLogFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
        int index) {
      if (accessLogBuilder_ == null) {
        return accessLog_.get(index);  } else {
        return accessLogBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
         getAccessLogOrBuilderList() {
      if (accessLogBuilder_ != null) {
        return accessLogBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(accessLog_);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder addAccessLogBuilder() {
      return getAccessLogFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.accesslog.v3.AccessLog.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder addAccessLogBuilder(
        int index) {
      return getAccessLogFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder> 
         getAccessLogBuilderList() {
      return getAccessLogFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
        getAccessLogFieldBuilder() {
      if (accessLogBuilder_ == null) {
        accessLogBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder>(
                accessLog_,
                ((bitField0_ & 0x00000002) != 0),
                getParentForChildren(),
                isClean());
        accessLog_ = null;
      }
      return accessLogBuilder_;
    }

    private com.google.protobuf.BoolValue useRemoteAddress_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> useRemoteAddressBuilder_;
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the useRemoteAddress field is set.
     */
    public boolean hasUseRemoteAddress() {
      return useRemoteAddressBuilder_ != null || useRemoteAddress_ != null;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     * @return The useRemoteAddress.
     */
    public com.google.protobuf.BoolValue getUseRemoteAddress() {
      if (useRemoteAddressBuilder_ == null) {
        return useRemoteAddress_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
      } else {
        return useRemoteAddressBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setUseRemoteAddress(com.google.protobuf.BoolValue value) {
      if (useRemoteAddressBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        useRemoteAddress_ = value;
        onChanged();
      } else {
        useRemoteAddressBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setUseRemoteAddress(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (useRemoteAddressBuilder_ == null) {
        useRemoteAddress_ = builderForValue.build();
        onChanged();
      } else {
        useRemoteAddressBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeUseRemoteAddress(com.google.protobuf.BoolValue value) {
      if (useRemoteAddressBuilder_ == null) {
        if (useRemoteAddress_ != null) {
          useRemoteAddress_ =
            com.google.protobuf.BoolValue.newBuilder(useRemoteAddress_).mergeFrom(value).buildPartial();
        } else {
          useRemoteAddress_ = value;
        }
        onChanged();
      } else {
        useRemoteAddressBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearUseRemoteAddress() {
      if (useRemoteAddressBuilder_ == null) {
        useRemoteAddress_ = null;
        onChanged();
      } else {
        useRemoteAddress_ = null;
        useRemoteAddressBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.BoolValue.Builder getUseRemoteAddressBuilder() {
      
      onChanged();
      return getUseRemoteAddressFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getUseRemoteAddressOrBuilder() {
      if (useRemoteAddressBuilder_ != null) {
        return useRemoteAddressBuilder_.getMessageOrBuilder();
      } else {
        return useRemoteAddress_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
      }
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getUseRemoteAddressFieldBuilder() {
      if (useRemoteAddressBuilder_ == null) {
        useRemoteAddressBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getUseRemoteAddress(),
                getParentForChildren(),
                isClean());
        useRemoteAddress_ = null;
      }
      return useRemoteAddressBuilder_;
    }

    private int xffNumTrustedHops_ ;
    /**
     * <pre>
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     * </pre>
     *
     * <code>uint32 xff_num_trusted_hops = 19;</code>
     * @return The xffNumTrustedHops.
     */
    @java.lang.Override
    public int getXffNumTrustedHops() {
      return xffNumTrustedHops_;
    }
    /**
     * <pre>
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     * </pre>
     *
     * <code>uint32 xff_num_trusted_hops = 19;</code>
     * @param value The xffNumTrustedHops to set.
     * @return This builder for chaining.
     */
    public Builder setXffNumTrustedHops(int value) {
      
      xffNumTrustedHops_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     * </pre>
     *
     * <code>uint32 xff_num_trusted_hops = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearXffNumTrustedHops() {
      
      xffNumTrustedHops_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internalAddressConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder> internalAddressConfigBuilder_;
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     * @return Whether the internalAddressConfig field is set.
     */
    public boolean hasInternalAddressConfig() {
      return internalAddressConfigBuilder_ != null || internalAddressConfig_ != null;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     * @return The internalAddressConfig.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getInternalAddressConfig() {
      if (internalAddressConfigBuilder_ == null) {
        return internalAddressConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
      } else {
        return internalAddressConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder setInternalAddressConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig value) {
      if (internalAddressConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        internalAddressConfig_ = value;
        onChanged();
      } else {
        internalAddressConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder setInternalAddressConfig(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder builderForValue) {
      if (internalAddressConfigBuilder_ == null) {
        internalAddressConfig_ = builderForValue.build();
        onChanged();
      } else {
        internalAddressConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder mergeInternalAddressConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig value) {
      if (internalAddressConfigBuilder_ == null) {
        if (internalAddressConfig_ != null) {
          internalAddressConfig_ =
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.newBuilder(internalAddressConfig_).mergeFrom(value).buildPartial();
        } else {
          internalAddressConfig_ = value;
        }
        onChanged();
      } else {
        internalAddressConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder clearInternalAddressConfig() {
      if (internalAddressConfigBuilder_ == null) {
        internalAddressConfig_ = null;
        onChanged();
      } else {
        internalAddressConfig_ = null;
        internalAddressConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder getInternalAddressConfigBuilder() {
      
      onChanged();
      return getInternalAddressConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder getInternalAddressConfigOrBuilder() {
      if (internalAddressConfigBuilder_ != null) {
        return internalAddressConfigBuilder_.getMessageOrBuilder();
      } else {
        return internalAddressConfig_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
      }
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder> 
        getInternalAddressConfigFieldBuilder() {
      if (internalAddressConfigBuilder_ == null) {
        internalAddressConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder>(
                getInternalAddressConfig(),
                getParentForChildren(),
                isClean());
        internalAddressConfig_ = null;
      }
      return internalAddressConfigBuilder_;
    }

    private boolean skipXffAppend_ ;
    /**
     * <pre>
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so *skip_xff_append* should be used
     * when only an elision of XFF addition is intended.
     * </pre>
     *
     * <code>bool skip_xff_append = 21;</code>
     * @return The skipXffAppend.
     */
    @java.lang.Override
    public boolean getSkipXffAppend() {
      return skipXffAppend_;
    }
    /**
     * <pre>
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so *skip_xff_append* should be used
     * when only an elision of XFF addition is intended.
     * </pre>
     *
     * <code>bool skip_xff_append = 21;</code>
     * @param value The skipXffAppend to set.
     * @return This builder for chaining.
     */
    public Builder setSkipXffAppend(boolean value) {
      
      skipXffAppend_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so *skip_xff_append* should be used
     * when only an elision of XFF addition is intended.
     * </pre>
     *
     * <code>bool skip_xff_append = 21;</code>
     * @return This builder for chaining.
     */
    public Builder clearSkipXffAppend() {
      
      skipXffAppend_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object via_ = "";
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22;</code>
     * @return The via.
     */
    public java.lang.String getVia() {
      java.lang.Object ref = via_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        via_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22;</code>
     * @return The bytes for via.
     */
    public com.google.protobuf.ByteString
        getViaBytes() {
      java.lang.Object ref = via_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        via_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22;</code>
     * @param value The via to set.
     * @return This builder for chaining.
     */
    public Builder setVia(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      via_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22;</code>
     * @return This builder for chaining.
     */
    public Builder clearVia() {
      
      via_ = getDefaultInstance().getVia();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22;</code>
     * @param value The bytes for via to set.
     * @return This builder for chaining.
     */
    public Builder setViaBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      via_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.BoolValue generateRequestId_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> generateRequestIdBuilder_;
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     * @return Whether the generateRequestId field is set.
     */
    public boolean hasGenerateRequestId() {
      return generateRequestIdBuilder_ != null || generateRequestId_ != null;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     * @return The generateRequestId.
     */
    public com.google.protobuf.BoolValue getGenerateRequestId() {
      if (generateRequestIdBuilder_ == null) {
        return generateRequestId_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
      } else {
        return generateRequestIdBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder setGenerateRequestId(com.google.protobuf.BoolValue value) {
      if (generateRequestIdBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        generateRequestId_ = value;
        onChanged();
      } else {
        generateRequestIdBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder setGenerateRequestId(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (generateRequestIdBuilder_ == null) {
        generateRequestId_ = builderForValue.build();
        onChanged();
      } else {
        generateRequestIdBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder mergeGenerateRequestId(com.google.protobuf.BoolValue value) {
      if (generateRequestIdBuilder_ == null) {
        if (generateRequestId_ != null) {
          generateRequestId_ =
            com.google.protobuf.BoolValue.newBuilder(generateRequestId_).mergeFrom(value).buildPartial();
        } else {
          generateRequestId_ = value;
        }
        onChanged();
      } else {
        generateRequestIdBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder clearGenerateRequestId() {
      if (generateRequestIdBuilder_ == null) {
        generateRequestId_ = null;
        onChanged();
      } else {
        generateRequestId_ = null;
        generateRequestIdBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public com.google.protobuf.BoolValue.Builder getGenerateRequestIdBuilder() {
      
      onChanged();
      return getGenerateRequestIdFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getGenerateRequestIdOrBuilder() {
      if (generateRequestIdBuilder_ != null) {
        return generateRequestIdBuilder_.getMessageOrBuilder();
      } else {
        return generateRequestId_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
      }
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getGenerateRequestIdFieldBuilder() {
      if (generateRequestIdBuilder_ == null) {
        generateRequestIdBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getGenerateRequestId(),
                getParentForChildren(),
                isClean());
        generateRequestId_ = null;
      }
      return generateRequestIdBuilder_;
    }

    private boolean preserveExternalRequestId_ ;
    /**
     * <pre>
     * Whether the connection manager will keep the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     * </pre>
     *
     * <code>bool preserve_external_request_id = 32;</code>
     * @return The preserveExternalRequestId.
     */
    @java.lang.Override
    public boolean getPreserveExternalRequestId() {
      return preserveExternalRequestId_;
    }
    /**
     * <pre>
     * Whether the connection manager will keep the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     * </pre>
     *
     * <code>bool preserve_external_request_id = 32;</code>
     * @param value The preserveExternalRequestId to set.
     * @return This builder for chaining.
     */
    public Builder setPreserveExternalRequestId(boolean value) {
      
      preserveExternalRequestId_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will keep the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     * </pre>
     *
     * <code>bool preserve_external_request_id = 32;</code>
     * @return This builder for chaining.
     */
    public Builder clearPreserveExternalRequestId() {
      
      preserveExternalRequestId_ = false;
      onChanged();
      return this;
    }

    private boolean alwaysSetRequestIdInResponse_ ;
    /**
     * <pre>
     * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
     * </pre>
     *
     * <code>bool always_set_request_id_in_response = 37;</code>
     * @return The alwaysSetRequestIdInResponse.
     */
    @java.lang.Override
    public boolean getAlwaysSetRequestIdInResponse() {
      return alwaysSetRequestIdInResponse_;
    }
    /**
     * <pre>
     * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
     * </pre>
     *
     * <code>bool always_set_request_id_in_response = 37;</code>
     * @param value The alwaysSetRequestIdInResponse to set.
     * @return This builder for chaining.
     */
    public Builder setAlwaysSetRequestIdInResponse(boolean value) {
      
      alwaysSetRequestIdInResponse_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
     * </pre>
     *
     * <code>bool always_set_request_id_in_response = 37;</code>
     * @return This builder for chaining.
     */
    public Builder clearAlwaysSetRequestIdInResponse() {
      
      alwaysSetRequestIdInResponse_ = false;
      onChanged();
      return this;
    }

    private int forwardClientCertDetails_ = 0;
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for forwardClientCertDetails.
     */
    @java.lang.Override public int getForwardClientCertDetailsValue() {
      return forwardClientCertDetails_;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for forwardClientCertDetails to set.
     * @return This builder for chaining.
     */
    public Builder setForwardClientCertDetailsValue(int value) {
      
      forwardClientCertDetails_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @return The forwardClientCertDetails.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails getForwardClientCertDetails() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.valueOf(forwardClientCertDetails_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @param value The forwardClientCertDetails to set.
     * @return This builder for chaining.
     */
    public Builder setForwardClientCertDetails(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      forwardClientCertDetails_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearForwardClientCertDetails() {
      
      forwardClientCertDetails_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails setCurrentClientCertDetails_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder> setCurrentClientCertDetailsBuilder_;
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     * @return Whether the setCurrentClientCertDetails field is set.
     */
    public boolean hasSetCurrentClientCertDetails() {
      return setCurrentClientCertDetailsBuilder_ != null || setCurrentClientCertDetails_ != null;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     * @return The setCurrentClientCertDetails.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getSetCurrentClientCertDetails() {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        return setCurrentClientCertDetails_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
      } else {
        return setCurrentClientCertDetailsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder setSetCurrentClientCertDetails(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails value) {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        setCurrentClientCertDetails_ = value;
        onChanged();
      } else {
        setCurrentClientCertDetailsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder setSetCurrentClientCertDetails(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder builderForValue) {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        setCurrentClientCertDetails_ = builderForValue.build();
        onChanged();
      } else {
        setCurrentClientCertDetailsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder mergeSetCurrentClientCertDetails(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails value) {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        if (setCurrentClientCertDetails_ != null) {
          setCurrentClientCertDetails_ =
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.newBuilder(setCurrentClientCertDetails_).mergeFrom(value).buildPartial();
        } else {
          setCurrentClientCertDetails_ = value;
        }
        onChanged();
      } else {
        setCurrentClientCertDetailsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder clearSetCurrentClientCertDetails() {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        setCurrentClientCertDetails_ = null;
        onChanged();
      } else {
        setCurrentClientCertDetails_ = null;
        setCurrentClientCertDetailsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder getSetCurrentClientCertDetailsBuilder() {
      
      onChanged();
      return getSetCurrentClientCertDetailsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder getSetCurrentClientCertDetailsOrBuilder() {
      if (setCurrentClientCertDetailsBuilder_ != null) {
        return setCurrentClientCertDetailsBuilder_.getMessageOrBuilder();
      } else {
        return setCurrentClientCertDetails_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
      }
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
     * *By* is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder> 
        getSetCurrentClientCertDetailsFieldBuilder() {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        setCurrentClientCertDetailsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder>(
                getSetCurrentClientCertDetails(),
                getParentForChildren(),
                isClean());
        setCurrentClientCertDetails_ = null;
      }
      return setCurrentClientCertDetailsBuilder_;
    }

    private boolean proxy100Continue_ ;
    /**
     * <pre>
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     * </pre>
     *
     * <code>bool proxy_100_continue = 18;</code>
     * @return The proxy100Continue.
     */
    @java.lang.Override
    public boolean getProxy100Continue() {
      return proxy100Continue_;
    }
    /**
     * <pre>
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     * </pre>
     *
     * <code>bool proxy_100_continue = 18;</code>
     * @param value The proxy100Continue to set.
     * @return This builder for chaining.
     */
    public Builder setProxy100Continue(boolean value) {
      
      proxy100Continue_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     * </pre>
     *
     * <code>bool proxy_100_continue = 18;</code>
     * @return This builder for chaining.
     */
    public Builder clearProxy100Continue() {
      
      proxy100Continue_ = false;
      onChanged();
      return this;
    }

    private boolean representIpv4RemoteAddressAsIpv4MappedIpv6_ ;
    /**
     * <pre>
     * If
     * :ref:`use_remote_address
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
     * control.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
     * @return The representIpv4RemoteAddressAsIpv4MappedIpv6.
     */
    @java.lang.Override
    public boolean getRepresentIpv4RemoteAddressAsIpv4MappedIpv6() {
      return representIpv4RemoteAddressAsIpv4MappedIpv6_;
    }
    /**
     * <pre>
     * If
     * :ref:`use_remote_address
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
     * control.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
     * @param value The representIpv4RemoteAddressAsIpv4MappedIpv6 to set.
     * @return This builder for chaining.
     */
    public Builder setRepresentIpv4RemoteAddressAsIpv4MappedIpv6(boolean value) {
      
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If
     * :ref:`use_remote_address
     * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
     * control.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
     * @return This builder for chaining.
     */
    public Builder clearRepresentIpv4RemoteAddressAsIpv4MappedIpv6() {
      
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = false;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> upgradeConfigs_ =
      java.util.Collections.emptyList();
    private void ensureUpgradeConfigsIsMutable() {
      if (!((bitField0_ & 0x00000004) != 0)) {
        upgradeConfigs_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig>(upgradeConfigs_);
        bitField0_ |= 0x00000004;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> upgradeConfigsBuilder_;

    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> getUpgradeConfigsList() {
      if (upgradeConfigsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(upgradeConfigs_);
      } else {
        return upgradeConfigsBuilder_.getMessageList();
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public int getUpgradeConfigsCount() {
      if (upgradeConfigsBuilder_ == null) {
        return upgradeConfigs_.size();
      } else {
        return upgradeConfigsBuilder_.getCount();
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getUpgradeConfigs(int index) {
      if (upgradeConfigsBuilder_ == null) {
        return upgradeConfigs_.get(index);
      } else {
        return upgradeConfigsBuilder_.getMessage(index);
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder setUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig value) {
      if (upgradeConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.set(index, value);
        onChanged();
      } else {
        upgradeConfigsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder setUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder builderForValue) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.set(index, builderForValue.build());
        onChanged();
      } else {
        upgradeConfigsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig value) {
      if (upgradeConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(value);
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig value) {
      if (upgradeConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(index, value);
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder builderForValue) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(builderForValue.build());
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder builderForValue) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(index, builderForValue.build());
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addAllUpgradeConfigs(
        java.lang.Iterable<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> values) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, upgradeConfigs_);
        onChanged();
      } else {
        upgradeConfigsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder clearUpgradeConfigs() {
      if (upgradeConfigsBuilder_ == null) {
        upgradeConfigs_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
      } else {
        upgradeConfigsBuilder_.clear();
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder removeUpgradeConfigs(int index) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.remove(index);
        onChanged();
      } else {
        upgradeConfigsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder getUpgradeConfigsBuilder(
        int index) {
      return getUpgradeConfigsFieldBuilder().getBuilder(index);
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder getUpgradeConfigsOrBuilder(
        int index) {
      if (upgradeConfigsBuilder_ == null) {
        return upgradeConfigs_.get(index);  } else {
        return upgradeConfigsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
         getUpgradeConfigsOrBuilderList() {
      if (upgradeConfigsBuilder_ != null) {
        return upgradeConfigsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(upgradeConfigs_);
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder addUpgradeConfigsBuilder() {
      return getUpgradeConfigsFieldBuilder().addBuilder(
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance());
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder addUpgradeConfigsBuilder(
        int index) {
      return getUpgradeConfigsFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance());
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder> 
         getUpgradeConfigsBuilderList() {
      return getUpgradeConfigsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
        getUpgradeConfigsFieldBuilder() {
      if (upgradeConfigsBuilder_ == null) {
        upgradeConfigsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder>(
                upgradeConfigs_,
                ((bitField0_ & 0x00000004) != 0),
                getParentForChildren(),
                isClean());
        upgradeConfigs_ = null;
      }
      return upgradeConfigsBuilder_;
    }

    private com.google.protobuf.BoolValue normalizePath_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> normalizePathBuilder_;
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     * @return Whether the normalizePath field is set.
     */
    public boolean hasNormalizePath() {
      return normalizePathBuilder_ != null || normalizePath_ != null;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     * @return The normalizePath.
     */
    public com.google.protobuf.BoolValue getNormalizePath() {
      if (normalizePathBuilder_ == null) {
        return normalizePath_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
      } else {
        return normalizePathBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder setNormalizePath(com.google.protobuf.BoolValue value) {
      if (normalizePathBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        normalizePath_ = value;
        onChanged();
      } else {
        normalizePathBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder setNormalizePath(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (normalizePathBuilder_ == null) {
        normalizePath_ = builderForValue.build();
        onChanged();
      } else {
        normalizePathBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder mergeNormalizePath(com.google.protobuf.BoolValue value) {
      if (normalizePathBuilder_ == null) {
        if (normalizePath_ != null) {
          normalizePath_ =
            com.google.protobuf.BoolValue.newBuilder(normalizePath_).mergeFrom(value).buildPartial();
        } else {
          normalizePath_ = value;
        }
        onChanged();
      } else {
        normalizePathBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder clearNormalizePath() {
      if (normalizePathBuilder_ == null) {
        normalizePath_ = null;
        onChanged();
      } else {
        normalizePath_ = null;
        normalizePathBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public com.google.protobuf.BoolValue.Builder getNormalizePathBuilder() {
      
      onChanged();
      return getNormalizePathFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getNormalizePathOrBuilder() {
      if (normalizePathBuilder_ != null) {
        return normalizePathBuilder_.getMessageOrBuilder();
      } else {
        return normalizePath_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
      }
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream *:path* header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getNormalizePathFieldBuilder() {
      if (normalizePathBuilder_ == null) {
        normalizePathBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getNormalizePath(),
                getParentForChildren(),
                isClean());
        normalizePath_ = null;
      }
      return normalizePathBuilder_;
    }

    private boolean mergeSlashes_ ;
    /**
     * <pre>
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
     * setting this option, incoming requests with path `//dir///file` will not match against route
     * with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
     * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * </pre>
     *
     * <code>bool merge_slashes = 33;</code>
     * @return The mergeSlashes.
     */
    @java.lang.Override
    public boolean getMergeSlashes() {
      return mergeSlashes_;
    }
    /**
     * <pre>
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
     * setting this option, incoming requests with path `//dir///file` will not match against route
     * with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
     * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * </pre>
     *
     * <code>bool merge_slashes = 33;</code>
     * @param value The mergeSlashes to set.
     * @return This builder for chaining.
     */
    public Builder setMergeSlashes(boolean value) {
      
      mergeSlashes_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
     * setting this option, incoming requests with path `//dir///file` will not match against route
     * with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
     * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * </pre>
     *
     * <code>bool merge_slashes = 33;</code>
     * @return This builder for chaining.
     */
    public Builder clearMergeSlashes() {
      
      mergeSlashes_ = false;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension requestIdExtension_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder> requestIdExtensionBuilder_;
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     * @return Whether the requestIdExtension field is set.
     */
    public boolean hasRequestIdExtension() {
      return requestIdExtensionBuilder_ != null || requestIdExtension_ != null;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     * @return The requestIdExtension.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension getRequestIdExtension() {
      if (requestIdExtensionBuilder_ == null) {
        return requestIdExtension_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
      } else {
        return requestIdExtensionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder setRequestIdExtension(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension value) {
      if (requestIdExtensionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        requestIdExtension_ = value;
        onChanged();
      } else {
        requestIdExtensionBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder setRequestIdExtension(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder builderForValue) {
      if (requestIdExtensionBuilder_ == null) {
        requestIdExtension_ = builderForValue.build();
        onChanged();
      } else {
        requestIdExtensionBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder mergeRequestIdExtension(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension value) {
      if (requestIdExtensionBuilder_ == null) {
        if (requestIdExtension_ != null) {
          requestIdExtension_ =
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.newBuilder(requestIdExtension_).mergeFrom(value).buildPartial();
        } else {
          requestIdExtension_ = value;
        }
        onChanged();
      } else {
        requestIdExtensionBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder clearRequestIdExtension() {
      if (requestIdExtensionBuilder_ == null) {
        requestIdExtension_ = null;
        onChanged();
      } else {
        requestIdExtension_ = null;
        requestIdExtensionBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder getRequestIdExtensionBuilder() {
      
      onChanged();
      return getRequestIdExtensionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder getRequestIdExtensionOrBuilder() {
      if (requestIdExtensionBuilder_ != null) {
        return requestIdExtensionBuilder_.getMessageOrBuilder();
      } else {
        return requestIdExtension_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
      }
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations.
     * If not set, Envoy uses the default UUID-based behavior:
     * 1. Request ID is propagated using *x-request-id* header.
     * 2. Request ID is a universally unique identifier (UUID).
     * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder> 
        getRequestIdExtensionFieldBuilder() {
      if (requestIdExtensionBuilder_ == null) {
        requestIdExtensionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder>(
                getRequestIdExtension(),
                getParentForChildren(),
                isClean());
        requestIdExtension_ = null;
      }
      return requestIdExtensionBuilder_;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig localReplyConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder> localReplyConfigBuilder_;
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     * @return Whether the localReplyConfig field is set.
     */
    public boolean hasLocalReplyConfig() {
      return localReplyConfigBuilder_ != null || localReplyConfig_ != null;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     * @return The localReplyConfig.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig getLocalReplyConfig() {
      if (localReplyConfigBuilder_ == null) {
        return localReplyConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
      } else {
        return localReplyConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder setLocalReplyConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig value) {
      if (localReplyConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        localReplyConfig_ = value;
        onChanged();
      } else {
        localReplyConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder setLocalReplyConfig(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder builderForValue) {
      if (localReplyConfigBuilder_ == null) {
        localReplyConfig_ = builderForValue.build();
        onChanged();
      } else {
        localReplyConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder mergeLocalReplyConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig value) {
      if (localReplyConfigBuilder_ == null) {
        if (localReplyConfig_ != null) {
          localReplyConfig_ =
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.newBuilder(localReplyConfig_).mergeFrom(value).buildPartial();
        } else {
          localReplyConfig_ = value;
        }
        onChanged();
      } else {
        localReplyConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder clearLocalReplyConfig() {
      if (localReplyConfigBuilder_ == null) {
        localReplyConfig_ = null;
        onChanged();
      } else {
        localReplyConfig_ = null;
        localReplyConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder getLocalReplyConfigBuilder() {
      
      onChanged();
      return getLocalReplyConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder getLocalReplyConfigOrBuilder() {
      if (localReplyConfigBuilder_ != null) {
        return localReplyConfigBuilder_.getMessageOrBuilder();
      } else {
        return localReplyConfig_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
      }
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder> 
        getLocalReplyConfigFieldBuilder() {
      if (localReplyConfigBuilder_ == null) {
        localReplyConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder>(
                getLocalReplyConfig(),
                getParentForChildren(),
                isClean());
        localReplyConfig_ = null;
      }
      return localReplyConfigBuilder_;
    }

    private boolean stripMatchingHostPort_ ;
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_api_field_config.listener.v3.Listener.address&gt;`
     * local port and request method is not CONNECT. This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
     * @return The stripMatchingHostPort.
     */
    @java.lang.Override
    public boolean getStripMatchingHostPort() {
      return stripMatchingHostPort_;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_api_field_config.listener.v3.Listener.address&gt;`
     * local port and request method is not CONNECT. This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
     * @param value The stripMatchingHostPort to set.
     * @return This builder for chaining.
     */
    public Builder setStripMatchingHostPort(boolean value) {
      
      stripMatchingHostPort_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_api_field_config.listener.v3.Listener.address&gt;`
     * local port and request method is not CONNECT. This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearStripMatchingHostPort() {
      
      stripMatchingHostPort_ = false;
      onChanged();
      return this;
    }

    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if request method is not CONNECT.
     * This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @return Whether the stripAnyHostPort field is set.
     */
    public boolean hasStripAnyHostPort() {
      return stripPortModeCase_ == 42;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if request method is not CONNECT.
     * This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @return The stripAnyHostPort.
     */
    public boolean getStripAnyHostPort() {
      if (stripPortModeCase_ == 42) {
        return (java.lang.Boolean) stripPortMode_;
      }
      return false;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if request method is not CONNECT.
     * This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @param value The stripAnyHostPort to set.
     * @return This builder for chaining.
     */
    public Builder setStripAnyHostPort(boolean value) {
      stripPortModeCase_ = 42;
      stripPortMode_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if request method is not CONNECT.
     * This affects the upstream host header as well.
     * Without setting this option, incoming requests with host `example:443` will not match against
     * route with :ref:`domains&lt;envoy_api_field_config.route.v3.VirtualHost.domains&gt;` match set to `example`. Defaults to `false`. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of `strip_matching_host_port` or `strip_any_host_port` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @return This builder for chaining.
     */
    public Builder clearStripAnyHostPort() {
      if (stripPortModeCase_ == 42) {
        stripPortModeCase_ = 0;
        stripPortMode_ = null;
        onChanged();
      }
      return this;
    }

    private com.google.protobuf.BoolValue streamErrorOnInvalidHttpMessage_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> streamErrorOnInvalidHttpMessageBuilder_;
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     * @return Whether the streamErrorOnInvalidHttpMessage field is set.
     */
    public boolean hasStreamErrorOnInvalidHttpMessage() {
      return streamErrorOnInvalidHttpMessageBuilder_ != null || streamErrorOnInvalidHttpMessage_ != null;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     * @return The streamErrorOnInvalidHttpMessage.
     */
    public com.google.protobuf.BoolValue getStreamErrorOnInvalidHttpMessage() {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        return streamErrorOnInvalidHttpMessage_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
      } else {
        return streamErrorOnInvalidHttpMessageBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder setStreamErrorOnInvalidHttpMessage(com.google.protobuf.BoolValue value) {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        streamErrorOnInvalidHttpMessage_ = value;
        onChanged();
      } else {
        streamErrorOnInvalidHttpMessageBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder setStreamErrorOnInvalidHttpMessage(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        streamErrorOnInvalidHttpMessage_ = builderForValue.build();
        onChanged();
      } else {
        streamErrorOnInvalidHttpMessageBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder mergeStreamErrorOnInvalidHttpMessage(com.google.protobuf.BoolValue value) {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        if (streamErrorOnInvalidHttpMessage_ != null) {
          streamErrorOnInvalidHttpMessage_ =
            com.google.protobuf.BoolValue.newBuilder(streamErrorOnInvalidHttpMessage_).mergeFrom(value).buildPartial();
        } else {
          streamErrorOnInvalidHttpMessage_ = value;
        }
        onChanged();
      } else {
        streamErrorOnInvalidHttpMessageBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder clearStreamErrorOnInvalidHttpMessage() {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        streamErrorOnInvalidHttpMessage_ = null;
        onChanged();
      } else {
        streamErrorOnInvalidHttpMessage_ = null;
        streamErrorOnInvalidHttpMessageBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public com.google.protobuf.BoolValue.Builder getStreamErrorOnInvalidHttpMessageBuilder() {
      
      onChanged();
      return getStreamErrorOnInvalidHttpMessageFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getStreamErrorOnInvalidHttpMessageOrBuilder() {
      if (streamErrorOnInvalidHttpMessageBuilder_ != null) {
        return streamErrorOnInvalidHttpMessageBuilder_.getMessageOrBuilder();
      } else {
        return streamErrorOnInvalidHttpMessage_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
      }
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * *not* the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getStreamErrorOnInvalidHttpMessageFieldBuilder() {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        streamErrorOnInvalidHttpMessageBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getStreamErrorOnInvalidHttpMessage(),
                getParentForChildren(),
                isClean());
        streamErrorOnInvalidHttpMessage_ = null;
      }
      return streamErrorOnInvalidHttpMessageBuilder_;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
  }

  // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
  private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager();
  }

  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<HttpConnectionManager>
      PARSER = new com.google.protobuf.AbstractParser<HttpConnectionManager>() {
    @java.lang.Override
    public HttpConnectionManager parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new HttpConnectionManager(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<HttpConnectionManager> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<HttpConnectionManager> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

