// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/wasm/v3/wasm.proto

package io.envoyproxy.envoy.extensions.wasm.v3;

public interface VmConfigOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.wasm.v3.VmConfig)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * An ID which will be used along with a hash of the wasm code (or the name of the registered Null
   * VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
   * *vm_id* and code will use the same VM. May be left blank. Sharing a VM between plugins can
   * reduce memory utilization and make sharing of data easier which may have security implications.
   * See ref: "TODO: add ref" for details.
   * </pre>
   *
   * <code>string vm_id = 1;</code>
   * @return The vmId.
   */
  java.lang.String getVmId();
  /**
   * <pre>
   * An ID which will be used along with a hash of the wasm code (or the name of the registered Null
   * VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
   * *vm_id* and code will use the same VM. May be left blank. Sharing a VM between plugins can
   * reduce memory utilization and make sharing of data easier which may have security implications.
   * See ref: "TODO: add ref" for details.
   * </pre>
   *
   * <code>string vm_id = 1;</code>
   * @return The bytes for vmId.
   */
  com.google.protobuf.ByteString
      getVmIdBytes();

  /**
   * <pre>
   * The Wasm runtime type.
   * Available Wasm runtime types are registered as extensions. The following runtimes are included
   * in Envoy code base:
   * .. _extension_envoy.wasm.runtime.null:
   * **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
   * Envoy binary. The registered name is given in the *code* field as *inline_string*.
   * .. _extension_envoy.wasm.runtime.v8:
   * **envoy.wasm.runtime.v8**: `V8 &lt;https://v8.dev/&gt;`_-based WebAssembly runtime.
   * .. _extension_envoy.wasm.runtime.wavm:
   * **envoy.wasm.runtime.wavm**: `WAVM &lt;https://wavm.github.io/&gt;`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   * .. _extension_envoy.wasm.runtime.wasmtime:
   * **envoy.wasm.runtime.wasmtime**: `Wasmtime &lt;https://wasmtime.dev/&gt;`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   * </pre>
   *
   * <code>string runtime = 2 [(.validate.rules) = { ... }</code>
   * @return The runtime.
   */
  java.lang.String getRuntime();
  /**
   * <pre>
   * The Wasm runtime type.
   * Available Wasm runtime types are registered as extensions. The following runtimes are included
   * in Envoy code base:
   * .. _extension_envoy.wasm.runtime.null:
   * **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
   * Envoy binary. The registered name is given in the *code* field as *inline_string*.
   * .. _extension_envoy.wasm.runtime.v8:
   * **envoy.wasm.runtime.v8**: `V8 &lt;https://v8.dev/&gt;`_-based WebAssembly runtime.
   * .. _extension_envoy.wasm.runtime.wavm:
   * **envoy.wasm.runtime.wavm**: `WAVM &lt;https://wavm.github.io/&gt;`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   * .. _extension_envoy.wasm.runtime.wasmtime:
   * **envoy.wasm.runtime.wasmtime**: `Wasmtime &lt;https://wasmtime.dev/&gt;`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   * </pre>
   *
   * <code>string runtime = 2 [(.validate.rules) = { ... }</code>
   * @return The bytes for runtime.
   */
  com.google.protobuf.ByteString
      getRuntimeBytes();

  /**
   * <pre>
   * The Wasm code that Envoy will execute.
   * </pre>
   *
   * <code>.envoy.config.core.v3.AsyncDataSource code = 3;</code>
   * @return Whether the code field is set.
   */
  boolean hasCode();
  /**
   * <pre>
   * The Wasm code that Envoy will execute.
   * </pre>
   *
   * <code>.envoy.config.core.v3.AsyncDataSource code = 3;</code>
   * @return The code.
   */
  io.envoyproxy.envoy.config.core.v3.AsyncDataSource getCode();
  /**
   * <pre>
   * The Wasm code that Envoy will execute.
   * </pre>
   *
   * <code>.envoy.config.core.v3.AsyncDataSource code = 3;</code>
   */
  io.envoyproxy.envoy.config.core.v3.AsyncDataSourceOrBuilder getCodeOrBuilder();

  /**
   * <pre>
   * The Wasm configuration used in initialization of a new VM
   * (proxy_on_start). `google.protobuf.Struct` is serialized as JSON before
   * passing it to the plugin. `google.protobuf.BytesValue` and
   * `google.protobuf.StringValue` are passed directly without the wrapper.
   * </pre>
   *
   * <code>.google.protobuf.Any configuration = 4;</code>
   * @return Whether the configuration field is set.
   */
  boolean hasConfiguration();
  /**
   * <pre>
   * The Wasm configuration used in initialization of a new VM
   * (proxy_on_start). `google.protobuf.Struct` is serialized as JSON before
   * passing it to the plugin. `google.protobuf.BytesValue` and
   * `google.protobuf.StringValue` are passed directly without the wrapper.
   * </pre>
   *
   * <code>.google.protobuf.Any configuration = 4;</code>
   * @return The configuration.
   */
  com.google.protobuf.Any getConfiguration();
  /**
   * <pre>
   * The Wasm configuration used in initialization of a new VM
   * (proxy_on_start). `google.protobuf.Struct` is serialized as JSON before
   * passing it to the plugin. `google.protobuf.BytesValue` and
   * `google.protobuf.StringValue` are passed directly without the wrapper.
   * </pre>
   *
   * <code>.google.protobuf.Any configuration = 4;</code>
   */
  com.google.protobuf.AnyOrBuilder getConfigurationOrBuilder();

  /**
   * <pre>
   * Allow the wasm file to include pre-compiled code on VMs which support it.
   * Warning: this should only be enable for trusted sources as the precompiled code is not
   * verified.
   * </pre>
   *
   * <code>bool allow_precompiled = 5;</code>
   * @return The allowPrecompiled.
   */
  boolean getAllowPrecompiled();

  /**
   * <pre>
   * If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
   * update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
   * warming state.
   * </pre>
   *
   * <code>bool nack_on_code_cache_miss = 6;</code>
   * @return The nackOnCodeCacheMiss.
   */
  boolean getNackOnCodeCacheMiss();
}
