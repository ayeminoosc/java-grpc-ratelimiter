// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto

package io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3;

public interface DnsCacheConfigOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The name of the cache. Multiple named caches allow independent dynamic forward proxy
   * configurations to operate within a single Envoy process using different configurations. All
   * configurations with the same name *must* otherwise have the same settings when referenced
   * from different configuration components. Configuration will fail to load if this is not
   * the case.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * The name of the cache. Multiple named caches allow independent dynamic forward proxy
   * configurations to operate within a single Envoy process using different configurations. All
   * configurations with the same name *must* otherwise have the same settings when referenced
   * from different configuration components. Configuration will fail to load if this is not
   * the case.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * The DNS lookup family to use during resolution.
   * [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
   * way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
   * then configures a host to have a primary and fall back address. With this, we could very
   * likely build a "happy eyeballs" connection pool which would race the primary / fall back
   * address and return the one that wins. This same method could potentially also be used for
   * QUIC to TCP fall back.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 2 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for dnsLookupFamily.
   */
  int getDnsLookupFamilyValue();
  /**
   * <pre>
   * The DNS lookup family to use during resolution.
   * [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
   * way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
   * then configures a host to have a primary and fall back address. With this, we could very
   * likely build a "happy eyeballs" connection pool which would race the primary / fall back
   * address and return the one that wins. This same method could potentially also be used for
   * QUIC to TCP fall back.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 2 [(.validate.rules) = { ... }</code>
   * @return The dnsLookupFamily.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily getDnsLookupFamily();

  /**
   * <pre>
   * The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
   * .. note:
   *  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
   *  added in a future change.
   * .. note:
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsRefreshRate field is set.
   */
  boolean hasDnsRefreshRate();
  /**
   * <pre>
   * The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
   * .. note:
   *  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
   *  added in a future change.
   * .. note:
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 3 [(.validate.rules) = { ... }</code>
   * @return The dnsRefreshRate.
   */
  com.google.protobuf.Duration getDnsRefreshRate();
  /**
   * <pre>
   * The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
   * .. note:
   *  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
   *  added in a future change.
   * .. note:
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 3 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder();

  /**
   * <pre>
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   * .. note:
   *   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *  .. note:
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   * </pre>
   *
   * <code>.google.protobuf.Duration host_ttl = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the hostTtl field is set.
   */
  boolean hasHostTtl();
  /**
   * <pre>
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   * .. note:
   *   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *  .. note:
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   * </pre>
   *
   * <code>.google.protobuf.Duration host_ttl = 4 [(.validate.rules) = { ... }</code>
   * @return The hostTtl.
   */
  com.google.protobuf.Duration getHostTtl();
  /**
   * <pre>
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   * .. note:
   *   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *  .. note:
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   * </pre>
   *
   * <code>.google.protobuf.Duration host_ttl = 4 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getHostTtlOrBuilder();

  /**
   * <pre>
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   * .. note:
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_hosts = 5 [(.validate.rules) = { ... }</code>
   * @return Whether the maxHosts field is set.
   */
  boolean hasMaxHosts();
  /**
   * <pre>
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   * .. note:
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_hosts = 5 [(.validate.rules) = { ... }</code>
   * @return The maxHosts.
   */
  com.google.protobuf.UInt32Value getMaxHosts();
  /**
   * <pre>
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   * .. note:
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_hosts = 5 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxHostsOrBuilder();

  /**
   * <pre>
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;</code>
   * @return Whether the dnsFailureRefreshRate field is set.
   */
  boolean hasDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;</code>
   * @return The dnsFailureRefreshRate.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder getDnsFailureRefreshRateOrBuilder();

  /**
   * <pre>
   * The config of circuit breakers for resolver. It provides a configurable threshold.
   * If `envoy.reloadable_features.enable_dns_cache_circuit_breakers` is enabled,
   * envoy will use dns cache circuit breakers with default settings even if this value is not set.
   * </pre>
   *
   * <code>.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;</code>
   * @return Whether the dnsCacheCircuitBreaker field is set.
   */
  boolean hasDnsCacheCircuitBreaker();
  /**
   * <pre>
   * The config of circuit breakers for resolver. It provides a configurable threshold.
   * If `envoy.reloadable_features.enable_dns_cache_circuit_breakers` is enabled,
   * envoy will use dns cache circuit breakers with default settings even if this value is not set.
   * </pre>
   *
   * <code>.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;</code>
   * @return The dnsCacheCircuitBreaker.
   */
  io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers getDnsCacheCircuitBreaker();
  /**
   * <pre>
   * The config of circuit breakers for resolver. It provides a configurable threshold.
   * If `envoy.reloadable_features.enable_dns_cache_circuit_breakers` is enabled,
   * envoy will use dns cache circuit breakers with default settings even if this value is not set.
   * </pre>
   *
   * <code>.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;</code>
   */
  io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakersOrBuilder getDnsCacheCircuitBreakerOrBuilder();

  /**
   * <pre>
   * [#next-major-version: Reconcile DNS options in a single message.]
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple' API only uses UDP for DNS resolution.
   * </pre>
   *
   * <code>bool use_tcp_for_dns_lookups = 8;</code>
   * @return The useTcpForDnsLookups.
   */
  boolean getUseTcpForDnsLookups();
}
