// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/route/v3/route_components.proto

package io.envoyproxy.envoy.config.route.v3;

public interface RouteMatchOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.route.v3.RouteMatch)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * If specified, the route is a prefix rule meaning that the prefix must
   * match the beginning of the *:path* header.
   * </pre>
   *
   * <code>string prefix = 1;</code>
   * @return Whether the prefix field is set.
   */
  boolean hasPrefix();
  /**
   * <pre>
   * If specified, the route is a prefix rule meaning that the prefix must
   * match the beginning of the *:path* header.
   * </pre>
   *
   * <code>string prefix = 1;</code>
   * @return The prefix.
   */
  java.lang.String getPrefix();
  /**
   * <pre>
   * If specified, the route is a prefix rule meaning that the prefix must
   * match the beginning of the *:path* header.
   * </pre>
   *
   * <code>string prefix = 1;</code>
   * @return The bytes for prefix.
   */
  com.google.protobuf.ByteString
      getPrefixBytes();

  /**
   * <pre>
   * If specified, the route is an exact path rule meaning that the path must
   * exactly match the *:path* header once the query string is removed.
   * </pre>
   *
   * <code>string path = 2;</code>
   * @return Whether the path field is set.
   */
  boolean hasPath();
  /**
   * <pre>
   * If specified, the route is an exact path rule meaning that the path must
   * exactly match the *:path* header once the query string is removed.
   * </pre>
   *
   * <code>string path = 2;</code>
   * @return The path.
   */
  java.lang.String getPath();
  /**
   * <pre>
   * If specified, the route is an exact path rule meaning that the path must
   * exactly match the *:path* header once the query string is removed.
   * </pre>
   *
   * <code>string path = 2;</code>
   * @return The bytes for path.
   */
  com.google.protobuf.ByteString
      getPathBytes();

  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex.
   * [#next-major-version: In the v3 API we should redo how path specification works such
   * that we utilize StringMatcher, and additionally have consistent options around whether we
   * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
   * to deprecate the existing options. We should even consider whether we want to do away with
   * path_specifier entirely and just rely on a set of header matchers which can already match
   * on :path, etc. The issue with that is it is unclear how to generically deal with query string
   * stripping. This needs more thought.]
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatcher safe_regex = 10 [(.validate.rules) = { ... }</code>
   * @return Whether the safeRegex field is set.
   */
  boolean hasSafeRegex();
  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex.
   * [#next-major-version: In the v3 API we should redo how path specification works such
   * that we utilize StringMatcher, and additionally have consistent options around whether we
   * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
   * to deprecate the existing options. We should even consider whether we want to do away with
   * path_specifier entirely and just rely on a set of header matchers which can already match
   * on :path, etc. The issue with that is it is unclear how to generically deal with query string
   * stripping. This needs more thought.]
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatcher safe_regex = 10 [(.validate.rules) = { ... }</code>
   * @return The safeRegex.
   */
  io.envoyproxy.envoy.type.matcher.v3.RegexMatcher getSafeRegex();
  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex.
   * [#next-major-version: In the v3 API we should redo how path specification works such
   * that we utilize StringMatcher, and additionally have consistent options around whether we
   * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
   * to deprecate the existing options. We should even consider whether we want to do away with
   * path_specifier entirely and just rely on a set of header matchers which can already match
   * on :path, etc. The issue with that is it is unclear how to generically deal with query string
   * stripping. This needs more thought.]
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatcher safe_regex = 10 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.type.matcher.v3.RegexMatcherOrBuilder getSafeRegexOrBuilder();

  /**
   * <pre>
   * If this is used as the matcher, the matcher will only match CONNECT requests.
   * Note that this will not match HTTP/2 upgrade-style CONNECT requests
   * (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
   * upgrades.
   * This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
   * where Extended CONNECT requests may have a path, the path matchers will work if
   * there is a path present.
   * Note that CONNECT support is currently considered alpha in Envoy.
   * [#comment:TODO(htuch): Replace the above comment with an alpha tag.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher = 12;</code>
   * @return Whether the connectMatcher field is set.
   */
  boolean hasConnectMatcher();
  /**
   * <pre>
   * If this is used as the matcher, the matcher will only match CONNECT requests.
   * Note that this will not match HTTP/2 upgrade-style CONNECT requests
   * (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
   * upgrades.
   * This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
   * where Extended CONNECT requests may have a path, the path matchers will work if
   * there is a path present.
   * Note that CONNECT support is currently considered alpha in Envoy.
   * [#comment:TODO(htuch): Replace the above comment with an alpha tag.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher = 12;</code>
   * @return The connectMatcher.
   */
  io.envoyproxy.envoy.config.route.v3.RouteMatch.ConnectMatcher getConnectMatcher();
  /**
   * <pre>
   * If this is used as the matcher, the matcher will only match CONNECT requests.
   * Note that this will not match HTTP/2 upgrade-style CONNECT requests
   * (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
   * upgrades.
   * This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
   * where Extended CONNECT requests may have a path, the path matchers will work if
   * there is a path present.
   * Note that CONNECT support is currently considered alpha in Envoy.
   * [#comment:TODO(htuch): Replace the above comment with an alpha tag.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher = 12;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteMatch.ConnectMatcherOrBuilder getConnectMatcherOrBuilder();

  /**
   * <pre>
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue case_sensitive = 4;</code>
   * @return Whether the caseSensitive field is set.
   */
  boolean hasCaseSensitive();
  /**
   * <pre>
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue case_sensitive = 4;</code>
   * @return The caseSensitive.
   */
  com.google.protobuf.BoolValue getCaseSensitive();
  /**
   * <pre>
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue case_sensitive = 4;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getCaseSensitiveOrBuilder();

  /**
   * <pre>
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is &lt;= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * &lt;config_http_conn_man_route_table_traffic_splitting_shift&gt;` docs for additional documentation.
   * .. note::
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 9;</code>
   * @return Whether the runtimeFraction field is set.
   */
  boolean hasRuntimeFraction();
  /**
   * <pre>
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is &lt;= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * &lt;config_http_conn_man_route_table_traffic_splitting_shift&gt;` docs for additional documentation.
   * .. note::
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 9;</code>
   * @return The runtimeFraction.
   */
  io.envoyproxy.envoy.config.core.v3.RuntimeFractionalPercent getRuntimeFraction();
  /**
   * <pre>
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is &lt;= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * &lt;config_http_conn_man_route_table_traffic_splitting_shift&gt;` docs for additional documentation.
   * .. note::
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 9;</code>
   */
  io.envoyproxy.envoy.config.core.v3.RuntimeFractionalPercentOrBuilder getRuntimeFractionOrBuilder();

  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.HeaderMatcher headers = 6;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.route.v3.HeaderMatcher> 
      getHeadersList();
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.HeaderMatcher headers = 6;</code>
   */
  io.envoyproxy.envoy.config.route.v3.HeaderMatcher getHeaders(int index);
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.HeaderMatcher headers = 6;</code>
   */
  int getHeadersCount();
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.HeaderMatcher headers = 6;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.route.v3.HeaderMatcherOrBuilder> 
      getHeadersOrBuilderList();
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.HeaderMatcher headers = 6;</code>
   */
  io.envoyproxy.envoy.config.route.v3.HeaderMatcherOrBuilder getHeadersOrBuilder(
      int index);

  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.route.v3.QueryParameterMatcher> 
      getQueryParametersList();
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;</code>
   */
  io.envoyproxy.envoy.config.route.v3.QueryParameterMatcher getQueryParameters(int index);
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;</code>
   */
  int getQueryParametersCount();
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.route.v3.QueryParameterMatcherOrBuilder> 
      getQueryParametersOrBuilderList();
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;</code>
   */
  io.envoyproxy.envoy.config.route.v3.QueryParameterMatcherOrBuilder getQueryParametersOrBuilder(
      int index);

  /**
   * <pre>
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc = 8;</code>
   * @return Whether the grpc field is set.
   */
  boolean hasGrpc();
  /**
   * <pre>
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc = 8;</code>
   * @return The grpc.
   */
  io.envoyproxy.envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions getGrpc();
  /**
   * <pre>
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc = 8;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptionsOrBuilder getGrpcOrBuilder();

  /**
   * <pre>
   * If specified, the client tls context will be matched against the defined
   * match options.
   * [#next-major-version: unify with RBAC]
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context = 11;</code>
   * @return Whether the tlsContext field is set.
   */
  boolean hasTlsContext();
  /**
   * <pre>
   * If specified, the client tls context will be matched against the defined
   * match options.
   * [#next-major-version: unify with RBAC]
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context = 11;</code>
   * @return The tlsContext.
   */
  io.envoyproxy.envoy.config.route.v3.RouteMatch.TlsContextMatchOptions getTlsContext();
  /**
   * <pre>
   * If specified, the client tls context will be matched against the defined
   * match options.
   * [#next-major-version: unify with RBAC]
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context = 11;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteMatch.TlsContextMatchOptionsOrBuilder getTlsContextOrBuilder();

  public io.envoyproxy.envoy.config.route.v3.RouteMatch.PathSpecifierCase getPathSpecifierCase();
}
