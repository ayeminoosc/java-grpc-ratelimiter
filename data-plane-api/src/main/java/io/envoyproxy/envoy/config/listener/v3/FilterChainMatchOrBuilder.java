// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/listener/v3/listener_components.proto

package io.envoyproxy.envoy.config.listener.v3;

public interface FilterChainMatchOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.listener.v3.FilterChainMatch)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Optional destination port to consider when use_original_dst is set on the
   * listener in determining a filter chain match.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value destination_port = 8 [(.validate.rules) = { ... }</code>
   * @return Whether the destinationPort field is set.
   */
  boolean hasDestinationPort();
  /**
   * <pre>
   * Optional destination port to consider when use_original_dst is set on the
   * listener in determining a filter chain match.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value destination_port = 8 [(.validate.rules) = { ... }</code>
   * @return The destinationPort.
   */
  com.google.protobuf.UInt32Value getDestinationPort();
  /**
   * <pre>
   * Optional destination port to consider when use_original_dst is set on the
   * listener in determining a filter chain match.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value destination_port = 8 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getDestinationPortOrBuilder();

  /**
   * <pre>
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange prefix_ranges = 3;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> 
      getPrefixRangesList();
  /**
   * <pre>
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange prefix_ranges = 3;</code>
   */
  io.envoyproxy.envoy.config.core.v3.CidrRange getPrefixRanges(int index);
  /**
   * <pre>
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange prefix_ranges = 3;</code>
   */
  int getPrefixRangesCount();
  /**
   * <pre>
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange prefix_ranges = 3;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> 
      getPrefixRangesOrBuilderList();
  /**
   * <pre>
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange prefix_ranges = 3;</code>
   */
  io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder getPrefixRangesOrBuilder(
      int index);

  /**
   * <pre>
   * If non-empty, an IP address and suffix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>string address_suffix = 4;</code>
   * @return The addressSuffix.
   */
  java.lang.String getAddressSuffix();
  /**
   * <pre>
   * If non-empty, an IP address and suffix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>string address_suffix = 4;</code>
   * @return The bytes for addressSuffix.
   */
  com.google.protobuf.ByteString
      getAddressSuffixBytes();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value suffix_len = 5;</code>
   * @return Whether the suffixLen field is set.
   */
  boolean hasSuffixLen();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value suffix_len = 5;</code>
   * @return The suffixLen.
   */
  com.google.protobuf.UInt32Value getSuffixLen();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value suffix_len = 5;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getSuffixLenOrBuilder();

  /**
   * <pre>
   * Specifies the connection source IP match type. Can be any, local or external network.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType source_type = 12 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for sourceType.
   */
  int getSourceTypeValue();
  /**
   * <pre>
   * Specifies the connection source IP match type. Can be any, local or external network.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType source_type = 12 [(.validate.rules) = { ... }</code>
   * @return The sourceType.
   */
  io.envoyproxy.envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType getSourceType();

  /**
   * <pre>
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange source_prefix_ranges = 6;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> 
      getSourcePrefixRangesList();
  /**
   * <pre>
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange source_prefix_ranges = 6;</code>
   */
  io.envoyproxy.envoy.config.core.v3.CidrRange getSourcePrefixRanges(int index);
  /**
   * <pre>
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange source_prefix_ranges = 6;</code>
   */
  int getSourcePrefixRangesCount();
  /**
   * <pre>
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange source_prefix_ranges = 6;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> 
      getSourcePrefixRangesOrBuilderList();
  /**
   * <pre>
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.CidrRange source_prefix_ranges = 6;</code>
   */
  io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder getSourcePrefixRangesOrBuilder(
      int index);

  /**
   * <pre>
   * The criteria is satisfied if the source port of the downstream connection
   * is contained in at least one of the specified ports. If the parameter is
   * not specified, the source port is ignored.
   * </pre>
   *
   * <code>repeated uint32 source_ports = 7 [(.validate.rules) = { ... }</code>
   * @return A list containing the sourcePorts.
   */
  java.util.List<java.lang.Integer> getSourcePortsList();
  /**
   * <pre>
   * The criteria is satisfied if the source port of the downstream connection
   * is contained in at least one of the specified ports. If the parameter is
   * not specified, the source port is ignored.
   * </pre>
   *
   * <code>repeated uint32 source_ports = 7 [(.validate.rules) = { ... }</code>
   * @return The count of sourcePorts.
   */
  int getSourcePortsCount();
  /**
   * <pre>
   * The criteria is satisfied if the source port of the downstream connection
   * is contained in at least one of the specified ports. If the parameter is
   * not specified, the source port is ignored.
   * </pre>
   *
   * <code>repeated uint32 source_ports = 7 [(.validate.rules) = { ... }</code>
   * @param index The index of the element to return.
   * @return The sourcePorts at the given index.
   */
  int getSourcePorts(int index);

  /**
   * <pre>
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   * .. attention::
   *   See the :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;` on how to configure SNI for more
   *   information.
   * </pre>
   *
   * <code>repeated string server_names = 11;</code>
   * @return A list containing the serverNames.
   */
  java.util.List<java.lang.String>
      getServerNamesList();
  /**
   * <pre>
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   * .. attention::
   *   See the :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;` on how to configure SNI for more
   *   information.
   * </pre>
   *
   * <code>repeated string server_names = 11;</code>
   * @return The count of serverNames.
   */
  int getServerNamesCount();
  /**
   * <pre>
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   * .. attention::
   *   See the :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;` on how to configure SNI for more
   *   information.
   * </pre>
   *
   * <code>repeated string server_names = 11;</code>
   * @param index The index of the element to return.
   * @return The serverNames at the given index.
   */
  java.lang.String getServerNames(int index);
  /**
   * <pre>
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   * .. attention::
   *   See the :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;` on how to configure SNI for more
   *   information.
   * </pre>
   *
   * <code>repeated string server_names = 11;</code>
   * @param index The index of the value to return.
   * @return The bytes of the serverNames at the given index.
   */
  com.google.protobuf.ByteString
      getServerNamesBytes(int index);

  /**
   * <pre>
   * If non-empty, a transport protocol to consider when determining a filter chain match.
   * This value will be compared against the transport protocol of a new connection, when
   * it's detected by one of the listener filters.
   * Suggested values include:
   * * ``raw_buffer`` - default, used when no transport protocol is detected,
   * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector &lt;config_listener_filters_tls_inspector&gt;`
   *   when TLS protocol is detected.
   * </pre>
   *
   * <code>string transport_protocol = 9;</code>
   * @return The transportProtocol.
   */
  java.lang.String getTransportProtocol();
  /**
   * <pre>
   * If non-empty, a transport protocol to consider when determining a filter chain match.
   * This value will be compared against the transport protocol of a new connection, when
   * it's detected by one of the listener filters.
   * Suggested values include:
   * * ``raw_buffer`` - default, used when no transport protocol is detected,
   * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector &lt;config_listener_filters_tls_inspector&gt;`
   *   when TLS protocol is detected.
   * </pre>
   *
   * <code>string transport_protocol = 9;</code>
   * @return The bytes for transportProtocol.
   */
  com.google.protobuf.ByteString
      getTransportProtocolBytes();

  /**
   * <pre>
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   * Suggested values include:
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   &lt;config_listener_filters_tls_inspector&gt;`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector &lt;config_listener_filters_tls_inspector&gt;`
   * .. attention::
   *   Currently, only :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;` provides
   *   application protocol detection based on the requested
   *   `ALPN &lt;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&gt;`_ values.
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   * </pre>
   *
   * <code>repeated string application_protocols = 10;</code>
   * @return A list containing the applicationProtocols.
   */
  java.util.List<java.lang.String>
      getApplicationProtocolsList();
  /**
   * <pre>
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   * Suggested values include:
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   &lt;config_listener_filters_tls_inspector&gt;`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector &lt;config_listener_filters_tls_inspector&gt;`
   * .. attention::
   *   Currently, only :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;` provides
   *   application protocol detection based on the requested
   *   `ALPN &lt;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&gt;`_ values.
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   * </pre>
   *
   * <code>repeated string application_protocols = 10;</code>
   * @return The count of applicationProtocols.
   */
  int getApplicationProtocolsCount();
  /**
   * <pre>
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   * Suggested values include:
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   &lt;config_listener_filters_tls_inspector&gt;`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector &lt;config_listener_filters_tls_inspector&gt;`
   * .. attention::
   *   Currently, only :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;` provides
   *   application protocol detection based on the requested
   *   `ALPN &lt;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&gt;`_ values.
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   * </pre>
   *
   * <code>repeated string application_protocols = 10;</code>
   * @param index The index of the element to return.
   * @return The applicationProtocols at the given index.
   */
  java.lang.String getApplicationProtocols(int index);
  /**
   * <pre>
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   * Suggested values include:
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   &lt;config_listener_filters_tls_inspector&gt;`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector &lt;config_listener_filters_tls_inspector&gt;`
   * .. attention::
   *   Currently, only :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;` provides
   *   application protocol detection based on the requested
   *   `ALPN &lt;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&gt;`_ values.
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   * </pre>
   *
   * <code>repeated string application_protocols = 10;</code>
   * @param index The index of the value to return.
   * @return The bytes of the applicationProtocols at the given index.
   */
  com.google.protobuf.ByteString
      getApplicationProtocolsBytes(int index);
}
