// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/cluster/v3/cluster.proto

package io.envoyproxy.envoy.config.cluster.v3;

/**
 * <pre>
 * Configuration for a single upstream cluster.
 * [#next-free-field: 53]
 * </pre>
 *
 * Protobuf type {@code envoy.config.cluster.v3.Cluster}
 */
public final class Cluster extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster)
    ClusterOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Cluster.newBuilder() to construct.
  private Cluster(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Cluster() {
    transportSocketMatches_ = java.util.Collections.emptyList();
    name_ = "";
    altStatName_ = "";
    lbPolicy_ = 0;
    healthChecks_ = java.util.Collections.emptyList();
    dnsLookupFamily_ = 0;
    dnsResolvers_ = java.util.Collections.emptyList();
    protocolSelection_ = 0;
    filters_ = java.util.Collections.emptyList();
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new Cluster();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private Cluster(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            java.lang.String s = input.readStringRequireUtf8();

            name_ = s;
            break;
          }
          case 16: {
            int rawValue = input.readEnum();
            clusterDiscoveryTypeCase_ = 2;
            clusterDiscoveryType_ = rawValue;
            break;
          }
          case 26: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder subBuilder = null;
            if (edsClusterConfig_ != null) {
              subBuilder = edsClusterConfig_.toBuilder();
            }
            edsClusterConfig_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(edsClusterConfig_);
              edsClusterConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 34: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (connectTimeout_ != null) {
              subBuilder = connectTimeout_.toBuilder();
            }
            connectTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(connectTimeout_);
              connectTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 42: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (perConnectionBufferLimitBytes_ != null) {
              subBuilder = perConnectionBufferLimitBytes_.toBuilder();
            }
            perConnectionBufferLimitBytes_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(perConnectionBufferLimitBytes_);
              perConnectionBufferLimitBytes_ = subBuilder.buildPartial();
            }

            break;
          }
          case 48: {
            int rawValue = input.readEnum();

            lbPolicy_ = rawValue;
            break;
          }
          case 66: {
            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
              healthChecks_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.HealthCheck>();
              mutable_bitField0_ |= 0x00000002;
            }
            healthChecks_.add(
                input.readMessage(io.envoyproxy.envoy.config.core.v3.HealthCheck.parser(), extensionRegistry));
            break;
          }
          case 74: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (maxRequestsPerConnection_ != null) {
              subBuilder = maxRequestsPerConnection_.toBuilder();
            }
            maxRequestsPerConnection_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(maxRequestsPerConnection_);
              maxRequestsPerConnection_ = subBuilder.buildPartial();
            }

            break;
          }
          case 82: {
            io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.Builder subBuilder = null;
            if (circuitBreakers_ != null) {
              subBuilder = circuitBreakers_.toBuilder();
            }
            circuitBreakers_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(circuitBreakers_);
              circuitBreakers_ = subBuilder.buildPartial();
            }

            break;
          }
          case 106: {
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder subBuilder = null;
            if (httpProtocolOptions_ != null) {
              subBuilder = httpProtocolOptions_.toBuilder();
            }
            httpProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(httpProtocolOptions_);
              httpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 114: {
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder subBuilder = null;
            if (http2ProtocolOptions_ != null) {
              subBuilder = http2ProtocolOptions_.toBuilder();
            }
            http2ProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(http2ProtocolOptions_);
              http2ProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 130: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (dnsRefreshRate_ != null) {
              subBuilder = dnsRefreshRate_.toBuilder();
            }
            dnsRefreshRate_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(dnsRefreshRate_);
              dnsRefreshRate_ = subBuilder.buildPartial();
            }

            break;
          }
          case 136: {
            int rawValue = input.readEnum();

            dnsLookupFamily_ = rawValue;
            break;
          }
          case 146: {
            if (!((mutable_bitField0_ & 0x00000008) != 0)) {
              dnsResolvers_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.Address>();
              mutable_bitField0_ |= 0x00000008;
            }
            dnsResolvers_.add(
                input.readMessage(io.envoyproxy.envoy.config.core.v3.Address.parser(), extensionRegistry));
            break;
          }
          case 154: {
            io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.Builder subBuilder = null;
            if (outlierDetection_ != null) {
              subBuilder = outlierDetection_.toBuilder();
            }
            outlierDetection_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(outlierDetection_);
              outlierDetection_ = subBuilder.buildPartial();
            }

            break;
          }
          case 162: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (cleanupInterval_ != null) {
              subBuilder = cleanupInterval_.toBuilder();
            }
            cleanupInterval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(cleanupInterval_);
              cleanupInterval_ = subBuilder.buildPartial();
            }

            break;
          }
          case 170: {
            io.envoyproxy.envoy.config.core.v3.BindConfig.Builder subBuilder = null;
            if (upstreamBindConfig_ != null) {
              subBuilder = upstreamBindConfig_.toBuilder();
            }
            upstreamBindConfig_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.BindConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(upstreamBindConfig_);
              upstreamBindConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 178: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder subBuilder = null;
            if (lbSubsetConfig_ != null) {
              subBuilder = lbSubsetConfig_.toBuilder();
            }
            lbSubsetConfig_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(lbSubsetConfig_);
              lbSubsetConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 186: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 23) {
              subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 23;
            break;
          }
          case 194: {
            io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder subBuilder = null;
            if (transportSocket_ != null) {
              subBuilder = transportSocket_.toBuilder();
            }
            transportSocket_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.TransportSocket.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(transportSocket_);
              transportSocket_ = subBuilder.buildPartial();
            }

            break;
          }
          case 202: {
            io.envoyproxy.envoy.config.core.v3.Metadata.Builder subBuilder = null;
            if (metadata_ != null) {
              subBuilder = metadata_.toBuilder();
            }
            metadata_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.Metadata.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(metadata_);
              metadata_ = subBuilder.buildPartial();
            }

            break;
          }
          case 208: {
            int rawValue = input.readEnum();

            protocolSelection_ = rawValue;
            break;
          }
          case 218: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder subBuilder = null;
            if (commonLbConfig_ != null) {
              subBuilder = commonLbConfig_.toBuilder();
            }
            commonLbConfig_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(commonLbConfig_);
              commonLbConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 226: {
            java.lang.String s = input.readStringRequireUtf8();

            altStatName_ = s;
            break;
          }
          case 234: {
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder subBuilder = null;
            if (commonHttpProtocolOptions_ != null) {
              subBuilder = commonHttpProtocolOptions_.toBuilder();
            }
            commonHttpProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(commonHttpProtocolOptions_);
              commonHttpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 242: {
            io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.Builder subBuilder = null;
            if (upstreamConnectionOptions_ != null) {
              subBuilder = upstreamConnectionOptions_.toBuilder();
            }
            upstreamConnectionOptions_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(upstreamConnectionOptions_);
              upstreamConnectionOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 248: {

            closeConnectionsOnHostHealthFailure_ = input.readBool();
            break;
          }
          case 256: {

            ignoreHealthOnHostRemoval_ = input.readBool();
            break;
          }
          case 266: {
            io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Builder subBuilder = null;
            if (loadAssignment_ != null) {
              subBuilder = loadAssignment_.toBuilder();
            }
            loadAssignment_ = input.readMessage(io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(loadAssignment_);
              loadAssignment_ = subBuilder.buildPartial();
            }

            break;
          }
          case 274: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 34) {
              subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 34;
            break;
          }
          case 290: {
            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
              typedExtensionProtocolOptions_ = com.google.protobuf.MapField.newMapField(
                  TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
              mutable_bitField0_ |= 0x00000004;
            }
            com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.Any>
            typedExtensionProtocolOptions__ = input.readMessage(
                TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
            typedExtensionProtocolOptions_.getMutableMap().put(
                typedExtensionProtocolOptions__.getKey(), typedExtensionProtocolOptions__.getValue());
            break;
          }
          case 298: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 37) {
              subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 37;
            break;
          }
          case 306: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder subBuilder = null;
            if (clusterDiscoveryTypeCase_ == 38) {
              subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_).toBuilder();
            }
            clusterDiscoveryType_ =
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_);
              clusterDiscoveryType_ = subBuilder.buildPartial();
            }
            clusterDiscoveryTypeCase_ = 38;
            break;
          }
          case 312: {

            respectDnsTtl_ = input.readBool();
            break;
          }
          case 322: {
            if (!((mutable_bitField0_ & 0x00000010) != 0)) {
              filters_ = new java.util.ArrayList<io.envoyproxy.envoy.config.cluster.v3.Filter>();
              mutable_bitField0_ |= 0x00000010;
            }
            filters_.add(
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Filter.parser(), extensionRegistry));
            break;
          }
          case 330: {
            io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.Builder subBuilder = null;
            if (loadBalancingPolicy_ != null) {
              subBuilder = loadBalancingPolicy_.toBuilder();
            }
            loadBalancingPolicy_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(loadBalancingPolicy_);
              loadBalancingPolicy_ = subBuilder.buildPartial();
            }

            break;
          }
          case 338: {
            io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder subBuilder = null;
            if (lrsServer_ != null) {
              subBuilder = lrsServer_.toBuilder();
            }
            lrsServer_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.ConfigSource.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(lrsServer_);
              lrsServer_ = subBuilder.buildPartial();
            }

            break;
          }
          case 346: {
            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
              transportSocketMatches_ = new java.util.ArrayList<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch>();
              mutable_bitField0_ |= 0x00000001;
            }
            transportSocketMatches_.add(
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.parser(), extensionRegistry));
            break;
          }
          case 354: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder subBuilder = null;
            if (dnsFailureRefreshRate_ != null) {
              subBuilder = dnsFailureRefreshRate_.toBuilder();
            }
            dnsFailureRefreshRate_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(dnsFailureRefreshRate_);
              dnsFailureRefreshRate_ = subBuilder.buildPartial();
            }

            break;
          }
          case 360: {

            useTcpForDnsLookups_ = input.readBool();
            break;
          }
          case 370: {
            io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.Builder subBuilder = null;
            if (upstreamHttpProtocolOptions_ != null) {
              subBuilder = upstreamHttpProtocolOptions_.toBuilder();
            }
            upstreamHttpProtocolOptions_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(upstreamHttpProtocolOptions_);
              upstreamHttpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 376: {

            trackTimeoutBudgets_ = input.readBool();
            break;
          }
          case 386: {
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder subBuilder = null;
            if (upstreamConfig_ != null) {
              subBuilder = upstreamConfig_.toBuilder();
            }
            upstreamConfig_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(upstreamConfig_);
              upstreamConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 394: {
            io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.Builder subBuilder = null;
            if (trackClusterStats_ != null) {
              subBuilder = trackClusterStats_.toBuilder();
            }
            trackClusterStats_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(trackClusterStats_);
              trackClusterStats_ = subBuilder.buildPartial();
            }

            break;
          }
          case 402: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder subBuilder = null;
            if (preconnectPolicy_ != null) {
              subBuilder = preconnectPolicy_.toBuilder();
            }
            preconnectPolicy_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(preconnectPolicy_);
              preconnectPolicy_ = subBuilder.buildPartial();
            }

            break;
          }
          case 408: {

            connectionPoolPerDownstreamConnection_ = input.readBool();
            break;
          }
          case 418: {
            io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 52) {
              subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 52;
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000002) != 0)) {
        healthChecks_ = java.util.Collections.unmodifiableList(healthChecks_);
      }
      if (((mutable_bitField0_ & 0x00000008) != 0)) {
        dnsResolvers_ = java.util.Collections.unmodifiableList(dnsResolvers_);
      }
      if (((mutable_bitField0_ & 0x00000010) != 0)) {
        filters_ = java.util.Collections.unmodifiableList(filters_);
      }
      if (((mutable_bitField0_ & 0x00000001) != 0)) {
        transportSocketMatches_ = java.util.Collections.unmodifiableList(transportSocketMatches_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  @java.lang.Override
  protected com.google.protobuf.MapField internalGetMapField(
      int number) {
    switch (number) {
      case 36:
        return internalGetTypedExtensionProtocolOptions();
      default:
        throw new RuntimeException(
            "Invalid map field number: " + number);
    }
  }
  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.envoyproxy.envoy.config.cluster.v3.Cluster.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.Builder.class);
  }

  /**
   * <pre>
   * Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * for an explanation on each type.
   * </pre>
   *
   * Protobuf enum {@code envoy.config.cluster.v3.Cluster.DiscoveryType}
   */
  public enum DiscoveryType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STATIC = 0;</code>
     */
    STATIC(0),
    /**
     * <pre>
     * Refer to the :ref:`strict DNS discovery
     * type&lt;arch_overview_service_discovery_types_strict_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STRICT_DNS = 1;</code>
     */
    STRICT_DNS(1),
    /**
     * <pre>
     * Refer to the :ref:`logical DNS discovery
     * type&lt;arch_overview_service_discovery_types_logical_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LOGICAL_DNS = 2;</code>
     */
    LOGICAL_DNS(2),
    /**
     * <pre>
     * Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>EDS = 3;</code>
     */
    EDS(3),
    /**
     * <pre>
     * Refer to the :ref:`original destination discovery
     * type&lt;arch_overview_service_discovery_types_original_destination&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ORIGINAL_DST = 4;</code>
     */
    ORIGINAL_DST(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STATIC = 0;</code>
     */
    public static final int STATIC_VALUE = 0;
    /**
     * <pre>
     * Refer to the :ref:`strict DNS discovery
     * type&lt;arch_overview_service_discovery_types_strict_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STRICT_DNS = 1;</code>
     */
    public static final int STRICT_DNS_VALUE = 1;
    /**
     * <pre>
     * Refer to the :ref:`logical DNS discovery
     * type&lt;arch_overview_service_discovery_types_logical_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LOGICAL_DNS = 2;</code>
     */
    public static final int LOGICAL_DNS_VALUE = 2;
    /**
     * <pre>
     * Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>EDS = 3;</code>
     */
    public static final int EDS_VALUE = 3;
    /**
     * <pre>
     * Refer to the :ref:`original destination discovery
     * type&lt;arch_overview_service_discovery_types_original_destination&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ORIGINAL_DST = 4;</code>
     */
    public static final int ORIGINAL_DST_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DiscoveryType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static DiscoveryType forNumber(int value) {
      switch (value) {
        case 0: return STATIC;
        case 1: return STRICT_DNS;
        case 2: return LOGICAL_DNS;
        case 3: return EDS;
        case 4: return ORIGINAL_DST;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DiscoveryType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DiscoveryType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DiscoveryType>() {
            public DiscoveryType findValueByNumber(int number) {
              return DiscoveryType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.getDescriptor().getEnumTypes().get(0);
    }

    private static final DiscoveryType[] VALUES = values();

    public static DiscoveryType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DiscoveryType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.DiscoveryType)
  }

  /**
   * <pre>
   * Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` architecture
   * overview section for information on each type.
   * </pre>
   *
   * Protobuf enum {@code envoy.config.cluster.v3.Cluster.LbPolicy}
   */
  public enum LbPolicy
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Refer to the :ref:`round robin load balancing
     * policy&lt;arch_overview_load_balancing_types_round_robin&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ROUND_ROBIN = 0;</code>
     */
    ROUND_ROBIN(0),
    /**
     * <pre>
     * Refer to the :ref:`least request load balancing
     * policy&lt;arch_overview_load_balancing_types_least_request&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LEAST_REQUEST = 1;</code>
     */
    LEAST_REQUEST(1),
    /**
     * <pre>
     * Refer to the :ref:`ring hash load balancing
     * policy&lt;arch_overview_load_balancing_types_ring_hash&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RING_HASH = 2;</code>
     */
    RING_HASH(2),
    /**
     * <pre>
     * Refer to the :ref:`random load balancing
     * policy&lt;arch_overview_load_balancing_types_random&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RANDOM = 3;</code>
     */
    RANDOM(3),
    /**
     * <pre>
     * Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>MAGLEV = 5;</code>
     */
    MAGLEV(5),
    /**
     * <pre>
     * This load balancer type must be specified if the configured cluster provides a cluster
     * specific load balancer. Consult the configured cluster's documentation for whether to set
     * this option or not.
     * </pre>
     *
     * <code>CLUSTER_PROVIDED = 6;</code>
     */
    CLUSTER_PROVIDED(6),
    /**
     * <pre>
     * [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
     * &lt;envoy_api_field_config.cluster.v3.Cluster.load_balancing_policy&gt;` field to determine the LB policy.
     * [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
     * and instead using the new load_balancing_policy field as the one and only mechanism for
     * configuring this.]
     * </pre>
     *
     * <code>LOAD_BALANCING_POLICY_CONFIG = 7;</code>
     */
    LOAD_BALANCING_POLICY_CONFIG(7),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Refer to the :ref:`round robin load balancing
     * policy&lt;arch_overview_load_balancing_types_round_robin&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ROUND_ROBIN = 0;</code>
     */
    public static final int ROUND_ROBIN_VALUE = 0;
    /**
     * <pre>
     * Refer to the :ref:`least request load balancing
     * policy&lt;arch_overview_load_balancing_types_least_request&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LEAST_REQUEST = 1;</code>
     */
    public static final int LEAST_REQUEST_VALUE = 1;
    /**
     * <pre>
     * Refer to the :ref:`ring hash load balancing
     * policy&lt;arch_overview_load_balancing_types_ring_hash&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RING_HASH = 2;</code>
     */
    public static final int RING_HASH_VALUE = 2;
    /**
     * <pre>
     * Refer to the :ref:`random load balancing
     * policy&lt;arch_overview_load_balancing_types_random&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RANDOM = 3;</code>
     */
    public static final int RANDOM_VALUE = 3;
    /**
     * <pre>
     * Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>MAGLEV = 5;</code>
     */
    public static final int MAGLEV_VALUE = 5;
    /**
     * <pre>
     * This load balancer type must be specified if the configured cluster provides a cluster
     * specific load balancer. Consult the configured cluster's documentation for whether to set
     * this option or not.
     * </pre>
     *
     * <code>CLUSTER_PROVIDED = 6;</code>
     */
    public static final int CLUSTER_PROVIDED_VALUE = 6;
    /**
     * <pre>
     * [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
     * &lt;envoy_api_field_config.cluster.v3.Cluster.load_balancing_policy&gt;` field to determine the LB policy.
     * [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
     * and instead using the new load_balancing_policy field as the one and only mechanism for
     * configuring this.]
     * </pre>
     *
     * <code>LOAD_BALANCING_POLICY_CONFIG = 7;</code>
     */
    public static final int LOAD_BALANCING_POLICY_CONFIG_VALUE = 7;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LbPolicy valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LbPolicy forNumber(int value) {
      switch (value) {
        case 0: return ROUND_ROBIN;
        case 1: return LEAST_REQUEST;
        case 2: return RING_HASH;
        case 3: return RANDOM;
        case 5: return MAGLEV;
        case 6: return CLUSTER_PROVIDED;
        case 7: return LOAD_BALANCING_POLICY_CONFIG;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LbPolicy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LbPolicy> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LbPolicy>() {
            public LbPolicy findValueByNumber(int number) {
              return LbPolicy.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.getDescriptor().getEnumTypes().get(1);
    }

    private static final LbPolicy[] VALUES = values();

    public static LbPolicy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LbPolicy(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.LbPolicy)
  }

  /**
   * <pre>
   * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
   * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
   * only perform a lookup for addresses in the IPv6 family. If AUTO is
   * specified, the DNS resolver will first perform a lookup for addresses in
   * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
   * For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this setting is
   * ignored.
   * </pre>
   *
   * Protobuf enum {@code envoy.config.cluster.v3.Cluster.DnsLookupFamily}
   */
  public enum DnsLookupFamily
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>AUTO = 0;</code>
     */
    AUTO(0),
    /**
     * <code>V4_ONLY = 1;</code>
     */
    V4_ONLY(1),
    /**
     * <code>V6_ONLY = 2;</code>
     */
    V6_ONLY(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>AUTO = 0;</code>
     */
    public static final int AUTO_VALUE = 0;
    /**
     * <code>V4_ONLY = 1;</code>
     */
    public static final int V4_ONLY_VALUE = 1;
    /**
     * <code>V6_ONLY = 2;</code>
     */
    public static final int V6_ONLY_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DnsLookupFamily valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static DnsLookupFamily forNumber(int value) {
      switch (value) {
        case 0: return AUTO;
        case 1: return V4_ONLY;
        case 2: return V6_ONLY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DnsLookupFamily>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DnsLookupFamily> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DnsLookupFamily>() {
            public DnsLookupFamily findValueByNumber(int number) {
              return DnsLookupFamily.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.getDescriptor().getEnumTypes().get(2);
    }

    private static final DnsLookupFamily[] VALUES = values();

    public static DnsLookupFamily valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DnsLookupFamily(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.DnsLookupFamily)
  }

  /**
   * Protobuf enum {@code envoy.config.cluster.v3.Cluster.ClusterProtocolSelection}
   */
  public enum ClusterProtocolSelection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options &lt;envoy_api_field_config.cluster.v3.Cluster.http2_protocol_options&gt;` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     * </pre>
     *
     * <code>USE_CONFIGURED_PROTOCOL = 0;</code>
     */
    USE_CONFIGURED_PROTOCOL(0),
    /**
     * <pre>
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     * </pre>
     *
     * <code>USE_DOWNSTREAM_PROTOCOL = 1;</code>
     */
    USE_DOWNSTREAM_PROTOCOL(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options &lt;envoy_api_field_config.cluster.v3.Cluster.http2_protocol_options&gt;` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     * </pre>
     *
     * <code>USE_CONFIGURED_PROTOCOL = 0;</code>
     */
    public static final int USE_CONFIGURED_PROTOCOL_VALUE = 0;
    /**
     * <pre>
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     * </pre>
     *
     * <code>USE_DOWNSTREAM_PROTOCOL = 1;</code>
     */
    public static final int USE_DOWNSTREAM_PROTOCOL_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ClusterProtocolSelection valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ClusterProtocolSelection forNumber(int value) {
      switch (value) {
        case 0: return USE_CONFIGURED_PROTOCOL;
        case 1: return USE_DOWNSTREAM_PROTOCOL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ClusterProtocolSelection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ClusterProtocolSelection> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ClusterProtocolSelection>() {
            public ClusterProtocolSelection findValueByNumber(int number) {
              return ClusterProtocolSelection.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.getDescriptor().getEnumTypes().get(3);
    }

    private static final ClusterProtocolSelection[] VALUES = values();

    public static ClusterProtocolSelection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ClusterProtocolSelection(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.ClusterProtocolSelection)
  }

  public interface TransportSocketMatchOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.TransportSocketMatch)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the match, used in stats generation.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the match, used in stats generation.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
     * against the values specified in this field.
     * </pre>
     *
     * <code>.google.protobuf.Struct match = 2;</code>
     * @return Whether the match field is set.
     */
    boolean hasMatch();
    /**
     * <pre>
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
     * against the values specified in this field.
     * </pre>
     *
     * <code>.google.protobuf.Struct match = 2;</code>
     * @return The match.
     */
    com.google.protobuf.Struct getMatch();
    /**
     * <pre>
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
     * against the values specified in this field.
     * </pre>
     *
     * <code>.google.protobuf.Struct match = 2;</code>
     */
    com.google.protobuf.StructOrBuilder getMatchOrBuilder();

    /**
     * <pre>
     * The configuration of the transport socket.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
     * @return Whether the transportSocket field is set.
     */
    boolean hasTransportSocket();
    /**
     * <pre>
     * The configuration of the transport socket.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
     * @return The transportSocket.
     */
    io.envoyproxy.envoy.config.core.v3.TransportSocket getTransportSocket();
    /**
     * <pre>
     * The configuration of the transport socket.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
     */
    io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder getTransportSocketOrBuilder();
  }
  /**
   * <pre>
   * TransportSocketMatch specifies what transport socket config will be used
   * when the match conditions are satisfied.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.TransportSocketMatch}
   */
  public static final class TransportSocketMatch extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.TransportSocketMatch)
      TransportSocketMatchOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TransportSocketMatch.newBuilder() to construct.
    private TransportSocketMatch(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TransportSocketMatch() {
      name_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TransportSocketMatch();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TransportSocketMatch(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              com.google.protobuf.Struct.Builder subBuilder = null;
              if (match_ != null) {
                subBuilder = match_.toBuilder();
              }
              match_ = input.readMessage(com.google.protobuf.Struct.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(match_);
                match_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder subBuilder = null;
              if (transportSocket_ != null) {
                subBuilder = transportSocket_.toBuilder();
              }
              transportSocket_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.TransportSocket.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(transportSocket_);
                transportSocket_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_TransportSocketMatch_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_TransportSocketMatch_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the match, used in stats generation.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name of the match, used in stats generation.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCH_FIELD_NUMBER = 2;
    private com.google.protobuf.Struct match_;
    /**
     * <pre>
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
     * against the values specified in this field.
     * </pre>
     *
     * <code>.google.protobuf.Struct match = 2;</code>
     * @return Whether the match field is set.
     */
    @java.lang.Override
    public boolean hasMatch() {
      return match_ != null;
    }
    /**
     * <pre>
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
     * against the values specified in this field.
     * </pre>
     *
     * <code>.google.protobuf.Struct match = 2;</code>
     * @return The match.
     */
    @java.lang.Override
    public com.google.protobuf.Struct getMatch() {
      return match_ == null ? com.google.protobuf.Struct.getDefaultInstance() : match_;
    }
    /**
     * <pre>
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
     * against the values specified in this field.
     * </pre>
     *
     * <code>.google.protobuf.Struct match = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.StructOrBuilder getMatchOrBuilder() {
      return getMatch();
    }

    public static final int TRANSPORT_SOCKET_FIELD_NUMBER = 3;
    private io.envoyproxy.envoy.config.core.v3.TransportSocket transportSocket_;
    /**
     * <pre>
     * The configuration of the transport socket.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
     * @return Whether the transportSocket field is set.
     */
    @java.lang.Override
    public boolean hasTransportSocket() {
      return transportSocket_ != null;
    }
    /**
     * <pre>
     * The configuration of the transport socket.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
     * @return The transportSocket.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.TransportSocket getTransportSocket() {
      return transportSocket_ == null ? io.envoyproxy.envoy.config.core.v3.TransportSocket.getDefaultInstance() : transportSocket_;
    }
    /**
     * <pre>
     * The configuration of the transport socket.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder getTransportSocketOrBuilder() {
      return getTransportSocket();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (match_ != null) {
        output.writeMessage(2, getMatch());
      }
      if (transportSocket_ != null) {
        output.writeMessage(3, getTransportSocket());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (match_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMatch());
      }
      if (transportSocket_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTransportSocket());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (hasMatch() != other.hasMatch()) return false;
      if (hasMatch()) {
        if (!getMatch()
            .equals(other.getMatch())) return false;
      }
      if (hasTransportSocket() != other.hasTransportSocket()) return false;
      if (hasTransportSocket()) {
        if (!getTransportSocket()
            .equals(other.getTransportSocket())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasMatch()) {
        hash = (37 * hash) + MATCH_FIELD_NUMBER;
        hash = (53 * hash) + getMatch().hashCode();
      }
      if (hasTransportSocket()) {
        hash = (37 * hash) + TRANSPORT_SOCKET_FIELD_NUMBER;
        hash = (53 * hash) + getTransportSocket().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TransportSocketMatch specifies what transport socket config will be used
     * when the match conditions are satisfied.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.TransportSocketMatch}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.TransportSocketMatch)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_TransportSocketMatch_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_TransportSocketMatch_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        if (matchBuilder_ == null) {
          match_ = null;
        } else {
          match_ = null;
          matchBuilder_ = null;
        }
        if (transportSocketBuilder_ == null) {
          transportSocket_ = null;
        } else {
          transportSocket_ = null;
          transportSocketBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_TransportSocketMatch_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch(this);
        result.name_ = name_;
        if (matchBuilder_ == null) {
          result.match_ = match_;
        } else {
          result.match_ = matchBuilder_.build();
        }
        if (transportSocketBuilder_ == null) {
          result.transportSocket_ = transportSocket_;
        } else {
          result.transportSocket_ = transportSocketBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.hasMatch()) {
          mergeMatch(other.getMatch());
        }
        if (other.hasTransportSocket()) {
          mergeTransportSocket(other.getTransportSocket());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the match, used in stats generation.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the match, used in stats generation.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the match, used in stats generation.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the match, used in stats generation.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the match, used in stats generation.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.Struct match_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> matchBuilder_;
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       * @return Whether the match field is set.
       */
      public boolean hasMatch() {
        return matchBuilder_ != null || match_ != null;
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       * @return The match.
       */
      public com.google.protobuf.Struct getMatch() {
        if (matchBuilder_ == null) {
          return match_ == null ? com.google.protobuf.Struct.getDefaultInstance() : match_;
        } else {
          return matchBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      public Builder setMatch(com.google.protobuf.Struct value) {
        if (matchBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          match_ = value;
          onChanged();
        } else {
          matchBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      public Builder setMatch(
          com.google.protobuf.Struct.Builder builderForValue) {
        if (matchBuilder_ == null) {
          match_ = builderForValue.build();
          onChanged();
        } else {
          matchBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      public Builder mergeMatch(com.google.protobuf.Struct value) {
        if (matchBuilder_ == null) {
          if (match_ != null) {
            match_ =
              com.google.protobuf.Struct.newBuilder(match_).mergeFrom(value).buildPartial();
          } else {
            match_ = value;
          }
          onChanged();
        } else {
          matchBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      public Builder clearMatch() {
        if (matchBuilder_ == null) {
          match_ = null;
          onChanged();
        } else {
          match_ = null;
          matchBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      public com.google.protobuf.Struct.Builder getMatchBuilder() {
        
        onChanged();
        return getMatchFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      public com.google.protobuf.StructOrBuilder getMatchOrBuilder() {
        if (matchBuilder_ != null) {
          return matchBuilder_.getMessageOrBuilder();
        } else {
          return match_ == null ?
              com.google.protobuf.Struct.getDefaultInstance() : match_;
        }
      }
      /**
       * <pre>
       * Optional endpoint metadata match criteria.
       * The connection to the endpoint with metadata matching what is set in this field
       * will use the transport socket configuration specified here.
       * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
       * against the values specified in this field.
       * </pre>
       *
       * <code>.google.protobuf.Struct match = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> 
          getMatchFieldBuilder() {
        if (matchBuilder_ == null) {
          matchBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder>(
                  getMatch(),
                  getParentForChildren(),
                  isClean());
          match_ = null;
        }
        return matchBuilder_;
      }

      private io.envoyproxy.envoy.config.core.v3.TransportSocket transportSocket_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.TransportSocket, io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder, io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder> transportSocketBuilder_;
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       * @return Whether the transportSocket field is set.
       */
      public boolean hasTransportSocket() {
        return transportSocketBuilder_ != null || transportSocket_ != null;
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       * @return The transportSocket.
       */
      public io.envoyproxy.envoy.config.core.v3.TransportSocket getTransportSocket() {
        if (transportSocketBuilder_ == null) {
          return transportSocket_ == null ? io.envoyproxy.envoy.config.core.v3.TransportSocket.getDefaultInstance() : transportSocket_;
        } else {
          return transportSocketBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      public Builder setTransportSocket(io.envoyproxy.envoy.config.core.v3.TransportSocket value) {
        if (transportSocketBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          transportSocket_ = value;
          onChanged();
        } else {
          transportSocketBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      public Builder setTransportSocket(
          io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder builderForValue) {
        if (transportSocketBuilder_ == null) {
          transportSocket_ = builderForValue.build();
          onChanged();
        } else {
          transportSocketBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      public Builder mergeTransportSocket(io.envoyproxy.envoy.config.core.v3.TransportSocket value) {
        if (transportSocketBuilder_ == null) {
          if (transportSocket_ != null) {
            transportSocket_ =
              io.envoyproxy.envoy.config.core.v3.TransportSocket.newBuilder(transportSocket_).mergeFrom(value).buildPartial();
          } else {
            transportSocket_ = value;
          }
          onChanged();
        } else {
          transportSocketBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      public Builder clearTransportSocket() {
        if (transportSocketBuilder_ == null) {
          transportSocket_ = null;
          onChanged();
        } else {
          transportSocket_ = null;
          transportSocketBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder getTransportSocketBuilder() {
        
        onChanged();
        return getTransportSocketFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder getTransportSocketOrBuilder() {
        if (transportSocketBuilder_ != null) {
          return transportSocketBuilder_.getMessageOrBuilder();
        } else {
          return transportSocket_ == null ?
              io.envoyproxy.envoy.config.core.v3.TransportSocket.getDefaultInstance() : transportSocket_;
        }
      }
      /**
       * <pre>
       * The configuration of the transport socket.
       * </pre>
       *
       * <code>.envoy.config.core.v3.TransportSocket transport_socket = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.TransportSocket, io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder, io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder> 
          getTransportSocketFieldBuilder() {
        if (transportSocketBuilder_ == null) {
          transportSocketBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.TransportSocket, io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder, io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder>(
                  getTransportSocket(),
                  getParentForChildren(),
                  isClean());
          transportSocket_ = null;
        }
        return transportSocketBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.TransportSocketMatch)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.TransportSocketMatch)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TransportSocketMatch>
        PARSER = new com.google.protobuf.AbstractParser<TransportSocketMatch>() {
      @java.lang.Override
      public TransportSocketMatch parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TransportSocketMatch(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TransportSocketMatch> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TransportSocketMatch> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CustomClusterTypeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.CustomClusterType)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type of the cluster to instantiate. The name must match a supported cluster type.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The type of the cluster to instantiate. The name must match a supported cluster type.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * </pre>
     *
     * <code>.google.protobuf.Any typed_config = 2;</code>
     * @return Whether the typedConfig field is set.
     */
    boolean hasTypedConfig();
    /**
     * <pre>
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * </pre>
     *
     * <code>.google.protobuf.Any typed_config = 2;</code>
     * @return The typedConfig.
     */
    com.google.protobuf.Any getTypedConfig();
    /**
     * <pre>
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * </pre>
     *
     * <code>.google.protobuf.Any typed_config = 2;</code>
     */
    com.google.protobuf.AnyOrBuilder getTypedConfigOrBuilder();
  }
  /**
   * <pre>
   * Extended cluster type.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.CustomClusterType}
   */
  public static final class CustomClusterType extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.CustomClusterType)
      CustomClusterTypeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CustomClusterType.newBuilder() to construct.
    private CustomClusterType(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CustomClusterType() {
      name_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CustomClusterType();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CustomClusterType(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              com.google.protobuf.Any.Builder subBuilder = null;
              if (typedConfig_ != null) {
                subBuilder = typedConfig_.toBuilder();
              }
              typedConfig_ = input.readMessage(com.google.protobuf.Any.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(typedConfig_);
                typedConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CustomClusterType_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CustomClusterType_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The type of the cluster to instantiate. The name must match a supported cluster type.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The type of the cluster to instantiate. The name must match a supported cluster type.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPED_CONFIG_FIELD_NUMBER = 2;
    private com.google.protobuf.Any typedConfig_;
    /**
     * <pre>
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * </pre>
     *
     * <code>.google.protobuf.Any typed_config = 2;</code>
     * @return Whether the typedConfig field is set.
     */
    @java.lang.Override
    public boolean hasTypedConfig() {
      return typedConfig_ != null;
    }
    /**
     * <pre>
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * </pre>
     *
     * <code>.google.protobuf.Any typed_config = 2;</code>
     * @return The typedConfig.
     */
    @java.lang.Override
    public com.google.protobuf.Any getTypedConfig() {
      return typedConfig_ == null ? com.google.protobuf.Any.getDefaultInstance() : typedConfig_;
    }
    /**
     * <pre>
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * </pre>
     *
     * <code>.google.protobuf.Any typed_config = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.AnyOrBuilder getTypedConfigOrBuilder() {
      return getTypedConfig();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (typedConfig_ != null) {
        output.writeMessage(2, getTypedConfig());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (typedConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getTypedConfig());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (hasTypedConfig() != other.hasTypedConfig()) return false;
      if (hasTypedConfig()) {
        if (!getTypedConfig()
            .equals(other.getTypedConfig())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasTypedConfig()) {
        hash = (37 * hash) + TYPED_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getTypedConfig().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Extended cluster type.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.CustomClusterType}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.CustomClusterType)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CustomClusterType_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CustomClusterType_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        if (typedConfigBuilder_ == null) {
          typedConfig_ = null;
        } else {
          typedConfig_ = null;
          typedConfigBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CustomClusterType_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType(this);
        result.name_ = name_;
        if (typedConfigBuilder_ == null) {
          result.typedConfig_ = typedConfig_;
        } else {
          result.typedConfig_ = typedConfigBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.hasTypedConfig()) {
          mergeTypedConfig(other.getTypedConfig());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The type of the cluster to instantiate. The name must match a supported cluster type.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The type of the cluster to instantiate. The name must match a supported cluster type.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The type of the cluster to instantiate. The name must match a supported cluster type.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type of the cluster to instantiate. The name must match a supported cluster type.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type of the cluster to instantiate. The name must match a supported cluster type.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.Any typedConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder> typedConfigBuilder_;
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       * @return Whether the typedConfig field is set.
       */
      public boolean hasTypedConfig() {
        return typedConfigBuilder_ != null || typedConfig_ != null;
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       * @return The typedConfig.
       */
      public com.google.protobuf.Any getTypedConfig() {
        if (typedConfigBuilder_ == null) {
          return typedConfig_ == null ? com.google.protobuf.Any.getDefaultInstance() : typedConfig_;
        } else {
          return typedConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      public Builder setTypedConfig(com.google.protobuf.Any value) {
        if (typedConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          typedConfig_ = value;
          onChanged();
        } else {
          typedConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      public Builder setTypedConfig(
          com.google.protobuf.Any.Builder builderForValue) {
        if (typedConfigBuilder_ == null) {
          typedConfig_ = builderForValue.build();
          onChanged();
        } else {
          typedConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      public Builder mergeTypedConfig(com.google.protobuf.Any value) {
        if (typedConfigBuilder_ == null) {
          if (typedConfig_ != null) {
            typedConfig_ =
              com.google.protobuf.Any.newBuilder(typedConfig_).mergeFrom(value).buildPartial();
          } else {
            typedConfig_ = value;
          }
          onChanged();
        } else {
          typedConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      public Builder clearTypedConfig() {
        if (typedConfigBuilder_ == null) {
          typedConfig_ = null;
          onChanged();
        } else {
          typedConfig_ = null;
          typedConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      public com.google.protobuf.Any.Builder getTypedConfigBuilder() {
        
        onChanged();
        return getTypedConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      public com.google.protobuf.AnyOrBuilder getTypedConfigOrBuilder() {
        if (typedConfigBuilder_ != null) {
          return typedConfigBuilder_.getMessageOrBuilder();
        } else {
          return typedConfig_ == null ?
              com.google.protobuf.Any.getDefaultInstance() : typedConfig_;
        }
      }
      /**
       * <pre>
       * Cluster specific configuration which depends on the cluster being instantiated.
       * See the supported cluster for further documentation.
       * </pre>
       *
       * <code>.google.protobuf.Any typed_config = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder> 
          getTypedConfigFieldBuilder() {
        if (typedConfigBuilder_ == null) {
          typedConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder>(
                  getTypedConfig(),
                  getParentForChildren(),
                  isClean());
          typedConfig_ = null;
        }
        return typedConfigBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.CustomClusterType)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.CustomClusterType)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CustomClusterType>
        PARSER = new com.google.protobuf.AbstractParser<CustomClusterType>() {
      @java.lang.Override
      public CustomClusterType parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CustomClusterType(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CustomClusterType> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CustomClusterType> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EdsClusterConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.EdsClusterConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
     * @return Whether the edsConfig field is set.
     */
    boolean hasEdsConfig();
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
     * @return The edsConfig.
     */
    io.envoyproxy.envoy.config.core.v3.ConfigSource getEdsConfig();
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
     */
    io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder getEdsConfigOrBuilder();

    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length. This may be a xdstp:// URL.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     * @return The serviceName.
     */
    java.lang.String getServiceName();
    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length. This may be a xdstp:// URL.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     * @return The bytes for serviceName.
     */
    com.google.protobuf.ByteString
        getServiceNameBytes();
  }
  /**
   * <pre>
   * Only valid when discovery type is EDS.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.EdsClusterConfig}
   */
  public static final class EdsClusterConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.EdsClusterConfig)
      EdsClusterConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use EdsClusterConfig.newBuilder() to construct.
    private EdsClusterConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private EdsClusterConfig() {
      serviceName_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new EdsClusterConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private EdsClusterConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder subBuilder = null;
              if (edsConfig_ != null) {
                subBuilder = edsConfig_.toBuilder();
              }
              edsConfig_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.ConfigSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(edsConfig_);
                edsConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              serviceName_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_EdsClusterConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_EdsClusterConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder.class);
    }

    public static final int EDS_CONFIG_FIELD_NUMBER = 1;
    private io.envoyproxy.envoy.config.core.v3.ConfigSource edsConfig_;
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
     * @return Whether the edsConfig field is set.
     */
    @java.lang.Override
    public boolean hasEdsConfig() {
      return edsConfig_ != null;
    }
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
     * @return The edsConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.ConfigSource getEdsConfig() {
      return edsConfig_ == null ? io.envoyproxy.envoy.config.core.v3.ConfigSource.getDefaultInstance() : edsConfig_;
    }
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder getEdsConfigOrBuilder() {
      return getEdsConfig();
    }

    public static final int SERVICE_NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object serviceName_;
    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length. This may be a xdstp:// URL.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     * @return The serviceName.
     */
    @java.lang.Override
    public java.lang.String getServiceName() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length. This may be a xdstp:// URL.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     * @return The bytes for serviceName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceNameBytes() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (edsConfig_ != null) {
        output.writeMessage(1, getEdsConfig());
      }
      if (!getServiceNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, serviceName_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (edsConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getEdsConfig());
      }
      if (!getServiceNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, serviceName_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig) obj;

      if (hasEdsConfig() != other.hasEdsConfig()) return false;
      if (hasEdsConfig()) {
        if (!getEdsConfig()
            .equals(other.getEdsConfig())) return false;
      }
      if (!getServiceName()
          .equals(other.getServiceName())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasEdsConfig()) {
        hash = (37 * hash) + EDS_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getEdsConfig().hashCode();
      }
      hash = (37 * hash) + SERVICE_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getServiceName().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Only valid when discovery type is EDS.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.EdsClusterConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.EdsClusterConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_EdsClusterConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_EdsClusterConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (edsConfigBuilder_ == null) {
          edsConfig_ = null;
        } else {
          edsConfig_ = null;
          edsConfigBuilder_ = null;
        }
        serviceName_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_EdsClusterConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig(this);
        if (edsConfigBuilder_ == null) {
          result.edsConfig_ = edsConfig_;
        } else {
          result.edsConfig_ = edsConfigBuilder_.build();
        }
        result.serviceName_ = serviceName_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.getDefaultInstance()) return this;
        if (other.hasEdsConfig()) {
          mergeEdsConfig(other.getEdsConfig());
        }
        if (!other.getServiceName().isEmpty()) {
          serviceName_ = other.serviceName_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private io.envoyproxy.envoy.config.core.v3.ConfigSource edsConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.ConfigSource, io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder, io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder> edsConfigBuilder_;
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       * @return Whether the edsConfig field is set.
       */
      public boolean hasEdsConfig() {
        return edsConfigBuilder_ != null || edsConfig_ != null;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       * @return The edsConfig.
       */
      public io.envoyproxy.envoy.config.core.v3.ConfigSource getEdsConfig() {
        if (edsConfigBuilder_ == null) {
          return edsConfig_ == null ? io.envoyproxy.envoy.config.core.v3.ConfigSource.getDefaultInstance() : edsConfig_;
        } else {
          return edsConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      public Builder setEdsConfig(io.envoyproxy.envoy.config.core.v3.ConfigSource value) {
        if (edsConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          edsConfig_ = value;
          onChanged();
        } else {
          edsConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      public Builder setEdsConfig(
          io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder builderForValue) {
        if (edsConfigBuilder_ == null) {
          edsConfig_ = builderForValue.build();
          onChanged();
        } else {
          edsConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      public Builder mergeEdsConfig(io.envoyproxy.envoy.config.core.v3.ConfigSource value) {
        if (edsConfigBuilder_ == null) {
          if (edsConfig_ != null) {
            edsConfig_ =
              io.envoyproxy.envoy.config.core.v3.ConfigSource.newBuilder(edsConfig_).mergeFrom(value).buildPartial();
          } else {
            edsConfig_ = value;
          }
          onChanged();
        } else {
          edsConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      public Builder clearEdsConfig() {
        if (edsConfigBuilder_ == null) {
          edsConfig_ = null;
          onChanged();
        } else {
          edsConfig_ = null;
          edsConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder getEdsConfigBuilder() {
        
        onChanged();
        return getEdsConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder getEdsConfigOrBuilder() {
        if (edsConfigBuilder_ != null) {
          return edsConfigBuilder_.getMessageOrBuilder();
        } else {
          return edsConfig_ == null ?
              io.envoyproxy.envoy.config.core.v3.ConfigSource.getDefaultInstance() : edsConfig_;
        }
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.config.core.v3.ConfigSource eds_config = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.ConfigSource, io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder, io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder> 
          getEdsConfigFieldBuilder() {
        if (edsConfigBuilder_ == null) {
          edsConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.ConfigSource, io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder, io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder>(
                  getEdsConfig(),
                  getParentForChildren(),
                  isClean());
          edsConfig_ = null;
        }
        return edsConfigBuilder_;
      }

      private java.lang.Object serviceName_ = "";
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length. This may be a xdstp:// URL.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       * @return The serviceName.
       */
      public java.lang.String getServiceName() {
        java.lang.Object ref = serviceName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length. This may be a xdstp:// URL.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       * @return The bytes for serviceName.
       */
      public com.google.protobuf.ByteString
          getServiceNameBytes() {
        java.lang.Object ref = serviceName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length. This may be a xdstp:// URL.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       * @param value The serviceName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        serviceName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length. This may be a xdstp:// URL.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceName() {
        
        serviceName_ = getDefaultInstance().getServiceName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length. This may be a xdstp:// URL.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       * @param value The bytes for serviceName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        serviceName_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.EdsClusterConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.EdsClusterConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EdsClusterConfig>
        PARSER = new com.google.protobuf.AbstractParser<EdsClusterConfig>() {
      @java.lang.Override
      public EdsClusterConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new EdsClusterConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<EdsClusterConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EdsClusterConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LbSubsetConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.LbSubsetConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for fallbackPolicy.
     */
    int getFallbackPolicyValue();
    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     * @return The fallbackPolicy.
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy getFallbackPolicy();

    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     * @return Whether the defaultSubset field is set.
     */
    boolean hasDefaultSubset();
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     * @return The defaultSubset.
     */
    com.google.protobuf.Struct getDefaultSubset();
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    com.google.protobuf.StructOrBuilder getDefaultSubsetOrBuilder();

    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector> 
        getSubsetSelectorsList();
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector getSubsetSelectors(int index);
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    int getSubsetSelectorsCount();
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
        getSubsetSelectorsOrBuilderList();
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder getSubsetSelectorsOrBuilder(
        int index);

    /**
     * <pre>
     * If true, routing to subsets will take into account the localities and locality weights of the
     * endpoints when making the routing decision.
     * There are some potential pitfalls associated with enabling this feature, as the resulting
     * traffic split after applying both a subset match and locality weights might be undesirable.
     * Consider for example a situation in which you have 50/50 split across two localities X/Y
     * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
     * host selected but Y having 100, then a lot more load is being dumped on the single host in X
     * than originally anticipated in the load balancing assignment delivered via EDS.
     * </pre>
     *
     * <code>bool locality_weight_aware = 4;</code>
     * @return The localityWeightAware.
     */
    boolean getLocalityWeightAware();

    /**
     * <pre>
     * When used with locality_weight_aware, scales the weight of each locality by the ratio
     * of hosts in the subset vs hosts in the original subset. This aims to even out the load
     * going to an individual locality if said locality is disproportionately affected by the
     * subset predicate.
     * </pre>
     *
     * <code>bool scale_locality_weight = 5;</code>
     * @return The scaleLocalityWeight.
     */
    boolean getScaleLocalityWeight();

    /**
     * <pre>
     * If true, when a fallback policy is configured and its corresponding subset fails to find
     * a host this will cause any host to be selected instead.
     * This is useful when using the default subset as the fallback policy, given the default
     * subset might become empty. With this option enabled, if that happens the LB will attempt
     * to select a host from the entire cluster.
     * </pre>
     *
     * <code>bool panic_mode_any = 6;</code>
     * @return The panicModeAny.
     */
    boolean getPanicModeAny();

    /**
     * <pre>
     * If true, metadata specified for a metadata key will be matched against the corresponding
     * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
     * and any of the elements in the list matches the criteria.
     * </pre>
     *
     * <code>bool list_as_any = 7;</code>
     * @return The listAsAny.
     */
    boolean getListAsAny();
  }
  /**
   * <pre>
   * Optionally divide the endpoints in this cluster into subsets defined by
   * endpoint metadata and selected by route and weighted cluster metadata.
   * [#next-free-field: 8]
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.LbSubsetConfig}
   */
  public static final class LbSubsetConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.LbSubsetConfig)
      LbSubsetConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LbSubsetConfig.newBuilder() to construct.
    private LbSubsetConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LbSubsetConfig() {
      fallbackPolicy_ = 0;
      subsetSelectors_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LbSubsetConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private LbSubsetConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();

              fallbackPolicy_ = rawValue;
              break;
            }
            case 18: {
              com.google.protobuf.Struct.Builder subBuilder = null;
              if (defaultSubset_ != null) {
                subBuilder = defaultSubset_.toBuilder();
              }
              defaultSubset_ = input.readMessage(com.google.protobuf.Struct.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(defaultSubset_);
                defaultSubset_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                subsetSelectors_ = new java.util.ArrayList<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector>();
                mutable_bitField0_ |= 0x00000001;
              }
              subsetSelectors_.add(
                  input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.parser(), extensionRegistry));
              break;
            }
            case 32: {

              localityWeightAware_ = input.readBool();
              break;
            }
            case 40: {

              scaleLocalityWeight_ = input.readBool();
              break;
            }
            case 48: {

              panicModeAny_ = input.readBool();
              break;
            }
            case 56: {

              listAsAny_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          subsetSelectors_ = java.util.Collections.unmodifiableList(subsetSelectors_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder.class);
    }

    /**
     * <pre>
     * If NO_FALLBACK is selected, a result
     * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
     * any cluster endpoint may be returned (subject to policy, health checks,
     * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
     * endpoints matching the values from the default_subset field.
     * </pre>
     *
     * Protobuf enum {@code envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy}
     */
    public enum LbSubsetFallbackPolicy
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_FALLBACK = 0;</code>
       */
      NO_FALLBACK(0),
      /**
       * <code>ANY_ENDPOINT = 1;</code>
       */
      ANY_ENDPOINT(1),
      /**
       * <code>DEFAULT_SUBSET = 2;</code>
       */
      DEFAULT_SUBSET(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>NO_FALLBACK = 0;</code>
       */
      public static final int NO_FALLBACK_VALUE = 0;
      /**
       * <code>ANY_ENDPOINT = 1;</code>
       */
      public static final int ANY_ENDPOINT_VALUE = 1;
      /**
       * <code>DEFAULT_SUBSET = 2;</code>
       */
      public static final int DEFAULT_SUBSET_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LbSubsetFallbackPolicy valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static LbSubsetFallbackPolicy forNumber(int value) {
        switch (value) {
          case 0: return NO_FALLBACK;
          case 1: return ANY_ENDPOINT;
          case 2: return DEFAULT_SUBSET;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<LbSubsetFallbackPolicy>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          LbSubsetFallbackPolicy> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LbSubsetFallbackPolicy>() {
              public LbSubsetFallbackPolicy findValueByNumber(int number) {
                return LbSubsetFallbackPolicy.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final LbSubsetFallbackPolicy[] VALUES = values();

      public static LbSubsetFallbackPolicy valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private LbSubsetFallbackPolicy(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy)
    }

    public interface LbSubsetSelectorOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @return A list containing the keys.
       */
      java.util.List<java.lang.String>
          getKeysList();
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @return The count of keys.
       */
      int getKeysCount();
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @param index The index of the element to return.
       * @return The keys at the given index.
       */
      java.lang.String getKeys(int index);
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the keys at the given index.
       */
      com.google.protobuf.ByteString
          getKeysBytes(int index);

      /**
       * <pre>
       * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
       * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
       * If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
       * Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
       * only one entry.
       * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
       * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
       * :ref:`lb_subsets_single_host_per_subset_duplicate&lt;config_cluster_manager_cluster_stats_subset_lb&gt;` indicates how many duplicates are
       * present in the current configuration.
       * </pre>
       *
       * <code>bool single_host_per_subset = 4;</code>
       * @return The singleHostPerSubset.
       */
      boolean getSingleHostPerSubset();

      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
       * @return The enum numeric value on the wire for fallbackPolicy.
       */
      int getFallbackPolicyValue();
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
       * @return The fallbackPolicy.
       */
      io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy getFallbackPolicy();

      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @return A list containing the fallbackKeysSubset.
       */
      java.util.List<java.lang.String>
          getFallbackKeysSubsetList();
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @return The count of fallbackKeysSubset.
       */
      int getFallbackKeysSubsetCount();
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @param index The index of the element to return.
       * @return The fallbackKeysSubset at the given index.
       */
      java.lang.String getFallbackKeysSubset(int index);
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the fallbackKeysSubset at the given index.
       */
      com.google.protobuf.ByteString
          getFallbackKeysSubsetBytes(int index);
    }
    /**
     * <pre>
     * Specifications for subsets.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector}
     */
    public static final class LbSubsetSelector extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)
        LbSubsetSelectorOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use LbSubsetSelector.newBuilder() to construct.
      private LbSubsetSelector(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private LbSubsetSelector() {
        keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        fallbackPolicy_ = 0;
        fallbackKeysSubset_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new LbSubsetSelector();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private LbSubsetSelector(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                  keys_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000001;
                }
                keys_.add(s);
                break;
              }
              case 16: {
                int rawValue = input.readEnum();

                fallbackPolicy_ = rawValue;
                break;
              }
              case 26: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                  fallbackKeysSubset_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000002;
                }
                fallbackKeysSubset_.add(s);
                break;
              }
              case 32: {

                singleHostPerSubset_ = input.readBool();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000001) != 0)) {
            keys_ = keys_.getUnmodifiableView();
          }
          if (((mutable_bitField0_ & 0x00000002) != 0)) {
            fallbackKeysSubset_ = fallbackKeysSubset_.getUnmodifiableView();
          }
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder.class);
      }

      /**
       * <pre>
       * Allows to override top level fallback policy per selector.
       * </pre>
       *
       * Protobuf enum {@code envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy}
       */
      public enum LbSubsetSelectorFallbackPolicy
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         * If NOT_DEFINED top level config fallback policy is used instead.
         * </pre>
         *
         * <code>NOT_DEFINED = 0;</code>
         */
        NOT_DEFINED(0),
        /**
         * <pre>
         * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
         * </pre>
         *
         * <code>NO_FALLBACK = 1;</code>
         */
        NO_FALLBACK(1),
        /**
         * <pre>
         * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
         * (subject to policy, health checks, etc).
         * </pre>
         *
         * <code>ANY_ENDPOINT = 2;</code>
         */
        ANY_ENDPOINT(2),
        /**
         * <pre>
         * If DEFAULT_SUBSET is selected, load balancing is performed over the
         * endpoints matching the values from the default_subset field.
         * </pre>
         *
         * <code>DEFAULT_SUBSET = 3;</code>
         */
        DEFAULT_SUBSET(3),
        /**
         * <pre>
         * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
         * keys reduced to
         * :ref:`fallback_keys_subset&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset&gt;`.
         * It allows for a fallback to a different, less specific selector if some of the keys of
         * the selector are considered optional.
         * </pre>
         *
         * <code>KEYS_SUBSET = 4;</code>
         */
        KEYS_SUBSET(4),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         * If NOT_DEFINED top level config fallback policy is used instead.
         * </pre>
         *
         * <code>NOT_DEFINED = 0;</code>
         */
        public static final int NOT_DEFINED_VALUE = 0;
        /**
         * <pre>
         * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
         * </pre>
         *
         * <code>NO_FALLBACK = 1;</code>
         */
        public static final int NO_FALLBACK_VALUE = 1;
        /**
         * <pre>
         * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
         * (subject to policy, health checks, etc).
         * </pre>
         *
         * <code>ANY_ENDPOINT = 2;</code>
         */
        public static final int ANY_ENDPOINT_VALUE = 2;
        /**
         * <pre>
         * If DEFAULT_SUBSET is selected, load balancing is performed over the
         * endpoints matching the values from the default_subset field.
         * </pre>
         *
         * <code>DEFAULT_SUBSET = 3;</code>
         */
        public static final int DEFAULT_SUBSET_VALUE = 3;
        /**
         * <pre>
         * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
         * keys reduced to
         * :ref:`fallback_keys_subset&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset&gt;`.
         * It allows for a fallback to a different, less specific selector if some of the keys of
         * the selector are considered optional.
         * </pre>
         *
         * <code>KEYS_SUBSET = 4;</code>
         */
        public static final int KEYS_SUBSET_VALUE = 4;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static LbSubsetSelectorFallbackPolicy valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static LbSubsetSelectorFallbackPolicy forNumber(int value) {
          switch (value) {
            case 0: return NOT_DEFINED;
            case 1: return NO_FALLBACK;
            case 2: return ANY_ENDPOINT;
            case 3: return DEFAULT_SUBSET;
            case 4: return KEYS_SUBSET;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<LbSubsetSelectorFallbackPolicy>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            LbSubsetSelectorFallbackPolicy> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<LbSubsetSelectorFallbackPolicy>() {
                public LbSubsetSelectorFallbackPolicy findValueByNumber(int number) {
                  return LbSubsetSelectorFallbackPolicy.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.getDescriptor().getEnumTypes().get(0);
        }

        private static final LbSubsetSelectorFallbackPolicy[] VALUES = values();

        public static LbSubsetSelectorFallbackPolicy valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private LbSubsetSelectorFallbackPolicy(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy)
      }

      public static final int KEYS_FIELD_NUMBER = 1;
      private com.google.protobuf.LazyStringList keys_;
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @return A list containing the keys.
       */
      public com.google.protobuf.ProtocolStringList
          getKeysList() {
        return keys_;
      }
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @return The count of keys.
       */
      public int getKeysCount() {
        return keys_.size();
      }
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @param index The index of the element to return.
       * @return The keys at the given index.
       */
      public java.lang.String getKeys(int index) {
        return keys_.get(index);
      }
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the keys at the given index.
       */
      public com.google.protobuf.ByteString
          getKeysBytes(int index) {
        return keys_.getByteString(index);
      }

      public static final int SINGLE_HOST_PER_SUBSET_FIELD_NUMBER = 4;
      private boolean singleHostPerSubset_;
      /**
       * <pre>
       * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
       * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
       * If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
       * Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
       * only one entry.
       * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
       * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
       * :ref:`lb_subsets_single_host_per_subset_duplicate&lt;config_cluster_manager_cluster_stats_subset_lb&gt;` indicates how many duplicates are
       * present in the current configuration.
       * </pre>
       *
       * <code>bool single_host_per_subset = 4;</code>
       * @return The singleHostPerSubset.
       */
      @java.lang.Override
      public boolean getSingleHostPerSubset() {
        return singleHostPerSubset_;
      }

      public static final int FALLBACK_POLICY_FIELD_NUMBER = 2;
      private int fallbackPolicy_;
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
       * @return The enum numeric value on the wire for fallbackPolicy.
       */
      @java.lang.Override public int getFallbackPolicyValue() {
        return fallbackPolicy_;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
       * @return The fallbackPolicy.
       */
      @java.lang.Override public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy getFallbackPolicy() {
        @SuppressWarnings("deprecation")
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy result = io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.valueOf(fallbackPolicy_);
        return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.UNRECOGNIZED : result;
      }

      public static final int FALLBACK_KEYS_SUBSET_FIELD_NUMBER = 3;
      private com.google.protobuf.LazyStringList fallbackKeysSubset_;
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @return A list containing the fallbackKeysSubset.
       */
      public com.google.protobuf.ProtocolStringList
          getFallbackKeysSubsetList() {
        return fallbackKeysSubset_;
      }
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @return The count of fallbackKeysSubset.
       */
      public int getFallbackKeysSubsetCount() {
        return fallbackKeysSubset_.size();
      }
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @param index The index of the element to return.
       * @return The fallbackKeysSubset at the given index.
       */
      public java.lang.String getFallbackKeysSubset(int index) {
        return fallbackKeysSubset_.get(index);
      }
      /**
       * <pre>
       * Subset of
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
       * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
       * fallback policy.
       * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
       * For any other fallback policy the parameter is not used and should not be set.
       * Only values also present in
       * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
       * `fallback_keys_subset` cannot be equal to `keys`.
       * </pre>
       *
       * <code>repeated string fallback_keys_subset = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the fallbackKeysSubset at the given index.
       */
      public com.google.protobuf.ByteString
          getFallbackKeysSubsetBytes(int index) {
        return fallbackKeysSubset_.getByteString(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        for (int i = 0; i < keys_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, keys_.getRaw(i));
        }
        if (fallbackPolicy_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.NOT_DEFINED.getNumber()) {
          output.writeEnum(2, fallbackPolicy_);
        }
        for (int i = 0; i < fallbackKeysSubset_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 3, fallbackKeysSubset_.getRaw(i));
        }
        if (singleHostPerSubset_ != false) {
          output.writeBool(4, singleHostPerSubset_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        {
          int dataSize = 0;
          for (int i = 0; i < keys_.size(); i++) {
            dataSize += computeStringSizeNoTag(keys_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getKeysList().size();
        }
        if (fallbackPolicy_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.NOT_DEFINED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, fallbackPolicy_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < fallbackKeysSubset_.size(); i++) {
            dataSize += computeStringSizeNoTag(fallbackKeysSubset_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getFallbackKeysSubsetList().size();
        }
        if (singleHostPerSubset_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(4, singleHostPerSubset_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)) {
          return super.equals(obj);
        }
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector) obj;

        if (!getKeysList()
            .equals(other.getKeysList())) return false;
        if (getSingleHostPerSubset()
            != other.getSingleHostPerSubset()) return false;
        if (fallbackPolicy_ != other.fallbackPolicy_) return false;
        if (!getFallbackKeysSubsetList()
            .equals(other.getFallbackKeysSubsetList())) return false;
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getKeysCount() > 0) {
          hash = (37 * hash) + KEYS_FIELD_NUMBER;
          hash = (53 * hash) + getKeysList().hashCode();
        }
        hash = (37 * hash) + SINGLE_HOST_PER_SUBSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSingleHostPerSubset());
        hash = (37 * hash) + FALLBACK_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + fallbackPolicy_;
        if (getFallbackKeysSubsetCount() > 0) {
          hash = (37 * hash) + FALLBACK_KEYS_SUBSET_FIELD_NUMBER;
          hash = (53 * hash) + getFallbackKeysSubsetList().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Specifications for subsets.
       * </pre>
       *
       * Protobuf type {@code envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder.class);
        }

        // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000001);
          singleHostPerSubset_ = false;

          fallbackPolicy_ = 0;

          fallbackKeysSubset_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_LbSubsetSelector_descriptor;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector getDefaultInstanceForType() {
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance();
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector build() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector buildPartial() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector(this);
          int from_bitField0_ = bitField0_;
          if (((bitField0_ & 0x00000001) != 0)) {
            keys_ = keys_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.keys_ = keys_;
          result.singleHostPerSubset_ = singleHostPerSubset_;
          result.fallbackPolicy_ = fallbackPolicy_;
          if (((bitField0_ & 0x00000002) != 0)) {
            fallbackKeysSubset_ = fallbackKeysSubset_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.fallbackKeysSubset_ = fallbackKeysSubset_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector) {
            return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector other) {
          if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance()) return this;
          if (!other.keys_.isEmpty()) {
            if (keys_.isEmpty()) {
              keys_ = other.keys_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureKeysIsMutable();
              keys_.addAll(other.keys_);
            }
            onChanged();
          }
          if (other.getSingleHostPerSubset() != false) {
            setSingleHostPerSubset(other.getSingleHostPerSubset());
          }
          if (other.fallbackPolicy_ != 0) {
            setFallbackPolicyValue(other.getFallbackPolicyValue());
          }
          if (!other.fallbackKeysSubset_.isEmpty()) {
            if (fallbackKeysSubset_.isEmpty()) {
              fallbackKeysSubset_ = other.fallbackKeysSubset_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureFallbackKeysSubsetIsMutable();
              fallbackKeysSubset_.addAll(other.fallbackKeysSubset_);
            }
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.LazyStringList keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureKeysIsMutable() {
          if (!((bitField0_ & 0x00000001) != 0)) {
            keys_ = new com.google.protobuf.LazyStringArrayList(keys_);
            bitField0_ |= 0x00000001;
           }
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @return A list containing the keys.
         */
        public com.google.protobuf.ProtocolStringList
            getKeysList() {
          return keys_.getUnmodifiableView();
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @return The count of keys.
         */
        public int getKeysCount() {
          return keys_.size();
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @param index The index of the element to return.
         * @return The keys at the given index.
         */
        public java.lang.String getKeys(int index) {
          return keys_.get(index);
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @param index The index of the value to return.
         * @return The bytes of the keys at the given index.
         */
        public com.google.protobuf.ByteString
            getKeysBytes(int index) {
          return keys_.getByteString(index);
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @param index The index to set the value at.
         * @param value The keys to set.
         * @return This builder for chaining.
         */
        public Builder setKeys(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureKeysIsMutable();
          keys_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @param value The keys to add.
         * @return This builder for chaining.
         */
        public Builder addKeys(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureKeysIsMutable();
          keys_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @param values The keys to add.
         * @return This builder for chaining.
         */
        public Builder addAllKeys(
            java.lang.Iterable<java.lang.String> values) {
          ensureKeysIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, keys_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearKeys() {
          keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         * @param value The bytes of the keys to add.
         * @return This builder for chaining.
         */
        public Builder addKeysBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureKeysIsMutable();
          keys_.add(value);
          onChanged();
          return this;
        }

        private boolean singleHostPerSubset_ ;
        /**
         * <pre>
         * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
         * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
         * If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
         * Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
         * only one entry.
         * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
         * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
         * :ref:`lb_subsets_single_host_per_subset_duplicate&lt;config_cluster_manager_cluster_stats_subset_lb&gt;` indicates how many duplicates are
         * present in the current configuration.
         * </pre>
         *
         * <code>bool single_host_per_subset = 4;</code>
         * @return The singleHostPerSubset.
         */
        @java.lang.Override
        public boolean getSingleHostPerSubset() {
          return singleHostPerSubset_;
        }
        /**
         * <pre>
         * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
         * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
         * If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
         * Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
         * only one entry.
         * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
         * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
         * :ref:`lb_subsets_single_host_per_subset_duplicate&lt;config_cluster_manager_cluster_stats_subset_lb&gt;` indicates how many duplicates are
         * present in the current configuration.
         * </pre>
         *
         * <code>bool single_host_per_subset = 4;</code>
         * @param value The singleHostPerSubset to set.
         * @return This builder for chaining.
         */
        public Builder setSingleHostPerSubset(boolean value) {
          
          singleHostPerSubset_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
         * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
         * If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
         * Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
         * only one entry.
         * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
         * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
         * :ref:`lb_subsets_single_host_per_subset_duplicate&lt;config_cluster_manager_cluster_stats_subset_lb&gt;` indicates how many duplicates are
         * present in the current configuration.
         * </pre>
         *
         * <code>bool single_host_per_subset = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearSingleHostPerSubset() {
          
          singleHostPerSubset_ = false;
          onChanged();
          return this;
        }

        private int fallbackPolicy_ = 0;
        /**
         * <pre>
         * The behavior used when no endpoint subset matches the selected route's
         * metadata.
         * </pre>
         *
         * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
         * @return The enum numeric value on the wire for fallbackPolicy.
         */
        @java.lang.Override public int getFallbackPolicyValue() {
          return fallbackPolicy_;
        }
        /**
         * <pre>
         * The behavior used when no endpoint subset matches the selected route's
         * metadata.
         * </pre>
         *
         * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
         * @param value The enum numeric value on the wire for fallbackPolicy to set.
         * @return This builder for chaining.
         */
        public Builder setFallbackPolicyValue(int value) {
          
          fallbackPolicy_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The behavior used when no endpoint subset matches the selected route's
         * metadata.
         * </pre>
         *
         * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
         * @return The fallbackPolicy.
         */
        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy getFallbackPolicy() {
          @SuppressWarnings("deprecation")
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy result = io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.valueOf(fallbackPolicy_);
          return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * The behavior used when no endpoint subset matches the selected route's
         * metadata.
         * </pre>
         *
         * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
         * @param value The fallbackPolicy to set.
         * @return This builder for chaining.
         */
        public Builder setFallbackPolicy(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          fallbackPolicy_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The behavior used when no endpoint subset matches the selected route's
         * metadata.
         * </pre>
         *
         * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2 [(.validate.rules) = { ... }</code>
         * @return This builder for chaining.
         */
        public Builder clearFallbackPolicy() {
          
          fallbackPolicy_ = 0;
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList fallbackKeysSubset_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureFallbackKeysSubsetIsMutable() {
          if (!((bitField0_ & 0x00000002) != 0)) {
            fallbackKeysSubset_ = new com.google.protobuf.LazyStringArrayList(fallbackKeysSubset_);
            bitField0_ |= 0x00000002;
           }
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @return A list containing the fallbackKeysSubset.
         */
        public com.google.protobuf.ProtocolStringList
            getFallbackKeysSubsetList() {
          return fallbackKeysSubset_.getUnmodifiableView();
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @return The count of fallbackKeysSubset.
         */
        public int getFallbackKeysSubsetCount() {
          return fallbackKeysSubset_.size();
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @param index The index of the element to return.
         * @return The fallbackKeysSubset at the given index.
         */
        public java.lang.String getFallbackKeysSubset(int index) {
          return fallbackKeysSubset_.get(index);
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @param index The index of the value to return.
         * @return The bytes of the fallbackKeysSubset at the given index.
         */
        public com.google.protobuf.ByteString
            getFallbackKeysSubsetBytes(int index) {
          return fallbackKeysSubset_.getByteString(index);
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @param index The index to set the value at.
         * @param value The fallbackKeysSubset to set.
         * @return This builder for chaining.
         */
        public Builder setFallbackKeysSubset(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureFallbackKeysSubsetIsMutable();
          fallbackKeysSubset_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @param value The fallbackKeysSubset to add.
         * @return This builder for chaining.
         */
        public Builder addFallbackKeysSubset(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureFallbackKeysSubsetIsMutable();
          fallbackKeysSubset_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @param values The fallbackKeysSubset to add.
         * @return This builder for chaining.
         */
        public Builder addAllFallbackKeysSubset(
            java.lang.Iterable<java.lang.String> values) {
          ensureFallbackKeysSubsetIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, fallbackKeysSubset_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearFallbackKeysSubset() {
          fallbackKeysSubset_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Subset of
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` used by
         * :ref:`KEYS_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET&gt;`
         * fallback policy.
         * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
         * For any other fallback policy the parameter is not used and should not be set.
         * Only values also present in
         * :ref:`keys&lt;envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys&gt;` are allowed, but
         * `fallback_keys_subset` cannot be equal to `keys`.
         * </pre>
         *
         * <code>repeated string fallback_keys_subset = 3;</code>
         * @param value The bytes of the fallbackKeysSubset to add.
         * @return This builder for chaining.
         */
        public Builder addFallbackKeysSubsetBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureFallbackKeysSubsetIsMutable();
          fallbackKeysSubset_.add(value);
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)
      }

      // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector)
      private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector();
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<LbSubsetSelector>
          PARSER = new com.google.protobuf.AbstractParser<LbSubsetSelector>() {
        @java.lang.Override
        public LbSubsetSelector parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new LbSubsetSelector(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<LbSubsetSelector> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<LbSubsetSelector> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int FALLBACK_POLICY_FIELD_NUMBER = 1;
    private int fallbackPolicy_;
    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for fallbackPolicy.
     */
    @java.lang.Override public int getFallbackPolicyValue() {
      return fallbackPolicy_;
    }
    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     * @return The fallbackPolicy.
     */
    @java.lang.Override public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy getFallbackPolicy() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy result = io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.valueOf(fallbackPolicy_);
      return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.UNRECOGNIZED : result;
    }

    public static final int DEFAULT_SUBSET_FIELD_NUMBER = 2;
    private com.google.protobuf.Struct defaultSubset_;
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     * @return Whether the defaultSubset field is set.
     */
    @java.lang.Override
    public boolean hasDefaultSubset() {
      return defaultSubset_ != null;
    }
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     * @return The defaultSubset.
     */
    @java.lang.Override
    public com.google.protobuf.Struct getDefaultSubset() {
      return defaultSubset_ == null ? com.google.protobuf.Struct.getDefaultInstance() : defaultSubset_;
    }
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.StructOrBuilder getDefaultSubsetOrBuilder() {
      return getDefaultSubset();
    }

    public static final int SUBSET_SELECTORS_FIELD_NUMBER = 3;
    private java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector> subsetSelectors_;
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector> getSubsetSelectorsList() {
      return subsetSelectors_;
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
        getSubsetSelectorsOrBuilderList() {
      return subsetSelectors_;
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    @java.lang.Override
    public int getSubsetSelectorsCount() {
      return subsetSelectors_.size();
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector getSubsetSelectors(int index) {
      return subsetSelectors_.get(index);
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder getSubsetSelectorsOrBuilder(
        int index) {
      return subsetSelectors_.get(index);
    }

    public static final int LOCALITY_WEIGHT_AWARE_FIELD_NUMBER = 4;
    private boolean localityWeightAware_;
    /**
     * <pre>
     * If true, routing to subsets will take into account the localities and locality weights of the
     * endpoints when making the routing decision.
     * There are some potential pitfalls associated with enabling this feature, as the resulting
     * traffic split after applying both a subset match and locality weights might be undesirable.
     * Consider for example a situation in which you have 50/50 split across two localities X/Y
     * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
     * host selected but Y having 100, then a lot more load is being dumped on the single host in X
     * than originally anticipated in the load balancing assignment delivered via EDS.
     * </pre>
     *
     * <code>bool locality_weight_aware = 4;</code>
     * @return The localityWeightAware.
     */
    @java.lang.Override
    public boolean getLocalityWeightAware() {
      return localityWeightAware_;
    }

    public static final int SCALE_LOCALITY_WEIGHT_FIELD_NUMBER = 5;
    private boolean scaleLocalityWeight_;
    /**
     * <pre>
     * When used with locality_weight_aware, scales the weight of each locality by the ratio
     * of hosts in the subset vs hosts in the original subset. This aims to even out the load
     * going to an individual locality if said locality is disproportionately affected by the
     * subset predicate.
     * </pre>
     *
     * <code>bool scale_locality_weight = 5;</code>
     * @return The scaleLocalityWeight.
     */
    @java.lang.Override
    public boolean getScaleLocalityWeight() {
      return scaleLocalityWeight_;
    }

    public static final int PANIC_MODE_ANY_FIELD_NUMBER = 6;
    private boolean panicModeAny_;
    /**
     * <pre>
     * If true, when a fallback policy is configured and its corresponding subset fails to find
     * a host this will cause any host to be selected instead.
     * This is useful when using the default subset as the fallback policy, given the default
     * subset might become empty. With this option enabled, if that happens the LB will attempt
     * to select a host from the entire cluster.
     * </pre>
     *
     * <code>bool panic_mode_any = 6;</code>
     * @return The panicModeAny.
     */
    @java.lang.Override
    public boolean getPanicModeAny() {
      return panicModeAny_;
    }

    public static final int LIST_AS_ANY_FIELD_NUMBER = 7;
    private boolean listAsAny_;
    /**
     * <pre>
     * If true, metadata specified for a metadata key will be matched against the corresponding
     * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
     * and any of the elements in the list matches the criteria.
     * </pre>
     *
     * <code>bool list_as_any = 7;</code>
     * @return The listAsAny.
     */
    @java.lang.Override
    public boolean getListAsAny() {
      return listAsAny_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (fallbackPolicy_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK.getNumber()) {
        output.writeEnum(1, fallbackPolicy_);
      }
      if (defaultSubset_ != null) {
        output.writeMessage(2, getDefaultSubset());
      }
      for (int i = 0; i < subsetSelectors_.size(); i++) {
        output.writeMessage(3, subsetSelectors_.get(i));
      }
      if (localityWeightAware_ != false) {
        output.writeBool(4, localityWeightAware_);
      }
      if (scaleLocalityWeight_ != false) {
        output.writeBool(5, scaleLocalityWeight_);
      }
      if (panicModeAny_ != false) {
        output.writeBool(6, panicModeAny_);
      }
      if (listAsAny_ != false) {
        output.writeBool(7, listAsAny_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (fallbackPolicy_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, fallbackPolicy_);
      }
      if (defaultSubset_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getDefaultSubset());
      }
      for (int i = 0; i < subsetSelectors_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, subsetSelectors_.get(i));
      }
      if (localityWeightAware_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, localityWeightAware_);
      }
      if (scaleLocalityWeight_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, scaleLocalityWeight_);
      }
      if (panicModeAny_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, panicModeAny_);
      }
      if (listAsAny_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, listAsAny_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig) obj;

      if (fallbackPolicy_ != other.fallbackPolicy_) return false;
      if (hasDefaultSubset() != other.hasDefaultSubset()) return false;
      if (hasDefaultSubset()) {
        if (!getDefaultSubset()
            .equals(other.getDefaultSubset())) return false;
      }
      if (!getSubsetSelectorsList()
          .equals(other.getSubsetSelectorsList())) return false;
      if (getLocalityWeightAware()
          != other.getLocalityWeightAware()) return false;
      if (getScaleLocalityWeight()
          != other.getScaleLocalityWeight()) return false;
      if (getPanicModeAny()
          != other.getPanicModeAny()) return false;
      if (getListAsAny()
          != other.getListAsAny()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + FALLBACK_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + fallbackPolicy_;
      if (hasDefaultSubset()) {
        hash = (37 * hash) + DEFAULT_SUBSET_FIELD_NUMBER;
        hash = (53 * hash) + getDefaultSubset().hashCode();
      }
      if (getSubsetSelectorsCount() > 0) {
        hash = (37 * hash) + SUBSET_SELECTORS_FIELD_NUMBER;
        hash = (53 * hash) + getSubsetSelectorsList().hashCode();
      }
      hash = (37 * hash) + LOCALITY_WEIGHT_AWARE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getLocalityWeightAware());
      hash = (37 * hash) + SCALE_LOCALITY_WEIGHT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getScaleLocalityWeight());
      hash = (37 * hash) + PANIC_MODE_ANY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getPanicModeAny());
      hash = (37 * hash) + LIST_AS_ANY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getListAsAny());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Optionally divide the endpoints in this cluster into subsets defined by
     * endpoint metadata and selected by route and weighted cluster metadata.
     * [#next-free-field: 8]
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.LbSubsetConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.LbSubsetConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSubsetSelectorsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        fallbackPolicy_ = 0;

        if (defaultSubsetBuilder_ == null) {
          defaultSubset_ = null;
        } else {
          defaultSubset_ = null;
          defaultSubsetBuilder_ = null;
        }
        if (subsetSelectorsBuilder_ == null) {
          subsetSelectors_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          subsetSelectorsBuilder_.clear();
        }
        localityWeightAware_ = false;

        scaleLocalityWeight_ = false;

        panicModeAny_ = false;

        listAsAny_ = false;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LbSubsetConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig(this);
        int from_bitField0_ = bitField0_;
        result.fallbackPolicy_ = fallbackPolicy_;
        if (defaultSubsetBuilder_ == null) {
          result.defaultSubset_ = defaultSubset_;
        } else {
          result.defaultSubset_ = defaultSubsetBuilder_.build();
        }
        if (subsetSelectorsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            subsetSelectors_ = java.util.Collections.unmodifiableList(subsetSelectors_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.subsetSelectors_ = subsetSelectors_;
        } else {
          result.subsetSelectors_ = subsetSelectorsBuilder_.build();
        }
        result.localityWeightAware_ = localityWeightAware_;
        result.scaleLocalityWeight_ = scaleLocalityWeight_;
        result.panicModeAny_ = panicModeAny_;
        result.listAsAny_ = listAsAny_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.getDefaultInstance()) return this;
        if (other.fallbackPolicy_ != 0) {
          setFallbackPolicyValue(other.getFallbackPolicyValue());
        }
        if (other.hasDefaultSubset()) {
          mergeDefaultSubset(other.getDefaultSubset());
        }
        if (subsetSelectorsBuilder_ == null) {
          if (!other.subsetSelectors_.isEmpty()) {
            if (subsetSelectors_.isEmpty()) {
              subsetSelectors_ = other.subsetSelectors_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSubsetSelectorsIsMutable();
              subsetSelectors_.addAll(other.subsetSelectors_);
            }
            onChanged();
          }
        } else {
          if (!other.subsetSelectors_.isEmpty()) {
            if (subsetSelectorsBuilder_.isEmpty()) {
              subsetSelectorsBuilder_.dispose();
              subsetSelectorsBuilder_ = null;
              subsetSelectors_ = other.subsetSelectors_;
              bitField0_ = (bitField0_ & ~0x00000001);
              subsetSelectorsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSubsetSelectorsFieldBuilder() : null;
            } else {
              subsetSelectorsBuilder_.addAllMessages(other.subsetSelectors_);
            }
          }
        }
        if (other.getLocalityWeightAware() != false) {
          setLocalityWeightAware(other.getLocalityWeightAware());
        }
        if (other.getScaleLocalityWeight() != false) {
          setScaleLocalityWeight(other.getScaleLocalityWeight());
        }
        if (other.getPanicModeAny() != false) {
          setPanicModeAny(other.getPanicModeAny());
        }
        if (other.getListAsAny() != false) {
          setListAsAny(other.getListAsAny());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int fallbackPolicy_ = 0;
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       * @return The enum numeric value on the wire for fallbackPolicy.
       */
      @java.lang.Override public int getFallbackPolicyValue() {
        return fallbackPolicy_;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       * @param value The enum numeric value on the wire for fallbackPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFallbackPolicyValue(int value) {
        
        fallbackPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       * @return The fallbackPolicy.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy getFallbackPolicy() {
        @SuppressWarnings("deprecation")
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy result = io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.valueOf(fallbackPolicy_);
        return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       * @param value The fallbackPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFallbackPolicy(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        fallbackPolicy_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearFallbackPolicy() {
        
        fallbackPolicy_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Struct defaultSubset_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> defaultSubsetBuilder_;
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       * @return Whether the defaultSubset field is set.
       */
      public boolean hasDefaultSubset() {
        return defaultSubsetBuilder_ != null || defaultSubset_ != null;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       * @return The defaultSubset.
       */
      public com.google.protobuf.Struct getDefaultSubset() {
        if (defaultSubsetBuilder_ == null) {
          return defaultSubset_ == null ? com.google.protobuf.Struct.getDefaultInstance() : defaultSubset_;
        } else {
          return defaultSubsetBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder setDefaultSubset(com.google.protobuf.Struct value) {
        if (defaultSubsetBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          defaultSubset_ = value;
          onChanged();
        } else {
          defaultSubsetBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder setDefaultSubset(
          com.google.protobuf.Struct.Builder builderForValue) {
        if (defaultSubsetBuilder_ == null) {
          defaultSubset_ = builderForValue.build();
          onChanged();
        } else {
          defaultSubsetBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder mergeDefaultSubset(com.google.protobuf.Struct value) {
        if (defaultSubsetBuilder_ == null) {
          if (defaultSubset_ != null) {
            defaultSubset_ =
              com.google.protobuf.Struct.newBuilder(defaultSubset_).mergeFrom(value).buildPartial();
          } else {
            defaultSubset_ = value;
          }
          onChanged();
        } else {
          defaultSubsetBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder clearDefaultSubset() {
        if (defaultSubsetBuilder_ == null) {
          defaultSubset_ = null;
          onChanged();
        } else {
          defaultSubset_ = null;
          defaultSubsetBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public com.google.protobuf.Struct.Builder getDefaultSubsetBuilder() {
        
        onChanged();
        return getDefaultSubsetFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public com.google.protobuf.StructOrBuilder getDefaultSubsetOrBuilder() {
        if (defaultSubsetBuilder_ != null) {
          return defaultSubsetBuilder_.getMessageOrBuilder();
        } else {
          return defaultSubset_ == null ?
              com.google.protobuf.Struct.getDefaultInstance() : defaultSubset_;
        }
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> 
          getDefaultSubsetFieldBuilder() {
        if (defaultSubsetBuilder_ == null) {
          defaultSubsetBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder>(
                  getDefaultSubset(),
                  getParentForChildren(),
                  isClean());
          defaultSubset_ = null;
        }
        return defaultSubsetBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector> subsetSelectors_ =
        java.util.Collections.emptyList();
      private void ensureSubsetSelectorsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          subsetSelectors_ = new java.util.ArrayList<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector>(subsetSelectors_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> subsetSelectorsBuilder_;

      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector> getSubsetSelectorsList() {
        if (subsetSelectorsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(subsetSelectors_);
        } else {
          return subsetSelectorsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public int getSubsetSelectorsCount() {
        if (subsetSelectorsBuilder_ == null) {
          return subsetSelectors_.size();
        } else {
          return subsetSelectorsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector getSubsetSelectors(int index) {
        if (subsetSelectorsBuilder_ == null) {
          return subsetSelectors_.get(index);
        } else {
          return subsetSelectorsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder setSubsetSelectors(
          int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector value) {
        if (subsetSelectorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.set(index, value);
          onChanged();
        } else {
          subsetSelectorsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder setSubsetSelectors(
          int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder builderForValue) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.set(index, builderForValue.build());
          onChanged();
        } else {
          subsetSelectorsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector value) {
        if (subsetSelectorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(value);
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(
          int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector value) {
        if (subsetSelectorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(index, value);
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder builderForValue) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(builderForValue.build());
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(
          int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder builderForValue) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(index, builderForValue.build());
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addAllSubsetSelectors(
          java.lang.Iterable<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector> values) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, subsetSelectors_);
          onChanged();
        } else {
          subsetSelectorsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder clearSubsetSelectors() {
        if (subsetSelectorsBuilder_ == null) {
          subsetSelectors_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          subsetSelectorsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder removeSubsetSelectors(int index) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.remove(index);
          onChanged();
        } else {
          subsetSelectorsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder getSubsetSelectorsBuilder(
          int index) {
        return getSubsetSelectorsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder getSubsetSelectorsOrBuilder(
          int index) {
        if (subsetSelectorsBuilder_ == null) {
          return subsetSelectors_.get(index);  } else {
          return subsetSelectorsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
           getSubsetSelectorsOrBuilderList() {
        if (subsetSelectorsBuilder_ != null) {
          return subsetSelectorsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(subsetSelectors_);
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder addSubsetSelectorsBuilder() {
        return getSubsetSelectorsFieldBuilder().addBuilder(
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance());
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder addSubsetSelectorsBuilder(
          int index) {
        return getSubsetSelectorsFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance());
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder> 
           getSubsetSelectorsBuilderList() {
        return getSubsetSelectorsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
          getSubsetSelectorsFieldBuilder() {
        if (subsetSelectorsBuilder_ == null) {
          subsetSelectorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder>(
                  subsetSelectors_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          subsetSelectors_ = null;
        }
        return subsetSelectorsBuilder_;
      }

      private boolean localityWeightAware_ ;
      /**
       * <pre>
       * If true, routing to subsets will take into account the localities and locality weights of the
       * endpoints when making the routing decision.
       * There are some potential pitfalls associated with enabling this feature, as the resulting
       * traffic split after applying both a subset match and locality weights might be undesirable.
       * Consider for example a situation in which you have 50/50 split across two localities X/Y
       * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
       * host selected but Y having 100, then a lot more load is being dumped on the single host in X
       * than originally anticipated in the load balancing assignment delivered via EDS.
       * </pre>
       *
       * <code>bool locality_weight_aware = 4;</code>
       * @return The localityWeightAware.
       */
      @java.lang.Override
      public boolean getLocalityWeightAware() {
        return localityWeightAware_;
      }
      /**
       * <pre>
       * If true, routing to subsets will take into account the localities and locality weights of the
       * endpoints when making the routing decision.
       * There are some potential pitfalls associated with enabling this feature, as the resulting
       * traffic split after applying both a subset match and locality weights might be undesirable.
       * Consider for example a situation in which you have 50/50 split across two localities X/Y
       * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
       * host selected but Y having 100, then a lot more load is being dumped on the single host in X
       * than originally anticipated in the load balancing assignment delivered via EDS.
       * </pre>
       *
       * <code>bool locality_weight_aware = 4;</code>
       * @param value The localityWeightAware to set.
       * @return This builder for chaining.
       */
      public Builder setLocalityWeightAware(boolean value) {
        
        localityWeightAware_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, routing to subsets will take into account the localities and locality weights of the
       * endpoints when making the routing decision.
       * There are some potential pitfalls associated with enabling this feature, as the resulting
       * traffic split after applying both a subset match and locality weights might be undesirable.
       * Consider for example a situation in which you have 50/50 split across two localities X/Y
       * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
       * host selected but Y having 100, then a lot more load is being dumped on the single host in X
       * than originally anticipated in the load balancing assignment delivered via EDS.
       * </pre>
       *
       * <code>bool locality_weight_aware = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalityWeightAware() {
        
        localityWeightAware_ = false;
        onChanged();
        return this;
      }

      private boolean scaleLocalityWeight_ ;
      /**
       * <pre>
       * When used with locality_weight_aware, scales the weight of each locality by the ratio
       * of hosts in the subset vs hosts in the original subset. This aims to even out the load
       * going to an individual locality if said locality is disproportionately affected by the
       * subset predicate.
       * </pre>
       *
       * <code>bool scale_locality_weight = 5;</code>
       * @return The scaleLocalityWeight.
       */
      @java.lang.Override
      public boolean getScaleLocalityWeight() {
        return scaleLocalityWeight_;
      }
      /**
       * <pre>
       * When used with locality_weight_aware, scales the weight of each locality by the ratio
       * of hosts in the subset vs hosts in the original subset. This aims to even out the load
       * going to an individual locality if said locality is disproportionately affected by the
       * subset predicate.
       * </pre>
       *
       * <code>bool scale_locality_weight = 5;</code>
       * @param value The scaleLocalityWeight to set.
       * @return This builder for chaining.
       */
      public Builder setScaleLocalityWeight(boolean value) {
        
        scaleLocalityWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When used with locality_weight_aware, scales the weight of each locality by the ratio
       * of hosts in the subset vs hosts in the original subset. This aims to even out the load
       * going to an individual locality if said locality is disproportionately affected by the
       * subset predicate.
       * </pre>
       *
       * <code>bool scale_locality_weight = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearScaleLocalityWeight() {
        
        scaleLocalityWeight_ = false;
        onChanged();
        return this;
      }

      private boolean panicModeAny_ ;
      /**
       * <pre>
       * If true, when a fallback policy is configured and its corresponding subset fails to find
       * a host this will cause any host to be selected instead.
       * This is useful when using the default subset as the fallback policy, given the default
       * subset might become empty. With this option enabled, if that happens the LB will attempt
       * to select a host from the entire cluster.
       * </pre>
       *
       * <code>bool panic_mode_any = 6;</code>
       * @return The panicModeAny.
       */
      @java.lang.Override
      public boolean getPanicModeAny() {
        return panicModeAny_;
      }
      /**
       * <pre>
       * If true, when a fallback policy is configured and its corresponding subset fails to find
       * a host this will cause any host to be selected instead.
       * This is useful when using the default subset as the fallback policy, given the default
       * subset might become empty. With this option enabled, if that happens the LB will attempt
       * to select a host from the entire cluster.
       * </pre>
       *
       * <code>bool panic_mode_any = 6;</code>
       * @param value The panicModeAny to set.
       * @return This builder for chaining.
       */
      public Builder setPanicModeAny(boolean value) {
        
        panicModeAny_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, when a fallback policy is configured and its corresponding subset fails to find
       * a host this will cause any host to be selected instead.
       * This is useful when using the default subset as the fallback policy, given the default
       * subset might become empty. With this option enabled, if that happens the LB will attempt
       * to select a host from the entire cluster.
       * </pre>
       *
       * <code>bool panic_mode_any = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPanicModeAny() {
        
        panicModeAny_ = false;
        onChanged();
        return this;
      }

      private boolean listAsAny_ ;
      /**
       * <pre>
       * If true, metadata specified for a metadata key will be matched against the corresponding
       * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
       * and any of the elements in the list matches the criteria.
       * </pre>
       *
       * <code>bool list_as_any = 7;</code>
       * @return The listAsAny.
       */
      @java.lang.Override
      public boolean getListAsAny() {
        return listAsAny_;
      }
      /**
       * <pre>
       * If true, metadata specified for a metadata key will be matched against the corresponding
       * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
       * and any of the elements in the list matches the criteria.
       * </pre>
       *
       * <code>bool list_as_any = 7;</code>
       * @param value The listAsAny to set.
       * @return This builder for chaining.
       */
      public Builder setListAsAny(boolean value) {
        
        listAsAny_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, metadata specified for a metadata key will be matched against the corresponding
       * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
       * and any of the elements in the list matches the criteria.
       * </pre>
       *
       * <code>bool list_as_any = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearListAsAny() {
        
        listAsAny_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.LbSubsetConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.LbSubsetConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LbSubsetConfig>
        PARSER = new com.google.protobuf.AbstractParser<LbSubsetConfig>() {
      @java.lang.Override
      public LbSubsetConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new LbSubsetConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<LbSubsetConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LbSubsetConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LeastRequestLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the choiceCount field is set.
     */
    boolean hasChoiceCount();
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     * @return The choiceCount.
     */
    com.google.protobuf.UInt32Value getChoiceCount();
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt32ValueOrBuilder getChoiceCountOrBuilder();

    /**
     * <pre>
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     * `active_request_bias` must be greater than or equal to 0.0.
     * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
     * @return Whether the activeRequestBias field is set.
     */
    boolean hasActiveRequestBias();
    /**
     * <pre>
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     * `active_request_bias` must be greater than or equal to 0.0.
     * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
     * @return The activeRequestBias.
     */
    io.envoyproxy.envoy.config.core.v3.RuntimeDouble getActiveRequestBias();
    /**
     * <pre>
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     * `active_request_bias` must be greater than or equal to 0.0.
     * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
     */
    io.envoyproxy.envoy.config.core.v3.RuntimeDoubleOrBuilder getActiveRequestBiasOrBuilder();
  }
  /**
   * <pre>
   * Specific configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.LeastRequestLbConfig}
   */
  public static final class LeastRequestLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)
      LeastRequestLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LeastRequestLbConfig.newBuilder() to construct.
    private LeastRequestLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LeastRequestLbConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LeastRequestLbConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private LeastRequestLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.UInt32Value.Builder subBuilder = null;
              if (choiceCount_ != null) {
                subBuilder = choiceCount_.toBuilder();
              }
              choiceCount_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(choiceCount_);
                choiceCount_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              io.envoyproxy.envoy.config.core.v3.RuntimeDouble.Builder subBuilder = null;
              if (activeRequestBias_ != null) {
                subBuilder = activeRequestBias_.toBuilder();
              }
              activeRequestBias_ = input.readMessage(io.envoyproxy.envoy.config.core.v3.RuntimeDouble.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(activeRequestBias_);
                activeRequestBias_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LeastRequestLbConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LeastRequestLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder.class);
    }

    public static final int CHOICE_COUNT_FIELD_NUMBER = 1;
    private com.google.protobuf.UInt32Value choiceCount_;
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the choiceCount field is set.
     */
    @java.lang.Override
    public boolean hasChoiceCount() {
      return choiceCount_ != null;
    }
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     * @return The choiceCount.
     */
    @java.lang.Override
    public com.google.protobuf.UInt32Value getChoiceCount() {
      return choiceCount_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : choiceCount_;
    }
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt32ValueOrBuilder getChoiceCountOrBuilder() {
      return getChoiceCount();
    }

    public static final int ACTIVE_REQUEST_BIAS_FIELD_NUMBER = 2;
    private io.envoyproxy.envoy.config.core.v3.RuntimeDouble activeRequestBias_;
    /**
     * <pre>
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     * `active_request_bias` must be greater than or equal to 0.0.
     * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
     * @return Whether the activeRequestBias field is set.
     */
    @java.lang.Override
    public boolean hasActiveRequestBias() {
      return activeRequestBias_ != null;
    }
    /**
     * <pre>
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     * `active_request_bias` must be greater than or equal to 0.0.
     * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
     * @return The activeRequestBias.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.RuntimeDouble getActiveRequestBias() {
      return activeRequestBias_ == null ? io.envoyproxy.envoy.config.core.v3.RuntimeDouble.getDefaultInstance() : activeRequestBias_;
    }
    /**
     * <pre>
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     * `active_request_bias` must be greater than or equal to 0.0.
     * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.RuntimeDoubleOrBuilder getActiveRequestBiasOrBuilder() {
      return getActiveRequestBias();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (choiceCount_ != null) {
        output.writeMessage(1, getChoiceCount());
      }
      if (activeRequestBias_ != null) {
        output.writeMessage(2, getActiveRequestBias());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (choiceCount_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getChoiceCount());
      }
      if (activeRequestBias_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getActiveRequestBias());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) obj;

      if (hasChoiceCount() != other.hasChoiceCount()) return false;
      if (hasChoiceCount()) {
        if (!getChoiceCount()
            .equals(other.getChoiceCount())) return false;
      }
      if (hasActiveRequestBias() != other.hasActiveRequestBias()) return false;
      if (hasActiveRequestBias()) {
        if (!getActiveRequestBias()
            .equals(other.getActiveRequestBias())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasChoiceCount()) {
        hash = (37 * hash) + CHOICE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getChoiceCount().hashCode();
      }
      if (hasActiveRequestBias()) {
        hash = (37 * hash) + ACTIVE_REQUEST_BIAS_FIELD_NUMBER;
        hash = (53 * hash) + getActiveRequestBias().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.LeastRequestLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LeastRequestLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LeastRequestLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (choiceCountBuilder_ == null) {
          choiceCount_ = null;
        } else {
          choiceCount_ = null;
          choiceCountBuilder_ = null;
        }
        if (activeRequestBiasBuilder_ == null) {
          activeRequestBias_ = null;
        } else {
          activeRequestBias_ = null;
          activeRequestBiasBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_LeastRequestLbConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig(this);
        if (choiceCountBuilder_ == null) {
          result.choiceCount_ = choiceCount_;
        } else {
          result.choiceCount_ = choiceCountBuilder_.build();
        }
        if (activeRequestBiasBuilder_ == null) {
          result.activeRequestBias_ = activeRequestBias_;
        } else {
          result.activeRequestBias_ = activeRequestBiasBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance()) return this;
        if (other.hasChoiceCount()) {
          mergeChoiceCount(other.getChoiceCount());
        }
        if (other.hasActiveRequestBias()) {
          mergeActiveRequestBias(other.getActiveRequestBias());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.UInt32Value choiceCount_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> choiceCountBuilder_;
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       * @return Whether the choiceCount field is set.
       */
      public boolean hasChoiceCount() {
        return choiceCountBuilder_ != null || choiceCount_ != null;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       * @return The choiceCount.
       */
      public com.google.protobuf.UInt32Value getChoiceCount() {
        if (choiceCountBuilder_ == null) {
          return choiceCount_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : choiceCount_;
        } else {
          return choiceCountBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setChoiceCount(com.google.protobuf.UInt32Value value) {
        if (choiceCountBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          choiceCount_ = value;
          onChanged();
        } else {
          choiceCountBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setChoiceCount(
          com.google.protobuf.UInt32Value.Builder builderForValue) {
        if (choiceCountBuilder_ == null) {
          choiceCount_ = builderForValue.build();
          onChanged();
        } else {
          choiceCountBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeChoiceCount(com.google.protobuf.UInt32Value value) {
        if (choiceCountBuilder_ == null) {
          if (choiceCount_ != null) {
            choiceCount_ =
              com.google.protobuf.UInt32Value.newBuilder(choiceCount_).mergeFrom(value).buildPartial();
          } else {
            choiceCount_ = value;
          }
          onChanged();
        } else {
          choiceCountBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearChoiceCount() {
        if (choiceCountBuilder_ == null) {
          choiceCount_ = null;
          onChanged();
        } else {
          choiceCount_ = null;
          choiceCountBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt32Value.Builder getChoiceCountBuilder() {
        
        onChanged();
        return getChoiceCountFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt32ValueOrBuilder getChoiceCountOrBuilder() {
        if (choiceCountBuilder_ != null) {
          return choiceCountBuilder_.getMessageOrBuilder();
        } else {
          return choiceCount_ == null ?
              com.google.protobuf.UInt32Value.getDefaultInstance() : choiceCount_;
        }
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
          getChoiceCountFieldBuilder() {
        if (choiceCountBuilder_ == null) {
          choiceCountBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                  getChoiceCount(),
                  getParentForChildren(),
                  isClean());
          choiceCount_ = null;
        }
        return choiceCountBuilder_;
      }

      private io.envoyproxy.envoy.config.core.v3.RuntimeDouble activeRequestBias_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.RuntimeDouble, io.envoyproxy.envoy.config.core.v3.RuntimeDouble.Builder, io.envoyproxy.envoy.config.core.v3.RuntimeDoubleOrBuilder> activeRequestBiasBuilder_;
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       * @return Whether the activeRequestBias field is set.
       */
      public boolean hasActiveRequestBias() {
        return activeRequestBiasBuilder_ != null || activeRequestBias_ != null;
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       * @return The activeRequestBias.
       */
      public io.envoyproxy.envoy.config.core.v3.RuntimeDouble getActiveRequestBias() {
        if (activeRequestBiasBuilder_ == null) {
          return activeRequestBias_ == null ? io.envoyproxy.envoy.config.core.v3.RuntimeDouble.getDefaultInstance() : activeRequestBias_;
        } else {
          return activeRequestBiasBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      public Builder setActiveRequestBias(io.envoyproxy.envoy.config.core.v3.RuntimeDouble value) {
        if (activeRequestBiasBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          activeRequestBias_ = value;
          onChanged();
        } else {
          activeRequestBiasBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      public Builder setActiveRequestBias(
          io.envoyproxy.envoy.config.core.v3.RuntimeDouble.Builder builderForValue) {
        if (activeRequestBiasBuilder_ == null) {
          activeRequestBias_ = builderForValue.build();
          onChanged();
        } else {
          activeRequestBiasBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      public Builder mergeActiveRequestBias(io.envoyproxy.envoy.config.core.v3.RuntimeDouble value) {
        if (activeRequestBiasBuilder_ == null) {
          if (activeRequestBias_ != null) {
            activeRequestBias_ =
              io.envoyproxy.envoy.config.core.v3.RuntimeDouble.newBuilder(activeRequestBias_).mergeFrom(value).buildPartial();
          } else {
            activeRequestBias_ = value;
          }
          onChanged();
        } else {
          activeRequestBiasBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      public Builder clearActiveRequestBias() {
        if (activeRequestBiasBuilder_ == null) {
          activeRequestBias_ = null;
          onChanged();
        } else {
          activeRequestBias_ = null;
          activeRequestBiasBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.RuntimeDouble.Builder getActiveRequestBiasBuilder() {
        
        onChanged();
        return getActiveRequestBiasFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.RuntimeDoubleOrBuilder getActiveRequestBiasOrBuilder() {
        if (activeRequestBiasBuilder_ != null) {
          return activeRequestBiasBuilder_.getMessageOrBuilder();
        } else {
          return activeRequestBias_ == null ?
              io.envoyproxy.envoy.config.core.v3.RuntimeDouble.getDefaultInstance() : activeRequestBias_;
        }
      }
      /**
       * <pre>
       * The following formula is used to calculate the dynamic weights when hosts have different load
       * balancing weights:
       * `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
       * The larger the active request bias is, the more aggressively active requests will lower the
       * effective weight when all host weights are not equal.
       * `active_request_bias` must be greater than or equal to 0.0.
       * When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
       * of active requests at the time it picks a host and behaves like the Round Robin Load
       * Balancer.
       * When `active_request_bias &gt; 0.0` the Least Request Load Balancer scales the load balancing
       * weight by the number of active requests at the time it does a pick.
       * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
       * host sets changes, e.g., whenever there is a host membership update or a host load balancing
       * weight change.
       * .. note::
       *   This setting only takes effect if all host weights are not equal.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RuntimeDouble active_request_bias = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.RuntimeDouble, io.envoyproxy.envoy.config.core.v3.RuntimeDouble.Builder, io.envoyproxy.envoy.config.core.v3.RuntimeDoubleOrBuilder> 
          getActiveRequestBiasFieldBuilder() {
        if (activeRequestBiasBuilder_ == null) {
          activeRequestBiasBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.RuntimeDouble, io.envoyproxy.envoy.config.core.v3.RuntimeDouble.Builder, io.envoyproxy.envoy.config.core.v3.RuntimeDoubleOrBuilder>(
                  getActiveRequestBias(),
                  getParentForChildren(),
                  isClean());
          activeRequestBias_ = null;
        }
        return activeRequestBiasBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.LeastRequestLbConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LeastRequestLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<LeastRequestLbConfig>() {
      @java.lang.Override
      public LeastRequestLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new LeastRequestLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<LeastRequestLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LeastRequestLbConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RingHashLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.RingHashLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the minimumRingSize field is set.
     */
    boolean hasMinimumRingSize();
    /**
     * <pre>
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     * @return The minimumRingSize.
     */
    com.google.protobuf.UInt64Value getMinimumRingSize();
    /**
     * <pre>
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder();

    /**
     * <pre>
     * The hash function used to hash hosts onto the ketama ring. The value defaults to
     * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for hashFunction.
     */
    int getHashFunctionValue();
    /**
     * <pre>
     * The hash function used to hash hosts onto the ketama ring. The value defaults to
     * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
     * @return The hashFunction.
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction getHashFunction();

    /**
     * <pre>
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
     * @return Whether the maximumRingSize field is set.
     */
    boolean hasMaximumRingSize();
    /**
     * <pre>
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
     * @return The maximumRingSize.
     */
    com.google.protobuf.UInt64Value getMaximumRingSize();
    /**
     * <pre>
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt64ValueOrBuilder getMaximumRingSizeOrBuilder();
  }
  /**
   * <pre>
   * Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash&gt;`
   * load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.RingHashLbConfig}
   */
  public static final class RingHashLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.RingHashLbConfig)
      RingHashLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RingHashLbConfig.newBuilder() to construct.
    private RingHashLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RingHashLbConfig() {
      hashFunction_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RingHashLbConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RingHashLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.UInt64Value.Builder subBuilder = null;
              if (minimumRingSize_ != null) {
                subBuilder = minimumRingSize_.toBuilder();
              }
              minimumRingSize_ = input.readMessage(com.google.protobuf.UInt64Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(minimumRingSize_);
                minimumRingSize_ = subBuilder.buildPartial();
              }

              break;
            }
            case 24: {
              int rawValue = input.readEnum();

              hashFunction_ = rawValue;
              break;
            }
            case 34: {
              com.google.protobuf.UInt64Value.Builder subBuilder = null;
              if (maximumRingSize_ != null) {
                subBuilder = maximumRingSize_.toBuilder();
              }
              maximumRingSize_ = input.readMessage(com.google.protobuf.UInt64Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maximumRingSize_);
                maximumRingSize_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RingHashLbConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RingHashLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder.class);
    }

    /**
     * <pre>
     * The hash function used to hash hosts onto the ketama ring.
     * </pre>
     *
     * Protobuf enum {@code envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction}
     */
    public enum HashFunction
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Use `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_, this is the default hash function.
       * </pre>
       *
       * <code>XX_HASH = 0;</code>
       */
      XX_HASH(0),
      /**
       * <pre>
       * Use `MurmurHash2 &lt;https://sites.google.com/site/murmurhash/&gt;`_, this is compatible with
       * std:hash&lt;string&gt; in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
       * on Linux and not macOS.
       * </pre>
       *
       * <code>MURMUR_HASH_2 = 1;</code>
       */
      MURMUR_HASH_2(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Use `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_, this is the default hash function.
       * </pre>
       *
       * <code>XX_HASH = 0;</code>
       */
      public static final int XX_HASH_VALUE = 0;
      /**
       * <pre>
       * Use `MurmurHash2 &lt;https://sites.google.com/site/murmurhash/&gt;`_, this is compatible with
       * std:hash&lt;string&gt; in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
       * on Linux and not macOS.
       * </pre>
       *
       * <code>MURMUR_HASH_2 = 1;</code>
       */
      public static final int MURMUR_HASH_2_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static HashFunction valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static HashFunction forNumber(int value) {
        switch (value) {
          case 0: return XX_HASH;
          case 1: return MURMUR_HASH_2;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<HashFunction>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          HashFunction> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<HashFunction>() {
              public HashFunction findValueByNumber(int number) {
                return HashFunction.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final HashFunction[] VALUES = values();

      public static HashFunction valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private HashFunction(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction)
    }

    public static final int MINIMUM_RING_SIZE_FIELD_NUMBER = 1;
    private com.google.protobuf.UInt64Value minimumRingSize_;
    /**
     * <pre>
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the minimumRingSize field is set.
     */
    @java.lang.Override
    public boolean hasMinimumRingSize() {
      return minimumRingSize_ != null;
    }
    /**
     * <pre>
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     * @return The minimumRingSize.
     */
    @java.lang.Override
    public com.google.protobuf.UInt64Value getMinimumRingSize() {
      return minimumRingSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minimumRingSize_;
    }
    /**
     * <pre>
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder() {
      return getMinimumRingSize();
    }

    public static final int HASH_FUNCTION_FIELD_NUMBER = 3;
    private int hashFunction_;
    /**
     * <pre>
     * The hash function used to hash hosts onto the ketama ring. The value defaults to
     * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for hashFunction.
     */
    @java.lang.Override public int getHashFunctionValue() {
      return hashFunction_;
    }
    /**
     * <pre>
     * The hash function used to hash hosts onto the ketama ring. The value defaults to
     * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
     * @return The hashFunction.
     */
    @java.lang.Override public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction getHashFunction() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction result = io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.valueOf(hashFunction_);
      return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.UNRECOGNIZED : result;
    }

    public static final int MAXIMUM_RING_SIZE_FIELD_NUMBER = 4;
    private com.google.protobuf.UInt64Value maximumRingSize_;
    /**
     * <pre>
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
     * @return Whether the maximumRingSize field is set.
     */
    @java.lang.Override
    public boolean hasMaximumRingSize() {
      return maximumRingSize_ != null;
    }
    /**
     * <pre>
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
     * @return The maximumRingSize.
     */
    @java.lang.Override
    public com.google.protobuf.UInt64Value getMaximumRingSize() {
      return maximumRingSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : maximumRingSize_;
    }
    /**
     * <pre>
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt64ValueOrBuilder getMaximumRingSizeOrBuilder() {
      return getMaximumRingSize();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (minimumRingSize_ != null) {
        output.writeMessage(1, getMinimumRingSize());
      }
      if (hashFunction_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH.getNumber()) {
        output.writeEnum(3, hashFunction_);
      }
      if (maximumRingSize_ != null) {
        output.writeMessage(4, getMaximumRingSize());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (minimumRingSize_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMinimumRingSize());
      }
      if (hashFunction_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, hashFunction_);
      }
      if (maximumRingSize_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getMaximumRingSize());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) obj;

      if (hasMinimumRingSize() != other.hasMinimumRingSize()) return false;
      if (hasMinimumRingSize()) {
        if (!getMinimumRingSize()
            .equals(other.getMinimumRingSize())) return false;
      }
      if (hashFunction_ != other.hashFunction_) return false;
      if (hasMaximumRingSize() != other.hasMaximumRingSize()) return false;
      if (hasMaximumRingSize()) {
        if (!getMaximumRingSize()
            .equals(other.getMaximumRingSize())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMinimumRingSize()) {
        hash = (37 * hash) + MINIMUM_RING_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMinimumRingSize().hashCode();
      }
      hash = (37 * hash) + HASH_FUNCTION_FIELD_NUMBER;
      hash = (53 * hash) + hashFunction_;
      if (hasMaximumRingSize()) {
        hash = (37 * hash) + MAXIMUM_RING_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMaximumRingSize().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash&gt;`
     * load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.RingHashLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.RingHashLbConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RingHashLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RingHashLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSize_ = null;
        } else {
          minimumRingSize_ = null;
          minimumRingSizeBuilder_ = null;
        }
        hashFunction_ = 0;

        if (maximumRingSizeBuilder_ == null) {
          maximumRingSize_ = null;
        } else {
          maximumRingSize_ = null;
          maximumRingSizeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RingHashLbConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig(this);
        if (minimumRingSizeBuilder_ == null) {
          result.minimumRingSize_ = minimumRingSize_;
        } else {
          result.minimumRingSize_ = minimumRingSizeBuilder_.build();
        }
        result.hashFunction_ = hashFunction_;
        if (maximumRingSizeBuilder_ == null) {
          result.maximumRingSize_ = maximumRingSize_;
        } else {
          result.maximumRingSize_ = maximumRingSizeBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance()) return this;
        if (other.hasMinimumRingSize()) {
          mergeMinimumRingSize(other.getMinimumRingSize());
        }
        if (other.hashFunction_ != 0) {
          setHashFunctionValue(other.getHashFunctionValue());
        }
        if (other.hasMaximumRingSize()) {
          mergeMaximumRingSize(other.getMaximumRingSize());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.UInt64Value minimumRingSize_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> minimumRingSizeBuilder_;
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       * @return Whether the minimumRingSize field is set.
       */
      public boolean hasMinimumRingSize() {
        return minimumRingSizeBuilder_ != null || minimumRingSize_ != null;
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       * @return The minimumRingSize.
       */
      public com.google.protobuf.UInt64Value getMinimumRingSize() {
        if (minimumRingSizeBuilder_ == null) {
          return minimumRingSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minimumRingSize_;
        } else {
          return minimumRingSizeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setMinimumRingSize(com.google.protobuf.UInt64Value value) {
        if (minimumRingSizeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          minimumRingSize_ = value;
          onChanged();
        } else {
          minimumRingSizeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setMinimumRingSize(
          com.google.protobuf.UInt64Value.Builder builderForValue) {
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSize_ = builderForValue.build();
          onChanged();
        } else {
          minimumRingSizeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeMinimumRingSize(com.google.protobuf.UInt64Value value) {
        if (minimumRingSizeBuilder_ == null) {
          if (minimumRingSize_ != null) {
            minimumRingSize_ =
              com.google.protobuf.UInt64Value.newBuilder(minimumRingSize_).mergeFrom(value).buildPartial();
          } else {
            minimumRingSize_ = value;
          }
          onChanged();
        } else {
          minimumRingSizeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearMinimumRingSize() {
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSize_ = null;
          onChanged();
        } else {
          minimumRingSize_ = null;
          minimumRingSizeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64Value.Builder getMinimumRingSizeBuilder() {
        
        onChanged();
        return getMinimumRingSizeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder() {
        if (minimumRingSizeBuilder_ != null) {
          return minimumRingSizeBuilder_.getMessageOrBuilder();
        } else {
          return minimumRingSize_ == null ?
              com.google.protobuf.UInt64Value.getDefaultInstance() : minimumRingSize_;
        }
      }
      /**
       * <pre>
       * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
       * provided host) the better the request distribution will reflect the desired weights. Defaults
       * to 1024 entries, and limited to 8M entries. See also
       * :ref:`maximum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
          getMinimumRingSizeFieldBuilder() {
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                  getMinimumRingSize(),
                  getParentForChildren(),
                  isClean());
          minimumRingSize_ = null;
        }
        return minimumRingSizeBuilder_;
      }

      private int hashFunction_ = 0;
      /**
       * <pre>
       * The hash function used to hash hosts onto the ketama ring. The value defaults to
       * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
       * @return The enum numeric value on the wire for hashFunction.
       */
      @java.lang.Override public int getHashFunctionValue() {
        return hashFunction_;
      }
      /**
       * <pre>
       * The hash function used to hash hosts onto the ketama ring. The value defaults to
       * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
       * @param value The enum numeric value on the wire for hashFunction to set.
       * @return This builder for chaining.
       */
      public Builder setHashFunctionValue(int value) {
        
        hashFunction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash function used to hash hosts onto the ketama ring. The value defaults to
       * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
       * @return The hashFunction.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction getHashFunction() {
        @SuppressWarnings("deprecation")
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction result = io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.valueOf(hashFunction_);
        return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The hash function used to hash hosts onto the ketama ring. The value defaults to
       * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
       * @param value The hashFunction to set.
       * @return This builder for chaining.
       */
      public Builder setHashFunction(io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        hashFunction_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash function used to hash hosts onto the ketama ring. The value defaults to
       * :ref:`XX_HASH&lt;envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearHashFunction() {
        
        hashFunction_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.UInt64Value maximumRingSize_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> maximumRingSizeBuilder_;
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       * @return Whether the maximumRingSize field is set.
       */
      public boolean hasMaximumRingSize() {
        return maximumRingSizeBuilder_ != null || maximumRingSize_ != null;
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       * @return The maximumRingSize.
       */
      public com.google.protobuf.UInt64Value getMaximumRingSize() {
        if (maximumRingSizeBuilder_ == null) {
          return maximumRingSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : maximumRingSize_;
        } else {
          return maximumRingSizeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      public Builder setMaximumRingSize(com.google.protobuf.UInt64Value value) {
        if (maximumRingSizeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maximumRingSize_ = value;
          onChanged();
        } else {
          maximumRingSizeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      public Builder setMaximumRingSize(
          com.google.protobuf.UInt64Value.Builder builderForValue) {
        if (maximumRingSizeBuilder_ == null) {
          maximumRingSize_ = builderForValue.build();
          onChanged();
        } else {
          maximumRingSizeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeMaximumRingSize(com.google.protobuf.UInt64Value value) {
        if (maximumRingSizeBuilder_ == null) {
          if (maximumRingSize_ != null) {
            maximumRingSize_ =
              com.google.protobuf.UInt64Value.newBuilder(maximumRingSize_).mergeFrom(value).buildPartial();
          } else {
            maximumRingSize_ = value;
          }
          onChanged();
        } else {
          maximumRingSizeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      public Builder clearMaximumRingSize() {
        if (maximumRingSizeBuilder_ == null) {
          maximumRingSize_ = null;
          onChanged();
        } else {
          maximumRingSize_ = null;
          maximumRingSizeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64Value.Builder getMaximumRingSizeBuilder() {
        
        onChanged();
        return getMaximumRingSizeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64ValueOrBuilder getMaximumRingSizeOrBuilder() {
        if (maximumRingSizeBuilder_ != null) {
          return maximumRingSizeBuilder_.getMessageOrBuilder();
        } else {
          return maximumRingSize_ == null ?
              com.google.protobuf.UInt64Value.getDefaultInstance() : maximumRingSize_;
        }
      }
      /**
       * <pre>
       * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
       * to further constrain resource use. See also
       * :ref:`minimum_ring_size&lt;envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value maximum_ring_size = 4 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
          getMaximumRingSizeFieldBuilder() {
        if (maximumRingSizeBuilder_ == null) {
          maximumRingSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                  getMaximumRingSize(),
                  getParentForChildren(),
                  isClean());
          maximumRingSize_ = null;
        }
        return maximumRingSizeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.RingHashLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.RingHashLbConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RingHashLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<RingHashLbConfig>() {
      @java.lang.Override
      public RingHashLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RingHashLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RingHashLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RingHashLbConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MaglevLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.MaglevLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number. If it is not specified, the default is 65537.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value table_size = 1;</code>
     * @return Whether the tableSize field is set.
     */
    boolean hasTableSize();
    /**
     * <pre>
     * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number. If it is not specified, the default is 65537.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value table_size = 1;</code>
     * @return The tableSize.
     */
    com.google.protobuf.UInt64Value getTableSize();
    /**
     * <pre>
     * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number. If it is not specified, the default is 65537.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value table_size = 1;</code>
     */
    com.google.protobuf.UInt64ValueOrBuilder getTableSizeOrBuilder();
  }
  /**
   * <pre>
   * Specific configuration for the :ref:`Maglev&lt;arch_overview_load_balancing_types_maglev&gt;`
   * load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.MaglevLbConfig}
   */
  public static final class MaglevLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.MaglevLbConfig)
      MaglevLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MaglevLbConfig.newBuilder() to construct.
    private MaglevLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MaglevLbConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MaglevLbConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MaglevLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.UInt64Value.Builder subBuilder = null;
              if (tableSize_ != null) {
                subBuilder = tableSize_.toBuilder();
              }
              tableSize_ = input.readMessage(com.google.protobuf.UInt64Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(tableSize_);
                tableSize_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_MaglevLbConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_MaglevLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder.class);
    }

    public static final int TABLE_SIZE_FIELD_NUMBER = 1;
    private com.google.protobuf.UInt64Value tableSize_;
    /**
     * <pre>
     * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number. If it is not specified, the default is 65537.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value table_size = 1;</code>
     * @return Whether the tableSize field is set.
     */
    @java.lang.Override
    public boolean hasTableSize() {
      return tableSize_ != null;
    }
    /**
     * <pre>
     * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number. If it is not specified, the default is 65537.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value table_size = 1;</code>
     * @return The tableSize.
     */
    @java.lang.Override
    public com.google.protobuf.UInt64Value getTableSize() {
      return tableSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : tableSize_;
    }
    /**
     * <pre>
     * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number. If it is not specified, the default is 65537.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value table_size = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt64ValueOrBuilder getTableSizeOrBuilder() {
      return getTableSize();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (tableSize_ != null) {
        output.writeMessage(1, getTableSize());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (tableSize_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getTableSize());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) obj;

      if (hasTableSize() != other.hasTableSize()) return false;
      if (hasTableSize()) {
        if (!getTableSize()
            .equals(other.getTableSize())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTableSize()) {
        hash = (37 * hash) + TABLE_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getTableSize().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the :ref:`Maglev&lt;arch_overview_load_balancing_types_maglev&gt;`
     * load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.MaglevLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.MaglevLbConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_MaglevLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_MaglevLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (tableSizeBuilder_ == null) {
          tableSize_ = null;
        } else {
          tableSize_ = null;
          tableSizeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_MaglevLbConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig(this);
        if (tableSizeBuilder_ == null) {
          result.tableSize_ = tableSize_;
        } else {
          result.tableSize_ = tableSizeBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance()) return this;
        if (other.hasTableSize()) {
          mergeTableSize(other.getTableSize());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.UInt64Value tableSize_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> tableSizeBuilder_;
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       * @return Whether the tableSize field is set.
       */
      public boolean hasTableSize() {
        return tableSizeBuilder_ != null || tableSize_ != null;
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       * @return The tableSize.
       */
      public com.google.protobuf.UInt64Value getTableSize() {
        if (tableSizeBuilder_ == null) {
          return tableSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : tableSize_;
        } else {
          return tableSizeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      public Builder setTableSize(com.google.protobuf.UInt64Value value) {
        if (tableSizeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          tableSize_ = value;
          onChanged();
        } else {
          tableSizeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      public Builder setTableSize(
          com.google.protobuf.UInt64Value.Builder builderForValue) {
        if (tableSizeBuilder_ == null) {
          tableSize_ = builderForValue.build();
          onChanged();
        } else {
          tableSizeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      public Builder mergeTableSize(com.google.protobuf.UInt64Value value) {
        if (tableSizeBuilder_ == null) {
          if (tableSize_ != null) {
            tableSize_ =
              com.google.protobuf.UInt64Value.newBuilder(tableSize_).mergeFrom(value).buildPartial();
          } else {
            tableSize_ = value;
          }
          onChanged();
        } else {
          tableSizeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      public Builder clearTableSize() {
        if (tableSizeBuilder_ == null) {
          tableSize_ = null;
          onChanged();
        } else {
          tableSize_ = null;
          tableSizeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      public com.google.protobuf.UInt64Value.Builder getTableSizeBuilder() {
        
        onChanged();
        return getTableSizeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      public com.google.protobuf.UInt64ValueOrBuilder getTableSizeOrBuilder() {
        if (tableSizeBuilder_ != null) {
          return tableSizeBuilder_.getMessageOrBuilder();
        } else {
          return tableSize_ == null ?
              com.google.protobuf.UInt64Value.getDefaultInstance() : tableSize_;
        }
      }
      /**
       * <pre>
       * The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
       * Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
       * upstream as it was before. Increasing the table size reduces the amount of disruption.
       * The table size must be prime number. If it is not specified, the default is 65537.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value table_size = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
          getTableSizeFieldBuilder() {
        if (tableSizeBuilder_ == null) {
          tableSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                  getTableSize(),
                  getParentForChildren(),
                  isClean());
          tableSize_ = null;
        }
        return tableSizeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.MaglevLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.MaglevLbConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MaglevLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<MaglevLbConfig>() {
      @java.lang.Override
      public MaglevLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MaglevLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MaglevLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MaglevLbConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OriginalDstLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When true, :ref:`x-envoy-original-dst-host
     * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
     * address.
     * .. attention::
     *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
     *   route traffic to arbitrary hosts and/or ports, which may have serious security
     *   consequences.
     * .. note::
     *   If the header appears multiple times only the first value is used.
     * </pre>
     *
     * <code>bool use_http_header = 1;</code>
     * @return The useHttpHeader.
     */
    boolean getUseHttpHeader();
  }
  /**
   * <pre>
   * Specific configuration for the
   * :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination&gt;`
   * load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.OriginalDstLbConfig}
   */
  public static final class OriginalDstLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)
      OriginalDstLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use OriginalDstLbConfig.newBuilder() to construct.
    private OriginalDstLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OriginalDstLbConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new OriginalDstLbConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private OriginalDstLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              useHttpHeader_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_OriginalDstLbConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_OriginalDstLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder.class);
    }

    public static final int USE_HTTP_HEADER_FIELD_NUMBER = 1;
    private boolean useHttpHeader_;
    /**
     * <pre>
     * When true, :ref:`x-envoy-original-dst-host
     * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
     * address.
     * .. attention::
     *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
     *   route traffic to arbitrary hosts and/or ports, which may have serious security
     *   consequences.
     * .. note::
     *   If the header appears multiple times only the first value is used.
     * </pre>
     *
     * <code>bool use_http_header = 1;</code>
     * @return The useHttpHeader.
     */
    @java.lang.Override
    public boolean getUseHttpHeader() {
      return useHttpHeader_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (useHttpHeader_ != false) {
        output.writeBool(1, useHttpHeader_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (useHttpHeader_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, useHttpHeader_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) obj;

      if (getUseHttpHeader()
          != other.getUseHttpHeader()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + USE_HTTP_HEADER_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUseHttpHeader());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the
     * :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination&gt;`
     * load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.OriginalDstLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_OriginalDstLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_OriginalDstLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        useHttpHeader_ = false;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_OriginalDstLbConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig(this);
        result.useHttpHeader_ = useHttpHeader_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance()) return this;
        if (other.getUseHttpHeader() != false) {
          setUseHttpHeader(other.getUseHttpHeader());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private boolean useHttpHeader_ ;
      /**
       * <pre>
       * When true, :ref:`x-envoy-original-dst-host
       * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
       * address.
       * .. attention::
       *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
       *   route traffic to arbitrary hosts and/or ports, which may have serious security
       *   consequences.
       * .. note::
       *   If the header appears multiple times only the first value is used.
       * </pre>
       *
       * <code>bool use_http_header = 1;</code>
       * @return The useHttpHeader.
       */
      @java.lang.Override
      public boolean getUseHttpHeader() {
        return useHttpHeader_;
      }
      /**
       * <pre>
       * When true, :ref:`x-envoy-original-dst-host
       * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
       * address.
       * .. attention::
       *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
       *   route traffic to arbitrary hosts and/or ports, which may have serious security
       *   consequences.
       * .. note::
       *   If the header appears multiple times only the first value is used.
       * </pre>
       *
       * <code>bool use_http_header = 1;</code>
       * @param value The useHttpHeader to set.
       * @return This builder for chaining.
       */
      public Builder setUseHttpHeader(boolean value) {
        
        useHttpHeader_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When true, :ref:`x-envoy-original-dst-host
       * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
       * address.
       * .. attention::
       *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
       *   route traffic to arbitrary hosts and/or ports, which may have serious security
       *   consequences.
       * .. note::
       *   If the header appears multiple times only the first value is used.
       * </pre>
       *
       * <code>bool use_http_header = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUseHttpHeader() {
        
        useHttpHeader_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.OriginalDstLbConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OriginalDstLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<OriginalDstLbConfig>() {
      @java.lang.Override
      public OriginalDstLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new OriginalDstLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<OriginalDstLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OriginalDstLbConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CommonLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.CommonLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
     * @return Whether the healthyPanicThreshold field is set.
     */
    boolean hasHealthyPanicThreshold();
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
     * @return The healthyPanicThreshold.
     */
    io.envoyproxy.envoy.type.v3.Percent getHealthyPanicThreshold();
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getHealthyPanicThresholdOrBuilder();

    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     * @return Whether the zoneAwareLbConfig field is set.
     */
    boolean hasZoneAwareLbConfig();
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     * @return The zoneAwareLbConfig.
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig getZoneAwareLbConfig();
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder getZoneAwareLbConfigOrBuilder();

    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     * @return Whether the localityWeightedLbConfig field is set.
     */
    boolean hasLocalityWeightedLbConfig();
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     * @return The localityWeightedLbConfig.
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig getLocalityWeightedLbConfig();
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder getLocalityWeightedLbConfigOrBuilder();

    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     * @return Whether the updateMergeWindow field is set.
     */
    boolean hasUpdateMergeWindow();
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     * @return The updateMergeWindow.
     */
    com.google.protobuf.Duration getUpdateMergeWindow();
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    com.google.protobuf.DurationOrBuilder getUpdateMergeWindowOrBuilder();

    /**
     * <pre>
     * If set to true, Envoy will not consider new hosts when computing load balancing weights until
     * they have been health checked for the first time. This will have no effect unless
     * active health checking is also configured.
     * Ignoring a host means that for any load balancing calculations that adjust weights based
     * on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
     * panic mode) Envoy will exclude these hosts in the denominator.
     * For example, with hosts in two priorities P0 and P1, where P0 looks like
     * {healthy, unhealthy (new), unhealthy (new)}
     * and where P1 looks like
     * {healthy, healthy}
     * all traffic will still hit P0, as 1 / (3 - 2) = 1.
     * Enabling this will allow scaling up the number of hosts for a given cluster without entering
     * panic mode or triggering priority spillover, assuming the hosts pass the first health check.
     * If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
     * contribute to the calculation when deciding whether panic mode is enabled or not.
     * </pre>
     *
     * <code>bool ignore_new_hosts_until_first_hc = 5;</code>
     * @return The ignoreNewHostsUntilFirstHc.
     */
    boolean getIgnoreNewHostsUntilFirstHc();

    /**
     * <pre>
     * If set to `true`, the cluster manager will drain all existing
     * connections to upstream hosts whenever hosts are added or removed from the cluster.
     * </pre>
     *
     * <code>bool close_connections_on_host_set_change = 6;</code>
     * @return The closeConnectionsOnHostSetChange.
     */
    boolean getCloseConnectionsOnHostSetChange();

    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
     * @return Whether the consistentHashingLbConfig field is set.
     */
    boolean hasConsistentHashingLbConfig();
    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
     * @return The consistentHashingLbConfig.
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig getConsistentHashingLbConfig();
    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
     */
    io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder getConsistentHashingLbConfigOrBuilder();

    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityConfigSpecifierCase getLocalityConfigSpecifierCase();
  }
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * [#next-free-field: 8]
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig}
   */
  public static final class CommonLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig)
      CommonLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CommonLbConfig.newBuilder() to construct.
    private CommonLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CommonLbConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CommonLbConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CommonLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.envoyproxy.envoy.type.v3.Percent.Builder subBuilder = null;
              if (healthyPanicThreshold_ != null) {
                subBuilder = healthyPanicThreshold_.toBuilder();
              }
              healthyPanicThreshold_ = input.readMessage(io.envoyproxy.envoy.type.v3.Percent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(healthyPanicThreshold_);
                healthyPanicThreshold_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder subBuilder = null;
              if (localityConfigSpecifierCase_ == 2) {
                subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_).toBuilder();
              }
              localityConfigSpecifier_ =
                  input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_);
                localityConfigSpecifier_ = subBuilder.buildPartial();
              }
              localityConfigSpecifierCase_ = 2;
              break;
            }
            case 26: {
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder subBuilder = null;
              if (localityConfigSpecifierCase_ == 3) {
                subBuilder = ((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_).toBuilder();
              }
              localityConfigSpecifier_ =
                  input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_);
                localityConfigSpecifier_ = subBuilder.buildPartial();
              }
              localityConfigSpecifierCase_ = 3;
              break;
            }
            case 34: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (updateMergeWindow_ != null) {
                subBuilder = updateMergeWindow_.toBuilder();
              }
              updateMergeWindow_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(updateMergeWindow_);
                updateMergeWindow_ = subBuilder.buildPartial();
              }

              break;
            }
            case 40: {

              ignoreNewHostsUntilFirstHc_ = input.readBool();
              break;
            }
            case 48: {

              closeConnectionsOnHostSetChange_ = input.readBool();
              break;
            }
            case 58: {
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder subBuilder = null;
              if (consistentHashingLbConfig_ != null) {
                subBuilder = consistentHashingLbConfig_.toBuilder();
              }
              consistentHashingLbConfig_ = input.readMessage(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(consistentHashingLbConfig_);
                consistentHashingLbConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder.class);
    }

    public interface ZoneAwareLbConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
       * @return Whether the routingEnabled field is set.
       */
      boolean hasRoutingEnabled();
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
       * @return The routingEnabled.
       */
      io.envoyproxy.envoy.type.v3.Percent getRoutingEnabled();
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
       */
      io.envoyproxy.envoy.type.v3.PercentOrBuilder getRoutingEnabledOrBuilder();

      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       * @return Whether the minClusterSize field is set.
       */
      boolean hasMinClusterSize();
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       * @return The minClusterSize.
       */
      com.google.protobuf.UInt64Value getMinClusterSize();
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      com.google.protobuf.UInt64ValueOrBuilder getMinClusterSizeOrBuilder();

      /**
       * <pre>
       * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
       * mode&lt;arch_overview_load_balancing_panic_threshold&gt;`. Instead, the cluster will fail all
       * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
       * failing service.
       * </pre>
       *
       * <code>bool fail_traffic_on_panic = 3;</code>
       * @return The failTrafficOnPanic.
       */
      boolean getFailTrafficOnPanic();
    }
    /**
     * <pre>
     * Configuration for :ref:`zone aware routing
     * &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig}
     */
    public static final class ZoneAwareLbConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)
        ZoneAwareLbConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ZoneAwareLbConfig.newBuilder() to construct.
      private ZoneAwareLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ZoneAwareLbConfig() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new ZoneAwareLbConfig();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private ZoneAwareLbConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                io.envoyproxy.envoy.type.v3.Percent.Builder subBuilder = null;
                if (routingEnabled_ != null) {
                  subBuilder = routingEnabled_.toBuilder();
                }
                routingEnabled_ = input.readMessage(io.envoyproxy.envoy.type.v3.Percent.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(routingEnabled_);
                  routingEnabled_ = subBuilder.buildPartial();
                }

                break;
              }
              case 18: {
                com.google.protobuf.UInt64Value.Builder subBuilder = null;
                if (minClusterSize_ != null) {
                  subBuilder = minClusterSize_.toBuilder();
                }
                minClusterSize_ = input.readMessage(com.google.protobuf.UInt64Value.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(minClusterSize_);
                  minClusterSize_ = subBuilder.buildPartial();
                }

                break;
              }
              case 24: {

                failTrafficOnPanic_ = input.readBool();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ZoneAwareLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ZoneAwareLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder.class);
      }

      public static final int ROUTING_ENABLED_FIELD_NUMBER = 1;
      private io.envoyproxy.envoy.type.v3.Percent routingEnabled_;
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
       * @return Whether the routingEnabled field is set.
       */
      @java.lang.Override
      public boolean hasRoutingEnabled() {
        return routingEnabled_ != null;
      }
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
       * @return The routingEnabled.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.type.v3.Percent getRoutingEnabled() {
        return routingEnabled_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : routingEnabled_;
      }
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
       */
      @java.lang.Override
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getRoutingEnabledOrBuilder() {
        return getRoutingEnabled();
      }

      public static final int MIN_CLUSTER_SIZE_FIELD_NUMBER = 2;
      private com.google.protobuf.UInt64Value minClusterSize_;
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       * @return Whether the minClusterSize field is set.
       */
      @java.lang.Override
      public boolean hasMinClusterSize() {
        return minClusterSize_ != null;
      }
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       * @return The minClusterSize.
       */
      @java.lang.Override
      public com.google.protobuf.UInt64Value getMinClusterSize() {
        return minClusterSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minClusterSize_;
      }
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.UInt64ValueOrBuilder getMinClusterSizeOrBuilder() {
        return getMinClusterSize();
      }

      public static final int FAIL_TRAFFIC_ON_PANIC_FIELD_NUMBER = 3;
      private boolean failTrafficOnPanic_;
      /**
       * <pre>
       * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
       * mode&lt;arch_overview_load_balancing_panic_threshold&gt;`. Instead, the cluster will fail all
       * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
       * failing service.
       * </pre>
       *
       * <code>bool fail_traffic_on_panic = 3;</code>
       * @return The failTrafficOnPanic.
       */
      @java.lang.Override
      public boolean getFailTrafficOnPanic() {
        return failTrafficOnPanic_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (routingEnabled_ != null) {
          output.writeMessage(1, getRoutingEnabled());
        }
        if (minClusterSize_ != null) {
          output.writeMessage(2, getMinClusterSize());
        }
        if (failTrafficOnPanic_ != false) {
          output.writeBool(3, failTrafficOnPanic_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (routingEnabled_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getRoutingEnabled());
        }
        if (minClusterSize_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getMinClusterSize());
        }
        if (failTrafficOnPanic_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(3, failTrafficOnPanic_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)) {
          return super.equals(obj);
        }
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) obj;

        if (hasRoutingEnabled() != other.hasRoutingEnabled()) return false;
        if (hasRoutingEnabled()) {
          if (!getRoutingEnabled()
              .equals(other.getRoutingEnabled())) return false;
        }
        if (hasMinClusterSize() != other.hasMinClusterSize()) return false;
        if (hasMinClusterSize()) {
          if (!getMinClusterSize()
              .equals(other.getMinClusterSize())) return false;
        }
        if (getFailTrafficOnPanic()
            != other.getFailTrafficOnPanic()) return false;
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasRoutingEnabled()) {
          hash = (37 * hash) + ROUTING_ENABLED_FIELD_NUMBER;
          hash = (53 * hash) + getRoutingEnabled().hashCode();
        }
        if (hasMinClusterSize()) {
          hash = (37 * hash) + MIN_CLUSTER_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getMinClusterSize().hashCode();
        }
        hash = (37 * hash) + FAIL_TRAFFIC_ON_PANIC_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFailTrafficOnPanic());
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Configuration for :ref:`zone aware routing
       * &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ZoneAwareLbConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ZoneAwareLbConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder.class);
        }

        // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          if (routingEnabledBuilder_ == null) {
            routingEnabled_ = null;
          } else {
            routingEnabled_ = null;
            routingEnabledBuilder_ = null;
          }
          if (minClusterSizeBuilder_ == null) {
            minClusterSize_ = null;
          } else {
            minClusterSize_ = null;
            minClusterSizeBuilder_ = null;
          }
          failTrafficOnPanic_ = false;

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ZoneAwareLbConfig_descriptor;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig getDefaultInstanceForType() {
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig build() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig buildPartial() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig(this);
          if (routingEnabledBuilder_ == null) {
            result.routingEnabled_ = routingEnabled_;
          } else {
            result.routingEnabled_ = routingEnabledBuilder_.build();
          }
          if (minClusterSizeBuilder_ == null) {
            result.minClusterSize_ = minClusterSize_;
          } else {
            result.minClusterSize_ = minClusterSizeBuilder_.build();
          }
          result.failTrafficOnPanic_ = failTrafficOnPanic_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) {
            return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig other) {
          if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance()) return this;
          if (other.hasRoutingEnabled()) {
            mergeRoutingEnabled(other.getRoutingEnabled());
          }
          if (other.hasMinClusterSize()) {
            mergeMinClusterSize(other.getMinClusterSize());
          }
          if (other.getFailTrafficOnPanic() != false) {
            setFailTrafficOnPanic(other.getFailTrafficOnPanic());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private io.envoyproxy.envoy.type.v3.Percent routingEnabled_;
        private com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> routingEnabledBuilder_;
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         * @return Whether the routingEnabled field is set.
         */
        public boolean hasRoutingEnabled() {
          return routingEnabledBuilder_ != null || routingEnabled_ != null;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         * @return The routingEnabled.
         */
        public io.envoyproxy.envoy.type.v3.Percent getRoutingEnabled() {
          if (routingEnabledBuilder_ == null) {
            return routingEnabled_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : routingEnabled_;
          } else {
            return routingEnabledBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        public Builder setRoutingEnabled(io.envoyproxy.envoy.type.v3.Percent value) {
          if (routingEnabledBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            routingEnabled_ = value;
            onChanged();
          } else {
            routingEnabledBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        public Builder setRoutingEnabled(
            io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
          if (routingEnabledBuilder_ == null) {
            routingEnabled_ = builderForValue.build();
            onChanged();
          } else {
            routingEnabledBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        public Builder mergeRoutingEnabled(io.envoyproxy.envoy.type.v3.Percent value) {
          if (routingEnabledBuilder_ == null) {
            if (routingEnabled_ != null) {
              routingEnabled_ =
                io.envoyproxy.envoy.type.v3.Percent.newBuilder(routingEnabled_).mergeFrom(value).buildPartial();
            } else {
              routingEnabled_ = value;
            }
            onChanged();
          } else {
            routingEnabledBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        public Builder clearRoutingEnabled() {
          if (routingEnabledBuilder_ == null) {
            routingEnabled_ = null;
            onChanged();
          } else {
            routingEnabled_ = null;
            routingEnabledBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        public io.envoyproxy.envoy.type.v3.Percent.Builder getRoutingEnabledBuilder() {
          
          onChanged();
          return getRoutingEnabledFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        public io.envoyproxy.envoy.type.v3.PercentOrBuilder getRoutingEnabledOrBuilder() {
          if (routingEnabledBuilder_ != null) {
            return routingEnabledBuilder_.getMessageOrBuilder();
          } else {
            return routingEnabled_ == null ?
                io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : routingEnabled_;
          }
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.v3.Percent routing_enabled = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
            getRoutingEnabledFieldBuilder() {
          if (routingEnabledBuilder_ == null) {
            routingEnabledBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                    getRoutingEnabled(),
                    getParentForChildren(),
                    isClean());
            routingEnabled_ = null;
          }
          return routingEnabledBuilder_;
        }

        private com.google.protobuf.UInt64Value minClusterSize_;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> minClusterSizeBuilder_;
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         * @return Whether the minClusterSize field is set.
         */
        public boolean hasMinClusterSize() {
          return minClusterSizeBuilder_ != null || minClusterSize_ != null;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         * @return The minClusterSize.
         */
        public com.google.protobuf.UInt64Value getMinClusterSize() {
          if (minClusterSizeBuilder_ == null) {
            return minClusterSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minClusterSize_;
          } else {
            return minClusterSizeBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder setMinClusterSize(com.google.protobuf.UInt64Value value) {
          if (minClusterSizeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            minClusterSize_ = value;
            onChanged();
          } else {
            minClusterSizeBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder setMinClusterSize(
            com.google.protobuf.UInt64Value.Builder builderForValue) {
          if (minClusterSizeBuilder_ == null) {
            minClusterSize_ = builderForValue.build();
            onChanged();
          } else {
            minClusterSizeBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder mergeMinClusterSize(com.google.protobuf.UInt64Value value) {
          if (minClusterSizeBuilder_ == null) {
            if (minClusterSize_ != null) {
              minClusterSize_ =
                com.google.protobuf.UInt64Value.newBuilder(minClusterSize_).mergeFrom(value).buildPartial();
            } else {
              minClusterSize_ = value;
            }
            onChanged();
          } else {
            minClusterSizeBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder clearMinClusterSize() {
          if (minClusterSizeBuilder_ == null) {
            minClusterSize_ = null;
            onChanged();
          } else {
            minClusterSize_ = null;
            minClusterSizeBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public com.google.protobuf.UInt64Value.Builder getMinClusterSizeBuilder() {
          
          onChanged();
          return getMinClusterSizeFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public com.google.protobuf.UInt64ValueOrBuilder getMinClusterSizeOrBuilder() {
          if (minClusterSizeBuilder_ != null) {
            return minClusterSizeBuilder_.getMessageOrBuilder();
          } else {
            return minClusterSize_ == null ?
                com.google.protobuf.UInt64Value.getDefaultInstance() : minClusterSize_;
          }
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
            getMinClusterSizeFieldBuilder() {
          if (minClusterSizeBuilder_ == null) {
            minClusterSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                    getMinClusterSize(),
                    getParentForChildren(),
                    isClean());
            minClusterSize_ = null;
          }
          return minClusterSizeBuilder_;
        }

        private boolean failTrafficOnPanic_ ;
        /**
         * <pre>
         * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
         * mode&lt;arch_overview_load_balancing_panic_threshold&gt;`. Instead, the cluster will fail all
         * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
         * failing service.
         * </pre>
         *
         * <code>bool fail_traffic_on_panic = 3;</code>
         * @return The failTrafficOnPanic.
         */
        @java.lang.Override
        public boolean getFailTrafficOnPanic() {
          return failTrafficOnPanic_;
        }
        /**
         * <pre>
         * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
         * mode&lt;arch_overview_load_balancing_panic_threshold&gt;`. Instead, the cluster will fail all
         * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
         * failing service.
         * </pre>
         *
         * <code>bool fail_traffic_on_panic = 3;</code>
         * @param value The failTrafficOnPanic to set.
         * @return This builder for chaining.
         */
        public Builder setFailTrafficOnPanic(boolean value) {
          
          failTrafficOnPanic_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
         * mode&lt;arch_overview_load_balancing_panic_threshold&gt;`. Instead, the cluster will fail all
         * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
         * failing service.
         * </pre>
         *
         * <code>bool fail_traffic_on_panic = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearFailTrafficOnPanic() {
          
          failTrafficOnPanic_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)
      }

      // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig)
      private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig();
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ZoneAwareLbConfig>
          PARSER = new com.google.protobuf.AbstractParser<ZoneAwareLbConfig>() {
        @java.lang.Override
        public ZoneAwareLbConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new ZoneAwareLbConfig(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<ZoneAwareLbConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ZoneAwareLbConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface LocalityWeightedLbConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * <pre>
     * Configuration for :ref:`locality weighted load balancing
     * &lt;arch_overview_load_balancing_locality_weighted_lb&gt;`
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig}
     */
    public static final class LocalityWeightedLbConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
        LocalityWeightedLbConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use LocalityWeightedLbConfig.newBuilder() to construct.
      private LocalityWeightedLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private LocalityWeightedLbConfig() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new LocalityWeightedLbConfig();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private LocalityWeightedLbConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_LocalityWeightedLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_LocalityWeightedLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)) {
          return super.equals(obj);
        }
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) obj;

        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Configuration for :ref:`locality weighted load balancing
       * &lt;arch_overview_load_balancing_locality_weighted_lb&gt;`
       * </pre>
       *
       * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_LocalityWeightedLbConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_LocalityWeightedLbConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder.class);
        }

        // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_LocalityWeightedLbConfig_descriptor;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig getDefaultInstanceForType() {
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig build() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig buildPartial() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig(this);
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) {
            return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig other) {
          if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
      }

      // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
      private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig();
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<LocalityWeightedLbConfig>
          PARSER = new com.google.protobuf.AbstractParser<LocalityWeightedLbConfig>() {
        @java.lang.Override
        public LocalityWeightedLbConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new LocalityWeightedLbConfig(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<LocalityWeightedLbConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<LocalityWeightedLbConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface ConsistentHashingLbConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * If set to `true`, the cluster will use hostname instead of the resolved
       * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
       * </pre>
       *
       * <code>bool use_hostname_for_hashing = 1;</code>
       * @return The useHostnameForHashing.
       */
      boolean getUseHostnameForHashing();

      /**
       * <pre>
       * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
       * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
       * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
       * Minimum is 100.
       * Applies to both Ring Hash and Maglev load balancers.
       * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
       * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
       * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
       * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
       * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
       * cascading overflow effect when choosing the next host in the ring/table).
       * If weights are specified on the hosts, they are respected.
       * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
       * being probed, so use a higher value if you require better performance.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
       * @return Whether the hashBalanceFactor field is set.
       */
      boolean hasHashBalanceFactor();
      /**
       * <pre>
       * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
       * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
       * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
       * Minimum is 100.
       * Applies to both Ring Hash and Maglev load balancers.
       * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
       * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
       * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
       * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
       * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
       * cascading overflow effect when choosing the next host in the ring/table).
       * If weights are specified on the hosts, they are respected.
       * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
       * being probed, so use a higher value if you require better performance.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
       * @return The hashBalanceFactor.
       */
      com.google.protobuf.UInt32Value getHashBalanceFactor();
      /**
       * <pre>
       * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
       * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
       * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
       * Minimum is 100.
       * Applies to both Ring Hash and Maglev load balancers.
       * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
       * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
       * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
       * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
       * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
       * cascading overflow effect when choosing the next host in the ring/table).
       * If weights are specified on the hosts, they are respected.
       * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
       * being probed, so use a higher value if you require better performance.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
       */
      com.google.protobuf.UInt32ValueOrBuilder getHashBalanceFactorOrBuilder();
    }
    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig}
     */
    public static final class ConsistentHashingLbConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)
        ConsistentHashingLbConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ConsistentHashingLbConfig.newBuilder() to construct.
      private ConsistentHashingLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ConsistentHashingLbConfig() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new ConsistentHashingLbConfig();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private ConsistentHashingLbConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {

                useHostnameForHashing_ = input.readBool();
                break;
              }
              case 18: {
                com.google.protobuf.UInt32Value.Builder subBuilder = null;
                if (hashBalanceFactor_ != null) {
                  subBuilder = hashBalanceFactor_.toBuilder();
                }
                hashBalanceFactor_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(hashBalanceFactor_);
                  hashBalanceFactor_ = subBuilder.buildPartial();
                }

                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ConsistentHashingLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ConsistentHashingLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder.class);
      }

      public static final int USE_HOSTNAME_FOR_HASHING_FIELD_NUMBER = 1;
      private boolean useHostnameForHashing_;
      /**
       * <pre>
       * If set to `true`, the cluster will use hostname instead of the resolved
       * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
       * </pre>
       *
       * <code>bool use_hostname_for_hashing = 1;</code>
       * @return The useHostnameForHashing.
       */
      @java.lang.Override
      public boolean getUseHostnameForHashing() {
        return useHostnameForHashing_;
      }

      public static final int HASH_BALANCE_FACTOR_FIELD_NUMBER = 2;
      private com.google.protobuf.UInt32Value hashBalanceFactor_;
      /**
       * <pre>
       * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
       * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
       * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
       * Minimum is 100.
       * Applies to both Ring Hash and Maglev load balancers.
       * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
       * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
       * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
       * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
       * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
       * cascading overflow effect when choosing the next host in the ring/table).
       * If weights are specified on the hosts, they are respected.
       * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
       * being probed, so use a higher value if you require better performance.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
       * @return Whether the hashBalanceFactor field is set.
       */
      @java.lang.Override
      public boolean hasHashBalanceFactor() {
        return hashBalanceFactor_ != null;
      }
      /**
       * <pre>
       * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
       * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
       * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
       * Minimum is 100.
       * Applies to both Ring Hash and Maglev load balancers.
       * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
       * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
       * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
       * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
       * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
       * cascading overflow effect when choosing the next host in the ring/table).
       * If weights are specified on the hosts, they are respected.
       * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
       * being probed, so use a higher value if you require better performance.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
       * @return The hashBalanceFactor.
       */
      @java.lang.Override
      public com.google.protobuf.UInt32Value getHashBalanceFactor() {
        return hashBalanceFactor_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : hashBalanceFactor_;
      }
      /**
       * <pre>
       * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
       * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
       * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
       * Minimum is 100.
       * Applies to both Ring Hash and Maglev load balancers.
       * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
       * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
       * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
       * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
       * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
       * cascading overflow effect when choosing the next host in the ring/table).
       * If weights are specified on the hosts, they are respected.
       * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
       * being probed, so use a higher value if you require better performance.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
       */
      @java.lang.Override
      public com.google.protobuf.UInt32ValueOrBuilder getHashBalanceFactorOrBuilder() {
        return getHashBalanceFactor();
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (useHostnameForHashing_ != false) {
          output.writeBool(1, useHostnameForHashing_);
        }
        if (hashBalanceFactor_ != null) {
          output.writeMessage(2, getHashBalanceFactor());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (useHostnameForHashing_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, useHostnameForHashing_);
        }
        if (hashBalanceFactor_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getHashBalanceFactor());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)) {
          return super.equals(obj);
        }
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig) obj;

        if (getUseHostnameForHashing()
            != other.getUseHostnameForHashing()) return false;
        if (hasHashBalanceFactor() != other.hasHashBalanceFactor()) return false;
        if (hasHashBalanceFactor()) {
          if (!getHashBalanceFactor()
              .equals(other.getHashBalanceFactor())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + USE_HOSTNAME_FOR_HASHING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseHostnameForHashing());
        if (hasHashBalanceFactor()) {
          hash = (37 * hash) + HASH_BALANCE_FACTOR_FIELD_NUMBER;
          hash = (53 * hash) + getHashBalanceFactor().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ConsistentHashingLbConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ConsistentHashingLbConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder.class);
        }

        // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          useHostnameForHashing_ = false;

          if (hashBalanceFactorBuilder_ == null) {
            hashBalanceFactor_ = null;
          } else {
            hashBalanceFactor_ = null;
            hashBalanceFactorBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_ConsistentHashingLbConfig_descriptor;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig getDefaultInstanceForType() {
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.getDefaultInstance();
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig build() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig buildPartial() {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig(this);
          result.useHostnameForHashing_ = useHostnameForHashing_;
          if (hashBalanceFactorBuilder_ == null) {
            result.hashBalanceFactor_ = hashBalanceFactor_;
          } else {
            result.hashBalanceFactor_ = hashBalanceFactorBuilder_.build();
          }
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig) {
            return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig other) {
          if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.getDefaultInstance()) return this;
          if (other.getUseHostnameForHashing() != false) {
            setUseHostnameForHashing(other.getUseHostnameForHashing());
          }
          if (other.hasHashBalanceFactor()) {
            mergeHashBalanceFactor(other.getHashBalanceFactor());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private boolean useHostnameForHashing_ ;
        /**
         * <pre>
         * If set to `true`, the cluster will use hostname instead of the resolved
         * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
         * </pre>
         *
         * <code>bool use_hostname_for_hashing = 1;</code>
         * @return The useHostnameForHashing.
         */
        @java.lang.Override
        public boolean getUseHostnameForHashing() {
          return useHostnameForHashing_;
        }
        /**
         * <pre>
         * If set to `true`, the cluster will use hostname instead of the resolved
         * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
         * </pre>
         *
         * <code>bool use_hostname_for_hashing = 1;</code>
         * @param value The useHostnameForHashing to set.
         * @return This builder for chaining.
         */
        public Builder setUseHostnameForHashing(boolean value) {
          
          useHostnameForHashing_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set to `true`, the cluster will use hostname instead of the resolved
         * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
         * </pre>
         *
         * <code>bool use_hostname_for_hashing = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearUseHostnameForHashing() {
          
          useHostnameForHashing_ = false;
          onChanged();
          return this;
        }

        private com.google.protobuf.UInt32Value hashBalanceFactor_;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> hashBalanceFactorBuilder_;
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         * @return Whether the hashBalanceFactor field is set.
         */
        public boolean hasHashBalanceFactor() {
          return hashBalanceFactorBuilder_ != null || hashBalanceFactor_ != null;
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         * @return The hashBalanceFactor.
         */
        public com.google.protobuf.UInt32Value getHashBalanceFactor() {
          if (hashBalanceFactorBuilder_ == null) {
            return hashBalanceFactor_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : hashBalanceFactor_;
          } else {
            return hashBalanceFactorBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder setHashBalanceFactor(com.google.protobuf.UInt32Value value) {
          if (hashBalanceFactorBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            hashBalanceFactor_ = value;
            onChanged();
          } else {
            hashBalanceFactorBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder setHashBalanceFactor(
            com.google.protobuf.UInt32Value.Builder builderForValue) {
          if (hashBalanceFactorBuilder_ == null) {
            hashBalanceFactor_ = builderForValue.build();
            onChanged();
          } else {
            hashBalanceFactorBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder mergeHashBalanceFactor(com.google.protobuf.UInt32Value value) {
          if (hashBalanceFactorBuilder_ == null) {
            if (hashBalanceFactor_ != null) {
              hashBalanceFactor_ =
                com.google.protobuf.UInt32Value.newBuilder(hashBalanceFactor_).mergeFrom(value).buildPartial();
            } else {
              hashBalanceFactor_ = value;
            }
            onChanged();
          } else {
            hashBalanceFactorBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder clearHashBalanceFactor() {
          if (hashBalanceFactorBuilder_ == null) {
            hashBalanceFactor_ = null;
            onChanged();
          } else {
            hashBalanceFactor_ = null;
            hashBalanceFactorBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        public com.google.protobuf.UInt32Value.Builder getHashBalanceFactorBuilder() {
          
          onChanged();
          return getHashBalanceFactorFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        public com.google.protobuf.UInt32ValueOrBuilder getHashBalanceFactorOrBuilder() {
          if (hashBalanceFactorBuilder_ != null) {
            return hashBalanceFactorBuilder_.getMessageOrBuilder();
          } else {
            return hashBalanceFactor_ == null ?
                com.google.protobuf.UInt32Value.getDefaultInstance() : hashBalanceFactor_;
          }
        }
        /**
         * <pre>
         * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
         * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
         * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
         * Minimum is 100.
         * Applies to both Ring Hash and Maglev load balancers.
         * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
         * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
         * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
         * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
         * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
         * cascading overflow effect when choosing the next host in the ring/table).
         * If weights are specified on the hosts, they are respected.
         * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
         * being probed, so use a higher value if you require better performance.
         * </pre>
         *
         * <code>.google.protobuf.UInt32Value hash_balance_factor = 2 [(.validate.rules) = { ... }</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
            getHashBalanceFactorFieldBuilder() {
          if (hashBalanceFactorBuilder_ == null) {
            hashBalanceFactorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                    getHashBalanceFactor(),
                    getParentForChildren(),
                    isClean());
            hashBalanceFactor_ = null;
          }
          return hashBalanceFactorBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)
      }

      // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig)
      private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig();
      }

      public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ConsistentHashingLbConfig>
          PARSER = new com.google.protobuf.AbstractParser<ConsistentHashingLbConfig>() {
        @java.lang.Override
        public ConsistentHashingLbConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new ConsistentHashingLbConfig(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<ConsistentHashingLbConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ConsistentHashingLbConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int localityConfigSpecifierCase_ = 0;
    private java.lang.Object localityConfigSpecifier_;
    public enum LocalityConfigSpecifierCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      ZONE_AWARE_LB_CONFIG(2),
      LOCALITY_WEIGHTED_LB_CONFIG(3),
      LOCALITYCONFIGSPECIFIER_NOT_SET(0);
      private final int value;
      private LocalityConfigSpecifierCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LocalityConfigSpecifierCase valueOf(int value) {
        return forNumber(value);
      }

      public static LocalityConfigSpecifierCase forNumber(int value) {
        switch (value) {
          case 2: return ZONE_AWARE_LB_CONFIG;
          case 3: return LOCALITY_WEIGHTED_LB_CONFIG;
          case 0: return LOCALITYCONFIGSPECIFIER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public LocalityConfigSpecifierCase
    getLocalityConfigSpecifierCase() {
      return LocalityConfigSpecifierCase.forNumber(
          localityConfigSpecifierCase_);
    }

    public static final int HEALTHY_PANIC_THRESHOLD_FIELD_NUMBER = 1;
    private io.envoyproxy.envoy.type.v3.Percent healthyPanicThreshold_;
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
     * @return Whether the healthyPanicThreshold field is set.
     */
    @java.lang.Override
    public boolean hasHealthyPanicThreshold() {
      return healthyPanicThreshold_ != null;
    }
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
     * @return The healthyPanicThreshold.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getHealthyPanicThreshold() {
      return healthyPanicThreshold_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : healthyPanicThreshold_;
    }
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getHealthyPanicThresholdOrBuilder() {
      return getHealthyPanicThreshold();
    }

    public static final int ZONE_AWARE_LB_CONFIG_FIELD_NUMBER = 2;
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     * @return Whether the zoneAwareLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasZoneAwareLbConfig() {
      return localityConfigSpecifierCase_ == 2;
    }
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     * @return The zoneAwareLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig getZoneAwareLbConfig() {
      if (localityConfigSpecifierCase_ == 2) {
         return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
      }
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
    }
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder getZoneAwareLbConfigOrBuilder() {
      if (localityConfigSpecifierCase_ == 2) {
         return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
      }
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
    }

    public static final int LOCALITY_WEIGHTED_LB_CONFIG_FIELD_NUMBER = 3;
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     * @return Whether the localityWeightedLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasLocalityWeightedLbConfig() {
      return localityConfigSpecifierCase_ == 3;
    }
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     * @return The localityWeightedLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig getLocalityWeightedLbConfig() {
      if (localityConfigSpecifierCase_ == 3) {
         return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
      }
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
    }
    /**
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder getLocalityWeightedLbConfigOrBuilder() {
      if (localityConfigSpecifierCase_ == 3) {
         return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
      }
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
    }

    public static final int UPDATE_MERGE_WINDOW_FIELD_NUMBER = 4;
    private com.google.protobuf.Duration updateMergeWindow_;
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     * @return Whether the updateMergeWindow field is set.
     */
    @java.lang.Override
    public boolean hasUpdateMergeWindow() {
      return updateMergeWindow_ != null;
    }
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     * @return The updateMergeWindow.
     */
    @java.lang.Override
    public com.google.protobuf.Duration getUpdateMergeWindow() {
      return updateMergeWindow_ == null ? com.google.protobuf.Duration.getDefaultInstance() : updateMergeWindow_;
    }
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DurationOrBuilder getUpdateMergeWindowOrBuilder() {
      return getUpdateMergeWindow();
    }

    public static final int IGNORE_NEW_HOSTS_UNTIL_FIRST_HC_FIELD_NUMBER = 5;
    private boolean ignoreNewHostsUntilFirstHc_;
    /**
     * <pre>
     * If set to true, Envoy will not consider new hosts when computing load balancing weights until
     * they have been health checked for the first time. This will have no effect unless
     * active health checking is also configured.
     * Ignoring a host means that for any load balancing calculations that adjust weights based
     * on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
     * panic mode) Envoy will exclude these hosts in the denominator.
     * For example, with hosts in two priorities P0 and P1, where P0 looks like
     * {healthy, unhealthy (new), unhealthy (new)}
     * and where P1 looks like
     * {healthy, healthy}
     * all traffic will still hit P0, as 1 / (3 - 2) = 1.
     * Enabling this will allow scaling up the number of hosts for a given cluster without entering
     * panic mode or triggering priority spillover, assuming the hosts pass the first health check.
     * If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
     * contribute to the calculation when deciding whether panic mode is enabled or not.
     * </pre>
     *
     * <code>bool ignore_new_hosts_until_first_hc = 5;</code>
     * @return The ignoreNewHostsUntilFirstHc.
     */
    @java.lang.Override
    public boolean getIgnoreNewHostsUntilFirstHc() {
      return ignoreNewHostsUntilFirstHc_;
    }

    public static final int CLOSE_CONNECTIONS_ON_HOST_SET_CHANGE_FIELD_NUMBER = 6;
    private boolean closeConnectionsOnHostSetChange_;
    /**
     * <pre>
     * If set to `true`, the cluster manager will drain all existing
     * connections to upstream hosts whenever hosts are added or removed from the cluster.
     * </pre>
     *
     * <code>bool close_connections_on_host_set_change = 6;</code>
     * @return The closeConnectionsOnHostSetChange.
     */
    @java.lang.Override
    public boolean getCloseConnectionsOnHostSetChange() {
      return closeConnectionsOnHostSetChange_;
    }

    public static final int CONSISTENT_HASHING_LB_CONFIG_FIELD_NUMBER = 7;
    private io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistentHashingLbConfig_;
    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
     * @return Whether the consistentHashingLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasConsistentHashingLbConfig() {
      return consistentHashingLbConfig_ != null;
    }
    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
     * @return The consistentHashingLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig getConsistentHashingLbConfig() {
      return consistentHashingLbConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.getDefaultInstance() : consistentHashingLbConfig_;
    }
    /**
     * <pre>
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder getConsistentHashingLbConfigOrBuilder() {
      return getConsistentHashingLbConfig();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (healthyPanicThreshold_ != null) {
        output.writeMessage(1, getHealthyPanicThreshold());
      }
      if (localityConfigSpecifierCase_ == 2) {
        output.writeMessage(2, (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_);
      }
      if (localityConfigSpecifierCase_ == 3) {
        output.writeMessage(3, (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_);
      }
      if (updateMergeWindow_ != null) {
        output.writeMessage(4, getUpdateMergeWindow());
      }
      if (ignoreNewHostsUntilFirstHc_ != false) {
        output.writeBool(5, ignoreNewHostsUntilFirstHc_);
      }
      if (closeConnectionsOnHostSetChange_ != false) {
        output.writeBool(6, closeConnectionsOnHostSetChange_);
      }
      if (consistentHashingLbConfig_ != null) {
        output.writeMessage(7, getConsistentHashingLbConfig());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (healthyPanicThreshold_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getHealthyPanicThreshold());
      }
      if (localityConfigSpecifierCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_);
      }
      if (localityConfigSpecifierCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_);
      }
      if (updateMergeWindow_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdateMergeWindow());
      }
      if (ignoreNewHostsUntilFirstHc_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, ignoreNewHostsUntilFirstHc_);
      }
      if (closeConnectionsOnHostSetChange_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, closeConnectionsOnHostSetChange_);
      }
      if (consistentHashingLbConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getConsistentHashingLbConfig());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig) obj;

      if (hasHealthyPanicThreshold() != other.hasHealthyPanicThreshold()) return false;
      if (hasHealthyPanicThreshold()) {
        if (!getHealthyPanicThreshold()
            .equals(other.getHealthyPanicThreshold())) return false;
      }
      if (hasUpdateMergeWindow() != other.hasUpdateMergeWindow()) return false;
      if (hasUpdateMergeWindow()) {
        if (!getUpdateMergeWindow()
            .equals(other.getUpdateMergeWindow())) return false;
      }
      if (getIgnoreNewHostsUntilFirstHc()
          != other.getIgnoreNewHostsUntilFirstHc()) return false;
      if (getCloseConnectionsOnHostSetChange()
          != other.getCloseConnectionsOnHostSetChange()) return false;
      if (hasConsistentHashingLbConfig() != other.hasConsistentHashingLbConfig()) return false;
      if (hasConsistentHashingLbConfig()) {
        if (!getConsistentHashingLbConfig()
            .equals(other.getConsistentHashingLbConfig())) return false;
      }
      if (!getLocalityConfigSpecifierCase().equals(other.getLocalityConfigSpecifierCase())) return false;
      switch (localityConfigSpecifierCase_) {
        case 2:
          if (!getZoneAwareLbConfig()
              .equals(other.getZoneAwareLbConfig())) return false;
          break;
        case 3:
          if (!getLocalityWeightedLbConfig()
              .equals(other.getLocalityWeightedLbConfig())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHealthyPanicThreshold()) {
        hash = (37 * hash) + HEALTHY_PANIC_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + getHealthyPanicThreshold().hashCode();
      }
      if (hasUpdateMergeWindow()) {
        hash = (37 * hash) + UPDATE_MERGE_WINDOW_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateMergeWindow().hashCode();
      }
      hash = (37 * hash) + IGNORE_NEW_HOSTS_UNTIL_FIRST_HC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getIgnoreNewHostsUntilFirstHc());
      hash = (37 * hash) + CLOSE_CONNECTIONS_ON_HOST_SET_CHANGE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getCloseConnectionsOnHostSetChange());
      if (hasConsistentHashingLbConfig()) {
        hash = (37 * hash) + CONSISTENT_HASHING_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getConsistentHashingLbConfig().hashCode();
      }
      switch (localityConfigSpecifierCase_) {
        case 2:
          hash = (37 * hash) + ZONE_AWARE_LB_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getZoneAwareLbConfig().hashCode();
          break;
        case 3:
          hash = (37 * hash) + LOCALITY_WEIGHTED_LB_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getLocalityWeightedLbConfig().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * [#next-free-field: 8]
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.CommonLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.CommonLbConfig)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThreshold_ = null;
        } else {
          healthyPanicThreshold_ = null;
          healthyPanicThresholdBuilder_ = null;
        }
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindow_ = null;
        } else {
          updateMergeWindow_ = null;
          updateMergeWindowBuilder_ = null;
        }
        ignoreNewHostsUntilFirstHc_ = false;

        closeConnectionsOnHostSetChange_ = false;

        if (consistentHashingLbConfigBuilder_ == null) {
          consistentHashingLbConfig_ = null;
        } else {
          consistentHashingLbConfig_ = null;
          consistentHashingLbConfigBuilder_ = null;
        }
        localityConfigSpecifierCase_ = 0;
        localityConfigSpecifier_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_CommonLbConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig(this);
        if (healthyPanicThresholdBuilder_ == null) {
          result.healthyPanicThreshold_ = healthyPanicThreshold_;
        } else {
          result.healthyPanicThreshold_ = healthyPanicThresholdBuilder_.build();
        }
        if (localityConfigSpecifierCase_ == 2) {
          if (zoneAwareLbConfigBuilder_ == null) {
            result.localityConfigSpecifier_ = localityConfigSpecifier_;
          } else {
            result.localityConfigSpecifier_ = zoneAwareLbConfigBuilder_.build();
          }
        }
        if (localityConfigSpecifierCase_ == 3) {
          if (localityWeightedLbConfigBuilder_ == null) {
            result.localityConfigSpecifier_ = localityConfigSpecifier_;
          } else {
            result.localityConfigSpecifier_ = localityWeightedLbConfigBuilder_.build();
          }
        }
        if (updateMergeWindowBuilder_ == null) {
          result.updateMergeWindow_ = updateMergeWindow_;
        } else {
          result.updateMergeWindow_ = updateMergeWindowBuilder_.build();
        }
        result.ignoreNewHostsUntilFirstHc_ = ignoreNewHostsUntilFirstHc_;
        result.closeConnectionsOnHostSetChange_ = closeConnectionsOnHostSetChange_;
        if (consistentHashingLbConfigBuilder_ == null) {
          result.consistentHashingLbConfig_ = consistentHashingLbConfig_;
        } else {
          result.consistentHashingLbConfig_ = consistentHashingLbConfigBuilder_.build();
        }
        result.localityConfigSpecifierCase_ = localityConfigSpecifierCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.getDefaultInstance()) return this;
        if (other.hasHealthyPanicThreshold()) {
          mergeHealthyPanicThreshold(other.getHealthyPanicThreshold());
        }
        if (other.hasUpdateMergeWindow()) {
          mergeUpdateMergeWindow(other.getUpdateMergeWindow());
        }
        if (other.getIgnoreNewHostsUntilFirstHc() != false) {
          setIgnoreNewHostsUntilFirstHc(other.getIgnoreNewHostsUntilFirstHc());
        }
        if (other.getCloseConnectionsOnHostSetChange() != false) {
          setCloseConnectionsOnHostSetChange(other.getCloseConnectionsOnHostSetChange());
        }
        if (other.hasConsistentHashingLbConfig()) {
          mergeConsistentHashingLbConfig(other.getConsistentHashingLbConfig());
        }
        switch (other.getLocalityConfigSpecifierCase()) {
          case ZONE_AWARE_LB_CONFIG: {
            mergeZoneAwareLbConfig(other.getZoneAwareLbConfig());
            break;
          }
          case LOCALITY_WEIGHTED_LB_CONFIG: {
            mergeLocalityWeightedLbConfig(other.getLocalityWeightedLbConfig());
            break;
          }
          case LOCALITYCONFIGSPECIFIER_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int localityConfigSpecifierCase_ = 0;
      private java.lang.Object localityConfigSpecifier_;
      public LocalityConfigSpecifierCase
          getLocalityConfigSpecifierCase() {
        return LocalityConfigSpecifierCase.forNumber(
            localityConfigSpecifierCase_);
      }

      public Builder clearLocalityConfigSpecifier() {
        localityConfigSpecifierCase_ = 0;
        localityConfigSpecifier_ = null;
        onChanged();
        return this;
      }


      private io.envoyproxy.envoy.type.v3.Percent healthyPanicThreshold_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> healthyPanicThresholdBuilder_;
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       * @return Whether the healthyPanicThreshold field is set.
       */
      public boolean hasHealthyPanicThreshold() {
        return healthyPanicThresholdBuilder_ != null || healthyPanicThreshold_ != null;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       * @return The healthyPanicThreshold.
       */
      public io.envoyproxy.envoy.type.v3.Percent getHealthyPanicThreshold() {
        if (healthyPanicThresholdBuilder_ == null) {
          return healthyPanicThreshold_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : healthyPanicThreshold_;
        } else {
          return healthyPanicThresholdBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder setHealthyPanicThreshold(io.envoyproxy.envoy.type.v3.Percent value) {
        if (healthyPanicThresholdBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          healthyPanicThreshold_ = value;
          onChanged();
        } else {
          healthyPanicThresholdBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder setHealthyPanicThreshold(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThreshold_ = builderForValue.build();
          onChanged();
        } else {
          healthyPanicThresholdBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder mergeHealthyPanicThreshold(io.envoyproxy.envoy.type.v3.Percent value) {
        if (healthyPanicThresholdBuilder_ == null) {
          if (healthyPanicThreshold_ != null) {
            healthyPanicThreshold_ =
              io.envoyproxy.envoy.type.v3.Percent.newBuilder(healthyPanicThreshold_).mergeFrom(value).buildPartial();
          } else {
            healthyPanicThreshold_ = value;
          }
          onChanged();
        } else {
          healthyPanicThresholdBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder clearHealthyPanicThreshold() {
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThreshold_ = null;
          onChanged();
        } else {
          healthyPanicThreshold_ = null;
          healthyPanicThresholdBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getHealthyPanicThresholdBuilder() {
        
        onChanged();
        return getHealthyPanicThresholdFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getHealthyPanicThresholdOrBuilder() {
        if (healthyPanicThresholdBuilder_ != null) {
          return healthyPanicThresholdBuilder_.getMessageOrBuilder();
        } else {
          return healthyPanicThreshold_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : healthyPanicThreshold_;
        }
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * To disable panic mode, set to 0%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.v3.Percent healthy_panic_threshold = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getHealthyPanicThresholdFieldBuilder() {
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThresholdBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getHealthyPanicThreshold(),
                  getParentForChildren(),
                  isClean());
          healthyPanicThreshold_ = null;
        }
        return healthyPanicThresholdBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder> zoneAwareLbConfigBuilder_;
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       * @return Whether the zoneAwareLbConfig field is set.
       */
      @java.lang.Override
      public boolean hasZoneAwareLbConfig() {
        return localityConfigSpecifierCase_ == 2;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       * @return The zoneAwareLbConfig.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig getZoneAwareLbConfig() {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 2) {
            return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
          }
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            return zoneAwareLbConfigBuilder_.getMessage();
          }
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder setZoneAwareLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig value) {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          localityConfigSpecifier_ = value;
          onChanged();
        } else {
          zoneAwareLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder setZoneAwareLbConfig(
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder builderForValue) {
        if (zoneAwareLbConfigBuilder_ == null) {
          localityConfigSpecifier_ = builderForValue.build();
          onChanged();
        } else {
          zoneAwareLbConfigBuilder_.setMessage(builderForValue.build());
        }
        localityConfigSpecifierCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder mergeZoneAwareLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig value) {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 2 &&
              localityConfigSpecifier_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance()) {
            localityConfigSpecifier_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_)
                .mergeFrom(value).buildPartial();
          } else {
            localityConfigSpecifier_ = value;
          }
          onChanged();
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            zoneAwareLbConfigBuilder_.mergeFrom(value);
          }
          zoneAwareLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder clearZoneAwareLbConfig() {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 2) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
            onChanged();
          }
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
          }
          zoneAwareLbConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder getZoneAwareLbConfigBuilder() {
        return getZoneAwareLbConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder getZoneAwareLbConfigOrBuilder() {
        if ((localityConfigSpecifierCase_ == 2) && (zoneAwareLbConfigBuilder_ != null)) {
          return zoneAwareLbConfigBuilder_.getMessageOrBuilder();
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
          }
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder> 
          getZoneAwareLbConfigFieldBuilder() {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (!(localityConfigSpecifierCase_ == 2)) {
            localityConfigSpecifier_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
          }
          zoneAwareLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder>(
                  (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_,
                  getParentForChildren(),
                  isClean());
          localityConfigSpecifier_ = null;
        }
        localityConfigSpecifierCase_ = 2;
        onChanged();;
        return zoneAwareLbConfigBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder> localityWeightedLbConfigBuilder_;
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       * @return Whether the localityWeightedLbConfig field is set.
       */
      @java.lang.Override
      public boolean hasLocalityWeightedLbConfig() {
        return localityConfigSpecifierCase_ == 3;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       * @return The localityWeightedLbConfig.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig getLocalityWeightedLbConfig() {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 3) {
            return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
          }
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            return localityWeightedLbConfigBuilder_.getMessage();
          }
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder setLocalityWeightedLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig value) {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          localityConfigSpecifier_ = value;
          onChanged();
        } else {
          localityWeightedLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder setLocalityWeightedLbConfig(
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder builderForValue) {
        if (localityWeightedLbConfigBuilder_ == null) {
          localityConfigSpecifier_ = builderForValue.build();
          onChanged();
        } else {
          localityWeightedLbConfigBuilder_.setMessage(builderForValue.build());
        }
        localityConfigSpecifierCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder mergeLocalityWeightedLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig value) {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 3 &&
              localityConfigSpecifier_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance()) {
            localityConfigSpecifier_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_)
                .mergeFrom(value).buildPartial();
          } else {
            localityConfigSpecifier_ = value;
          }
          onChanged();
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            localityWeightedLbConfigBuilder_.mergeFrom(value);
          }
          localityWeightedLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder clearLocalityWeightedLbConfig() {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 3) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
            onChanged();
          }
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
          }
          localityWeightedLbConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder getLocalityWeightedLbConfigBuilder() {
        return getLocalityWeightedLbConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder getLocalityWeightedLbConfigOrBuilder() {
        if ((localityConfigSpecifierCase_ == 3) && (localityWeightedLbConfigBuilder_ != null)) {
          return localityWeightedLbConfigBuilder_.getMessageOrBuilder();
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
          }
          return io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder> 
          getLocalityWeightedLbConfigFieldBuilder() {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (!(localityConfigSpecifierCase_ == 3)) {
            localityConfigSpecifier_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
          }
          localityWeightedLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder>(
                  (io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_,
                  getParentForChildren(),
                  isClean());
          localityConfigSpecifier_ = null;
        }
        localityConfigSpecifierCase_ = 3;
        onChanged();;
        return localityWeightedLbConfigBuilder_;
      }

      private com.google.protobuf.Duration updateMergeWindow_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> updateMergeWindowBuilder_;
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       * @return Whether the updateMergeWindow field is set.
       */
      public boolean hasUpdateMergeWindow() {
        return updateMergeWindowBuilder_ != null || updateMergeWindow_ != null;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       * @return The updateMergeWindow.
       */
      public com.google.protobuf.Duration getUpdateMergeWindow() {
        if (updateMergeWindowBuilder_ == null) {
          return updateMergeWindow_ == null ? com.google.protobuf.Duration.getDefaultInstance() : updateMergeWindow_;
        } else {
          return updateMergeWindowBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder setUpdateMergeWindow(com.google.protobuf.Duration value) {
        if (updateMergeWindowBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          updateMergeWindow_ = value;
          onChanged();
        } else {
          updateMergeWindowBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder setUpdateMergeWindow(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindow_ = builderForValue.build();
          onChanged();
        } else {
          updateMergeWindowBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder mergeUpdateMergeWindow(com.google.protobuf.Duration value) {
        if (updateMergeWindowBuilder_ == null) {
          if (updateMergeWindow_ != null) {
            updateMergeWindow_ =
              com.google.protobuf.Duration.newBuilder(updateMergeWindow_).mergeFrom(value).buildPartial();
          } else {
            updateMergeWindow_ = value;
          }
          onChanged();
        } else {
          updateMergeWindowBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder clearUpdateMergeWindow() {
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindow_ = null;
          onChanged();
        } else {
          updateMergeWindow_ = null;
          updateMergeWindowBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public com.google.protobuf.Duration.Builder getUpdateMergeWindowBuilder() {
        
        onChanged();
        return getUpdateMergeWindowFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public com.google.protobuf.DurationOrBuilder getUpdateMergeWindowOrBuilder() {
        if (updateMergeWindowBuilder_ != null) {
          return updateMergeWindowBuilder_.getMessageOrBuilder();
        } else {
          return updateMergeWindow_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : updateMergeWindow_;
        }
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster). Please always keep in mind that the use of sandbox technologies may change this
       * behavior.
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getUpdateMergeWindowFieldBuilder() {
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindowBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getUpdateMergeWindow(),
                  getParentForChildren(),
                  isClean());
          updateMergeWindow_ = null;
        }
        return updateMergeWindowBuilder_;
      }

      private boolean ignoreNewHostsUntilFirstHc_ ;
      /**
       * <pre>
       * If set to true, Envoy will not consider new hosts when computing load balancing weights until
       * they have been health checked for the first time. This will have no effect unless
       * active health checking is also configured.
       * Ignoring a host means that for any load balancing calculations that adjust weights based
       * on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
       * panic mode) Envoy will exclude these hosts in the denominator.
       * For example, with hosts in two priorities P0 and P1, where P0 looks like
       * {healthy, unhealthy (new), unhealthy (new)}
       * and where P1 looks like
       * {healthy, healthy}
       * all traffic will still hit P0, as 1 / (3 - 2) = 1.
       * Enabling this will allow scaling up the number of hosts for a given cluster without entering
       * panic mode or triggering priority spillover, assuming the hosts pass the first health check.
       * If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
       * contribute to the calculation when deciding whether panic mode is enabled or not.
       * </pre>
       *
       * <code>bool ignore_new_hosts_until_first_hc = 5;</code>
       * @return The ignoreNewHostsUntilFirstHc.
       */
      @java.lang.Override
      public boolean getIgnoreNewHostsUntilFirstHc() {
        return ignoreNewHostsUntilFirstHc_;
      }
      /**
       * <pre>
       * If set to true, Envoy will not consider new hosts when computing load balancing weights until
       * they have been health checked for the first time. This will have no effect unless
       * active health checking is also configured.
       * Ignoring a host means that for any load balancing calculations that adjust weights based
       * on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
       * panic mode) Envoy will exclude these hosts in the denominator.
       * For example, with hosts in two priorities P0 and P1, where P0 looks like
       * {healthy, unhealthy (new), unhealthy (new)}
       * and where P1 looks like
       * {healthy, healthy}
       * all traffic will still hit P0, as 1 / (3 - 2) = 1.
       * Enabling this will allow scaling up the number of hosts for a given cluster without entering
       * panic mode or triggering priority spillover, assuming the hosts pass the first health check.
       * If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
       * contribute to the calculation when deciding whether panic mode is enabled or not.
       * </pre>
       *
       * <code>bool ignore_new_hosts_until_first_hc = 5;</code>
       * @param value The ignoreNewHostsUntilFirstHc to set.
       * @return This builder for chaining.
       */
      public Builder setIgnoreNewHostsUntilFirstHc(boolean value) {
        
        ignoreNewHostsUntilFirstHc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set to true, Envoy will not consider new hosts when computing load balancing weights until
       * they have been health checked for the first time. This will have no effect unless
       * active health checking is also configured.
       * Ignoring a host means that for any load balancing calculations that adjust weights based
       * on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
       * panic mode) Envoy will exclude these hosts in the denominator.
       * For example, with hosts in two priorities P0 and P1, where P0 looks like
       * {healthy, unhealthy (new), unhealthy (new)}
       * and where P1 looks like
       * {healthy, healthy}
       * all traffic will still hit P0, as 1 / (3 - 2) = 1.
       * Enabling this will allow scaling up the number of hosts for a given cluster without entering
       * panic mode or triggering priority spillover, assuming the hosts pass the first health check.
       * If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
       * contribute to the calculation when deciding whether panic mode is enabled or not.
       * </pre>
       *
       * <code>bool ignore_new_hosts_until_first_hc = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearIgnoreNewHostsUntilFirstHc() {
        
        ignoreNewHostsUntilFirstHc_ = false;
        onChanged();
        return this;
      }

      private boolean closeConnectionsOnHostSetChange_ ;
      /**
       * <pre>
       * If set to `true`, the cluster manager will drain all existing
       * connections to upstream hosts whenever hosts are added or removed from the cluster.
       * </pre>
       *
       * <code>bool close_connections_on_host_set_change = 6;</code>
       * @return The closeConnectionsOnHostSetChange.
       */
      @java.lang.Override
      public boolean getCloseConnectionsOnHostSetChange() {
        return closeConnectionsOnHostSetChange_;
      }
      /**
       * <pre>
       * If set to `true`, the cluster manager will drain all existing
       * connections to upstream hosts whenever hosts are added or removed from the cluster.
       * </pre>
       *
       * <code>bool close_connections_on_host_set_change = 6;</code>
       * @param value The closeConnectionsOnHostSetChange to set.
       * @return This builder for chaining.
       */
      public Builder setCloseConnectionsOnHostSetChange(boolean value) {
        
        closeConnectionsOnHostSetChange_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set to `true`, the cluster manager will drain all existing
       * connections to upstream hosts whenever hosts are added or removed from the cluster.
       * </pre>
       *
       * <code>bool close_connections_on_host_set_change = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCloseConnectionsOnHostSetChange() {
        
        closeConnectionsOnHostSetChange_ = false;
        onChanged();
        return this;
      }

      private io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistentHashingLbConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder> consistentHashingLbConfigBuilder_;
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       * @return Whether the consistentHashingLbConfig field is set.
       */
      public boolean hasConsistentHashingLbConfig() {
        return consistentHashingLbConfigBuilder_ != null || consistentHashingLbConfig_ != null;
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       * @return The consistentHashingLbConfig.
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig getConsistentHashingLbConfig() {
        if (consistentHashingLbConfigBuilder_ == null) {
          return consistentHashingLbConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.getDefaultInstance() : consistentHashingLbConfig_;
        } else {
          return consistentHashingLbConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      public Builder setConsistentHashingLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig value) {
        if (consistentHashingLbConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          consistentHashingLbConfig_ = value;
          onChanged();
        } else {
          consistentHashingLbConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      public Builder setConsistentHashingLbConfig(
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder builderForValue) {
        if (consistentHashingLbConfigBuilder_ == null) {
          consistentHashingLbConfig_ = builderForValue.build();
          onChanged();
        } else {
          consistentHashingLbConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      public Builder mergeConsistentHashingLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig value) {
        if (consistentHashingLbConfigBuilder_ == null) {
          if (consistentHashingLbConfig_ != null) {
            consistentHashingLbConfig_ =
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.newBuilder(consistentHashingLbConfig_).mergeFrom(value).buildPartial();
          } else {
            consistentHashingLbConfig_ = value;
          }
          onChanged();
        } else {
          consistentHashingLbConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      public Builder clearConsistentHashingLbConfig() {
        if (consistentHashingLbConfigBuilder_ == null) {
          consistentHashingLbConfig_ = null;
          onChanged();
        } else {
          consistentHashingLbConfig_ = null;
          consistentHashingLbConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder getConsistentHashingLbConfigBuilder() {
        
        onChanged();
        return getConsistentHashingLbConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder getConsistentHashingLbConfigOrBuilder() {
        if (consistentHashingLbConfigBuilder_ != null) {
          return consistentHashingLbConfigBuilder_.getMessageOrBuilder();
        } else {
          return consistentHashingLbConfig_ == null ?
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.getDefaultInstance() : consistentHashingLbConfig_;
        }
      }
      /**
       * <pre>
       * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
       * </pre>
       *
       * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder> 
          getConsistentHashingLbConfigFieldBuilder() {
        if (consistentHashingLbConfigBuilder_ == null) {
          consistentHashingLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigOrBuilder>(
                  getConsistentHashingLbConfig(),
                  getParentForChildren(),
                  isClean());
          consistentHashingLbConfig_ = null;
        }
        return consistentHashingLbConfigBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.CommonLbConfig)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CommonLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<CommonLbConfig>() {
      @java.lang.Override
      public CommonLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CommonLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CommonLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CommonLbConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RefreshRateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.RefreshRate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the baseInterval field is set.
     */
    boolean hasBaseInterval();
    /**
     * <pre>
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
     * @return The baseInterval.
     */
    com.google.protobuf.Duration getBaseInterval();
    /**
     * <pre>
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.DurationOrBuilder getBaseIntervalOrBuilder();

    /**
     * <pre>
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
     * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the maxInterval field is set.
     */
    boolean hasMaxInterval();
    /**
     * <pre>
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
     * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
     * @return The maxInterval.
     */
    com.google.protobuf.Duration getMaxInterval();
    /**
     * <pre>
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
     * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.DurationOrBuilder getMaxIntervalOrBuilder();
  }
  /**
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.RefreshRate}
   */
  public static final class RefreshRate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.RefreshRate)
      RefreshRateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RefreshRate.newBuilder() to construct.
    private RefreshRate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RefreshRate() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RefreshRate();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RefreshRate(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (baseInterval_ != null) {
                subBuilder = baseInterval_.toBuilder();
              }
              baseInterval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(baseInterval_);
                baseInterval_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (maxInterval_ != null) {
                subBuilder = maxInterval_.toBuilder();
              }
              maxInterval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxInterval_);
                maxInterval_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RefreshRate_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RefreshRate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder.class);
    }

    public static final int BASE_INTERVAL_FIELD_NUMBER = 1;
    private com.google.protobuf.Duration baseInterval_;
    /**
     * <pre>
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the baseInterval field is set.
     */
    @java.lang.Override
    public boolean hasBaseInterval() {
      return baseInterval_ != null;
    }
    /**
     * <pre>
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
     * @return The baseInterval.
     */
    @java.lang.Override
    public com.google.protobuf.Duration getBaseInterval() {
      return baseInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : baseInterval_;
    }
    /**
     * <pre>
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.DurationOrBuilder getBaseIntervalOrBuilder() {
      return getBaseInterval();
    }

    public static final int MAX_INTERVAL_FIELD_NUMBER = 2;
    private com.google.protobuf.Duration maxInterval_;
    /**
     * <pre>
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
     * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the maxInterval field is set.
     */
    @java.lang.Override
    public boolean hasMaxInterval() {
      return maxInterval_ != null;
    }
    /**
     * <pre>
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
     * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
     * @return The maxInterval.
     */
    @java.lang.Override
    public com.google.protobuf.Duration getMaxInterval() {
      return maxInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxInterval_;
    }
    /**
     * <pre>
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
     * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.DurationOrBuilder getMaxIntervalOrBuilder() {
      return getMaxInterval();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (baseInterval_ != null) {
        output.writeMessage(1, getBaseInterval());
      }
      if (maxInterval_ != null) {
        output.writeMessage(2, getMaxInterval());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (baseInterval_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getBaseInterval());
      }
      if (maxInterval_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMaxInterval());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate) obj;

      if (hasBaseInterval() != other.hasBaseInterval()) return false;
      if (hasBaseInterval()) {
        if (!getBaseInterval()
            .equals(other.getBaseInterval())) return false;
      }
      if (hasMaxInterval() != other.hasMaxInterval()) return false;
      if (hasMaxInterval()) {
        if (!getMaxInterval()
            .equals(other.getMaxInterval())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasBaseInterval()) {
        hash = (37 * hash) + BASE_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getBaseInterval().hashCode();
      }
      if (hasMaxInterval()) {
        hash = (37 * hash) + MAX_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getMaxInterval().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.RefreshRate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.RefreshRate)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RefreshRate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RefreshRate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (baseIntervalBuilder_ == null) {
          baseInterval_ = null;
        } else {
          baseInterval_ = null;
          baseIntervalBuilder_ = null;
        }
        if (maxIntervalBuilder_ == null) {
          maxInterval_ = null;
        } else {
          maxInterval_ = null;
          maxIntervalBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_RefreshRate_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate(this);
        if (baseIntervalBuilder_ == null) {
          result.baseInterval_ = baseInterval_;
        } else {
          result.baseInterval_ = baseIntervalBuilder_.build();
        }
        if (maxIntervalBuilder_ == null) {
          result.maxInterval_ = maxInterval_;
        } else {
          result.maxInterval_ = maxIntervalBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.getDefaultInstance()) return this;
        if (other.hasBaseInterval()) {
          mergeBaseInterval(other.getBaseInterval());
        }
        if (other.hasMaxInterval()) {
          mergeMaxInterval(other.getMaxInterval());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.Duration baseInterval_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> baseIntervalBuilder_;
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       * @return Whether the baseInterval field is set.
       */
      public boolean hasBaseInterval() {
        return baseIntervalBuilder_ != null || baseInterval_ != null;
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       * @return The baseInterval.
       */
      public com.google.protobuf.Duration getBaseInterval() {
        if (baseIntervalBuilder_ == null) {
          return baseInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : baseInterval_;
        } else {
          return baseIntervalBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setBaseInterval(com.google.protobuf.Duration value) {
        if (baseIntervalBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          baseInterval_ = value;
          onChanged();
        } else {
          baseIntervalBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setBaseInterval(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (baseIntervalBuilder_ == null) {
          baseInterval_ = builderForValue.build();
          onChanged();
        } else {
          baseIntervalBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeBaseInterval(com.google.protobuf.Duration value) {
        if (baseIntervalBuilder_ == null) {
          if (baseInterval_ != null) {
            baseInterval_ =
              com.google.protobuf.Duration.newBuilder(baseInterval_).mergeFrom(value).buildPartial();
          } else {
            baseInterval_ = value;
          }
          onChanged();
        } else {
          baseIntervalBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearBaseInterval() {
        if (baseIntervalBuilder_ == null) {
          baseInterval_ = null;
          onChanged();
        } else {
          baseInterval_ = null;
          baseIntervalBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.Duration.Builder getBaseIntervalBuilder() {
        
        onChanged();
        return getBaseIntervalFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.DurationOrBuilder getBaseIntervalOrBuilder() {
        if (baseIntervalBuilder_ != null) {
          return baseIntervalBuilder_.getMessageOrBuilder();
        } else {
          return baseInterval_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : baseInterval_;
        }
      }
      /**
       * <pre>
       * Specifies the base interval between refreshes. This parameter is required and must be greater
       * than zero and less than
       * :ref:`max_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration base_interval = 1 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getBaseIntervalFieldBuilder() {
        if (baseIntervalBuilder_ == null) {
          baseIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getBaseInterval(),
                  getParentForChildren(),
                  isClean());
          baseInterval_ = null;
        }
        return baseIntervalBuilder_;
      }

      private com.google.protobuf.Duration maxInterval_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> maxIntervalBuilder_;
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       * @return Whether the maxInterval field is set.
       */
      public boolean hasMaxInterval() {
        return maxIntervalBuilder_ != null || maxInterval_ != null;
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       * @return The maxInterval.
       */
      public com.google.protobuf.Duration getMaxInterval() {
        if (maxIntervalBuilder_ == null) {
          return maxInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxInterval_;
        } else {
          return maxIntervalBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setMaxInterval(com.google.protobuf.Duration value) {
        if (maxIntervalBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxInterval_ = value;
          onChanged();
        } else {
          maxIntervalBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setMaxInterval(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (maxIntervalBuilder_ == null) {
          maxInterval_ = builderForValue.build();
          onChanged();
        } else {
          maxIntervalBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeMaxInterval(com.google.protobuf.Duration value) {
        if (maxIntervalBuilder_ == null) {
          if (maxInterval_ != null) {
            maxInterval_ =
              com.google.protobuf.Duration.newBuilder(maxInterval_).mergeFrom(value).buildPartial();
          } else {
            maxInterval_ = value;
          }
          onChanged();
        } else {
          maxIntervalBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder clearMaxInterval() {
        if (maxIntervalBuilder_ == null) {
          maxInterval_ = null;
          onChanged();
        } else {
          maxInterval_ = null;
          maxIntervalBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.Duration.Builder getMaxIntervalBuilder() {
        
        onChanged();
        return getMaxIntervalFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.DurationOrBuilder getMaxIntervalOrBuilder() {
        if (maxIntervalBuilder_ != null) {
          return maxIntervalBuilder_.getMessageOrBuilder();
        } else {
          return maxInterval_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : maxInterval_;
        }
      }
      /**
       * <pre>
       * Specifies the maximum interval between refreshes. This parameter is optional, but must be
       * greater than or equal to the
       * :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`  if set. The default
       * is 10 times the :ref:`base_interval &lt;envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_interval = 2 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getMaxIntervalFieldBuilder() {
        if (maxIntervalBuilder_ == null) {
          maxIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getMaxInterval(),
                  getParentForChildren(),
                  isClean());
          maxInterval_ = null;
        }
        return maxIntervalBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.RefreshRate)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.RefreshRate)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RefreshRate>
        PARSER = new com.google.protobuf.AbstractParser<RefreshRate>() {
      @java.lang.Override
      public RefreshRate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RefreshRate(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RefreshRate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RefreshRate> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PreconnectPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster.PreconnectPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy.
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
     * preconnected.
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the perUpstreamPreconnectRatio field is set.
     */
    boolean hasPerUpstreamPreconnectRatio();
    /**
     * <pre>
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy.
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
     * preconnected.
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
     * @return The perUpstreamPreconnectRatio.
     */
    com.google.protobuf.DoubleValue getPerUpstreamPreconnectRatio();
    /**
     * <pre>
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy.
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
     * preconnected.
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.DoubleValueOrBuilder getPerUpstreamPreconnectRatioOrBuilder();

    /**
     * <pre>
     * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
     * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the predictivePreconnectRatio field is set.
     */
    boolean hasPredictivePreconnectRatio();
    /**
     * <pre>
     * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
     * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
     * @return The predictivePreconnectRatio.
     */
    com.google.protobuf.DoubleValue getPredictivePreconnectRatio();
    /**
     * <pre>
     * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
     * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.DoubleValueOrBuilder getPredictivePreconnectRatioOrBuilder();
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster.PreconnectPolicy}
   */
  public static final class PreconnectPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.cluster.v3.Cluster.PreconnectPolicy)
      PreconnectPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PreconnectPolicy.newBuilder() to construct.
    private PreconnectPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PreconnectPolicy() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PreconnectPolicy();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PreconnectPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.DoubleValue.Builder subBuilder = null;
              if (perUpstreamPreconnectRatio_ != null) {
                subBuilder = perUpstreamPreconnectRatio_.toBuilder();
              }
              perUpstreamPreconnectRatio_ = input.readMessage(com.google.protobuf.DoubleValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(perUpstreamPreconnectRatio_);
                perUpstreamPreconnectRatio_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              com.google.protobuf.DoubleValue.Builder subBuilder = null;
              if (predictivePreconnectRatio_ != null) {
                subBuilder = predictivePreconnectRatio_.toBuilder();
              }
              predictivePreconnectRatio_ = input.readMessage(com.google.protobuf.DoubleValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(predictivePreconnectRatio_);
                predictivePreconnectRatio_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_PreconnectPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_PreconnectPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder.class);
    }

    public static final int PER_UPSTREAM_PRECONNECT_RATIO_FIELD_NUMBER = 1;
    private com.google.protobuf.DoubleValue perUpstreamPreconnectRatio_;
    /**
     * <pre>
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy.
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
     * preconnected.
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the perUpstreamPreconnectRatio field is set.
     */
    @java.lang.Override
    public boolean hasPerUpstreamPreconnectRatio() {
      return perUpstreamPreconnectRatio_ != null;
    }
    /**
     * <pre>
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy.
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
     * preconnected.
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
     * @return The perUpstreamPreconnectRatio.
     */
    @java.lang.Override
    public com.google.protobuf.DoubleValue getPerUpstreamPreconnectRatio() {
      return perUpstreamPreconnectRatio_ == null ? com.google.protobuf.DoubleValue.getDefaultInstance() : perUpstreamPreconnectRatio_;
    }
    /**
     * <pre>
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy.
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
     * preconnected.
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.DoubleValueOrBuilder getPerUpstreamPreconnectRatioOrBuilder() {
      return getPerUpstreamPreconnectRatio();
    }

    public static final int PREDICTIVE_PRECONNECT_RATIO_FIELD_NUMBER = 2;
    private com.google.protobuf.DoubleValue predictivePreconnectRatio_;
    /**
     * <pre>
     * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
     * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the predictivePreconnectRatio field is set.
     */
    @java.lang.Override
    public boolean hasPredictivePreconnectRatio() {
      return predictivePreconnectRatio_ != null;
    }
    /**
     * <pre>
     * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
     * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
     * @return The predictivePreconnectRatio.
     */
    @java.lang.Override
    public com.google.protobuf.DoubleValue getPredictivePreconnectRatio() {
      return predictivePreconnectRatio_ == null ? com.google.protobuf.DoubleValue.getDefaultInstance() : predictivePreconnectRatio_;
    }
    /**
     * <pre>
     * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
     * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
     * </pre>
     *
     * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.DoubleValueOrBuilder getPredictivePreconnectRatioOrBuilder() {
      return getPredictivePreconnectRatio();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (perUpstreamPreconnectRatio_ != null) {
        output.writeMessage(1, getPerUpstreamPreconnectRatio());
      }
      if (predictivePreconnectRatio_ != null) {
        output.writeMessage(2, getPredictivePreconnectRatio());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (perUpstreamPreconnectRatio_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getPerUpstreamPreconnectRatio());
      }
      if (predictivePreconnectRatio_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getPredictivePreconnectRatio());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy other = (io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy) obj;

      if (hasPerUpstreamPreconnectRatio() != other.hasPerUpstreamPreconnectRatio()) return false;
      if (hasPerUpstreamPreconnectRatio()) {
        if (!getPerUpstreamPreconnectRatio()
            .equals(other.getPerUpstreamPreconnectRatio())) return false;
      }
      if (hasPredictivePreconnectRatio() != other.hasPredictivePreconnectRatio()) return false;
      if (hasPredictivePreconnectRatio()) {
        if (!getPredictivePreconnectRatio()
            .equals(other.getPredictivePreconnectRatio())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPerUpstreamPreconnectRatio()) {
        hash = (37 * hash) + PER_UPSTREAM_PRECONNECT_RATIO_FIELD_NUMBER;
        hash = (53 * hash) + getPerUpstreamPreconnectRatio().hashCode();
      }
      if (hasPredictivePreconnectRatio()) {
        hash = (37 * hash) + PREDICTIVE_PRECONNECT_RATIO_FIELD_NUMBER;
        hash = (53 * hash) + getPredictivePreconnectRatio().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * Protobuf type {@code envoy.config.cluster.v3.Cluster.PreconnectPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster.PreconnectPolicy)
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_PreconnectPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_PreconnectPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          perUpstreamPreconnectRatio_ = null;
        } else {
          perUpstreamPreconnectRatio_ = null;
          perUpstreamPreconnectRatioBuilder_ = null;
        }
        if (predictivePreconnectRatioBuilder_ == null) {
          predictivePreconnectRatio_ = null;
        } else {
          predictivePreconnectRatio_ = null;
          predictivePreconnectRatioBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_PreconnectPolicy_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy build() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy buildPartial() {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy result = new io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy(this);
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          result.perUpstreamPreconnectRatio_ = perUpstreamPreconnectRatio_;
        } else {
          result.perUpstreamPreconnectRatio_ = perUpstreamPreconnectRatioBuilder_.build();
        }
        if (predictivePreconnectRatioBuilder_ == null) {
          result.predictivePreconnectRatio_ = predictivePreconnectRatio_;
        } else {
          result.predictivePreconnectRatio_ = predictivePreconnectRatioBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy) {
          return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy other) {
        if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.getDefaultInstance()) return this;
        if (other.hasPerUpstreamPreconnectRatio()) {
          mergePerUpstreamPreconnectRatio(other.getPerUpstreamPreconnectRatio());
        }
        if (other.hasPredictivePreconnectRatio()) {
          mergePredictivePreconnectRatio(other.getPredictivePreconnectRatio());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.DoubleValue perUpstreamPreconnectRatio_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.DoubleValue, com.google.protobuf.DoubleValue.Builder, com.google.protobuf.DoubleValueOrBuilder> perUpstreamPreconnectRatioBuilder_;
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       * @return Whether the perUpstreamPreconnectRatio field is set.
       */
      public boolean hasPerUpstreamPreconnectRatio() {
        return perUpstreamPreconnectRatioBuilder_ != null || perUpstreamPreconnectRatio_ != null;
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       * @return The perUpstreamPreconnectRatio.
       */
      public com.google.protobuf.DoubleValue getPerUpstreamPreconnectRatio() {
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          return perUpstreamPreconnectRatio_ == null ? com.google.protobuf.DoubleValue.getDefaultInstance() : perUpstreamPreconnectRatio_;
        } else {
          return perUpstreamPreconnectRatioBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setPerUpstreamPreconnectRatio(com.google.protobuf.DoubleValue value) {
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          perUpstreamPreconnectRatio_ = value;
          onChanged();
        } else {
          perUpstreamPreconnectRatioBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setPerUpstreamPreconnectRatio(
          com.google.protobuf.DoubleValue.Builder builderForValue) {
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          perUpstreamPreconnectRatio_ = builderForValue.build();
          onChanged();
        } else {
          perUpstreamPreconnectRatioBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder mergePerUpstreamPreconnectRatio(com.google.protobuf.DoubleValue value) {
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          if (perUpstreamPreconnectRatio_ != null) {
            perUpstreamPreconnectRatio_ =
              com.google.protobuf.DoubleValue.newBuilder(perUpstreamPreconnectRatio_).mergeFrom(value).buildPartial();
          } else {
            perUpstreamPreconnectRatio_ = value;
          }
          onChanged();
        } else {
          perUpstreamPreconnectRatioBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearPerUpstreamPreconnectRatio() {
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          perUpstreamPreconnectRatio_ = null;
          onChanged();
        } else {
          perUpstreamPreconnectRatio_ = null;
          perUpstreamPreconnectRatioBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.DoubleValue.Builder getPerUpstreamPreconnectRatioBuilder() {
        
        onChanged();
        return getPerUpstreamPreconnectRatioFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.DoubleValueOrBuilder getPerUpstreamPreconnectRatioOrBuilder() {
        if (perUpstreamPreconnectRatioBuilder_ != null) {
          return perUpstreamPreconnectRatioBuilder_.getMessageOrBuilder();
        } else {
          return perUpstreamPreconnectRatio_ == null ?
              com.google.protobuf.DoubleValue.getDefaultInstance() : perUpstreamPreconnectRatio_;
        }
      }
      /**
       * <pre>
       * Indicates how many streams (rounded up) can be anticipated per-upstream for each
       * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
       * will only be done if the upstream is healthy.
       * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
       * established, one for the new incoming stream, and one for a presumed follow-up stream. For
       * HTTP/2, only one connection would be established by default as one connection can
       * serve both the original and presumed follow-up stream.
       * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
       * active streams, there would be 100 connections in use, and 50 connections preconnected.
       * This might be a useful value for something like short lived single-use connections,
       * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
       * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
       * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
       * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
       * in case of unexpected disconnects where the connection could not be reused.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight. This means in steady state if a connection is torn down,
       * a subsequent streams will pay an upstream-rtt latency penalty waiting for streams to be
       * preconnected.
       * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
       * harm latency more than the preconnecting helps.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.DoubleValue, com.google.protobuf.DoubleValue.Builder, com.google.protobuf.DoubleValueOrBuilder> 
          getPerUpstreamPreconnectRatioFieldBuilder() {
        if (perUpstreamPreconnectRatioBuilder_ == null) {
          perUpstreamPreconnectRatioBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.DoubleValue, com.google.protobuf.DoubleValue.Builder, com.google.protobuf.DoubleValueOrBuilder>(
                  getPerUpstreamPreconnectRatio(),
                  getParentForChildren(),
                  isClean());
          perUpstreamPreconnectRatio_ = null;
        }
        return perUpstreamPreconnectRatioBuilder_;
      }

      private com.google.protobuf.DoubleValue predictivePreconnectRatio_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.DoubleValue, com.google.protobuf.DoubleValue.Builder, com.google.protobuf.DoubleValueOrBuilder> predictivePreconnectRatioBuilder_;
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       * @return Whether the predictivePreconnectRatio field is set.
       */
      public boolean hasPredictivePreconnectRatio() {
        return predictivePreconnectRatioBuilder_ != null || predictivePreconnectRatio_ != null;
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       * @return The predictivePreconnectRatio.
       */
      public com.google.protobuf.DoubleValue getPredictivePreconnectRatio() {
        if (predictivePreconnectRatioBuilder_ == null) {
          return predictivePreconnectRatio_ == null ? com.google.protobuf.DoubleValue.getDefaultInstance() : predictivePreconnectRatio_;
        } else {
          return predictivePreconnectRatioBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setPredictivePreconnectRatio(com.google.protobuf.DoubleValue value) {
        if (predictivePreconnectRatioBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          predictivePreconnectRatio_ = value;
          onChanged();
        } else {
          predictivePreconnectRatioBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setPredictivePreconnectRatio(
          com.google.protobuf.DoubleValue.Builder builderForValue) {
        if (predictivePreconnectRatioBuilder_ == null) {
          predictivePreconnectRatio_ = builderForValue.build();
          onChanged();
        } else {
          predictivePreconnectRatioBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder mergePredictivePreconnectRatio(com.google.protobuf.DoubleValue value) {
        if (predictivePreconnectRatioBuilder_ == null) {
          if (predictivePreconnectRatio_ != null) {
            predictivePreconnectRatio_ =
              com.google.protobuf.DoubleValue.newBuilder(predictivePreconnectRatio_).mergeFrom(value).buildPartial();
          } else {
            predictivePreconnectRatio_ = value;
          }
          onChanged();
        } else {
          predictivePreconnectRatioBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder clearPredictivePreconnectRatio() {
        if (predictivePreconnectRatioBuilder_ == null) {
          predictivePreconnectRatio_ = null;
          onChanged();
        } else {
          predictivePreconnectRatio_ = null;
          predictivePreconnectRatioBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.DoubleValue.Builder getPredictivePreconnectRatioBuilder() {
        
        onChanged();
        return getPredictivePreconnectRatioFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.DoubleValueOrBuilder getPredictivePreconnectRatioOrBuilder() {
        if (predictivePreconnectRatioBuilder_ != null) {
          return predictivePreconnectRatioBuilder_.getMessageOrBuilder();
        } else {
          return predictivePreconnectRatio_ == null ?
              com.google.protobuf.DoubleValue.getDefaultInstance() : predictivePreconnectRatio_;
        }
      }
      /**
       * <pre>
       * Indicates how many many streams (rounded up) can be anticipated across a cluster for each
       * stream, useful for low QPS services. This is currently supported for a subset of
       * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
       * Unlike per_upstream_preconnect_ratio this preconnects across the upstream instances in a
       * cluster, doing best effort predictions of what upstream would be picked next and
       * pre-establishing a connection.
       * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
       * incoming stream, 2 connections will be preconnected - one to the first upstream for this
       * cluster, one to the second on the assumption there will be a follow-up stream.
       * Preconnecting will be limited to one preconnect per configured upstream in the cluster.
       * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
       * as needed to serve streams in flight, so during warm up and in steady state if a connection
       * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
       * connection establishment.
       * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
       * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream.
       * TODO(alyssawilk) per LB docs and LB overview docs when unhiding.
       * </pre>
       *
       * <code>.google.protobuf.DoubleValue predictive_preconnect_ratio = 2 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.DoubleValue, com.google.protobuf.DoubleValue.Builder, com.google.protobuf.DoubleValueOrBuilder> 
          getPredictivePreconnectRatioFieldBuilder() {
        if (predictivePreconnectRatioBuilder_ == null) {
          predictivePreconnectRatioBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.DoubleValue, com.google.protobuf.DoubleValue.Builder, com.google.protobuf.DoubleValueOrBuilder>(
                  getPredictivePreconnectRatio(),
                  getParentForChildren(),
                  isClean());
          predictivePreconnectRatio_ = null;
        }
        return predictivePreconnectRatioBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster.PreconnectPolicy)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster.PreconnectPolicy)
    private static final io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy();
    }

    public static io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PreconnectPolicy>
        PARSER = new com.google.protobuf.AbstractParser<PreconnectPolicy>() {
      @java.lang.Override
      public PreconnectPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PreconnectPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PreconnectPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PreconnectPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int clusterDiscoveryTypeCase_ = 0;
  private java.lang.Object clusterDiscoveryType_;
  public enum ClusterDiscoveryTypeCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    TYPE(2),
    CLUSTER_TYPE(38),
    CLUSTERDISCOVERYTYPE_NOT_SET(0);
    private final int value;
    private ClusterDiscoveryTypeCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ClusterDiscoveryTypeCase valueOf(int value) {
      return forNumber(value);
    }

    public static ClusterDiscoveryTypeCase forNumber(int value) {
      switch (value) {
        case 2: return TYPE;
        case 38: return CLUSTER_TYPE;
        case 0: return CLUSTERDISCOVERYTYPE_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public ClusterDiscoveryTypeCase
  getClusterDiscoveryTypeCase() {
    return ClusterDiscoveryTypeCase.forNumber(
        clusterDiscoveryTypeCase_);
  }

  private int lbConfigCase_ = 0;
  private java.lang.Object lbConfig_;
  public enum LbConfigCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    RING_HASH_LB_CONFIG(23),
    MAGLEV_LB_CONFIG(52),
    ORIGINAL_DST_LB_CONFIG(34),
    LEAST_REQUEST_LB_CONFIG(37),
    LBCONFIG_NOT_SET(0);
    private final int value;
    private LbConfigCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LbConfigCase valueOf(int value) {
      return forNumber(value);
    }

    public static LbConfigCase forNumber(int value) {
      switch (value) {
        case 23: return RING_HASH_LB_CONFIG;
        case 52: return MAGLEV_LB_CONFIG;
        case 34: return ORIGINAL_DST_LB_CONFIG;
        case 37: return LEAST_REQUEST_LB_CONFIG;
        case 0: return LBCONFIG_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public LbConfigCase
  getLbConfigCase() {
    return LbConfigCase.forNumber(
        lbConfigCase_);
  }

  public static final int TRANSPORT_SOCKET_MATCHES_FIELD_NUMBER = 43;
  private java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch> transportSocketMatches_;
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch> getTransportSocketMatchesList() {
    return transportSocketMatches_;
  }
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder> 
      getTransportSocketMatchesOrBuilderList() {
    return transportSocketMatches_;
  }
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  @java.lang.Override
  public int getTransportSocketMatchesCount() {
    return transportSocketMatches_.size();
  }
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch getTransportSocketMatches(int index) {
    return transportSocketMatches_.get(index);
  }
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder getTransportSocketMatchesOrBuilder(
      int index) {
    return transportSocketMatches_.get(index);
  }

  public static final int NAME_FIELD_NUMBER = 1;
  private volatile java.lang.Object name_;
  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALT_STAT_NAME_FIELD_NUMBER = 28;
  private volatile java.lang.Object altStatName_;
  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   * @return The altStatName.
   */
  @java.lang.Override
  public java.lang.String getAltStatName() {
    java.lang.Object ref = altStatName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      altStatName_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   * @return The bytes for altStatName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAltStatNameBytes() {
    java.lang.Object ref = altStatName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      altStatName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int TYPE_FIELD_NUMBER = 2;
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the type field is set.
   */
  public boolean hasType() {
    return clusterDiscoveryTypeCase_ == 2;
  }
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for type.
   */
  public int getTypeValue() {
    if (clusterDiscoveryTypeCase_ == 2) {
      return (java.lang.Integer) clusterDiscoveryType_;
    }
    return 0;
  }
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return The type.
   */
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType getType() {
    if (clusterDiscoveryTypeCase_ == 2) {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType result = io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType.valueOf(
          (java.lang.Integer) clusterDiscoveryType_);
      return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType.UNRECOGNIZED : result;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType.STATIC;
  }

  public static final int CLUSTER_TYPE_FIELD_NUMBER = 38;
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
   * @return Whether the clusterType field is set.
   */
  @java.lang.Override
  public boolean hasClusterType() {
    return clusterDiscoveryTypeCase_ == 38;
  }
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
   * @return The clusterType.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType getClusterType() {
    if (clusterDiscoveryTypeCase_ == 38) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
  }
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder getClusterTypeOrBuilder() {
    if (clusterDiscoveryTypeCase_ == 38) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
  }

  public static final int EDS_CLUSTER_CONFIG_FIELD_NUMBER = 3;
  private io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig edsClusterConfig_;
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   * @return Whether the edsClusterConfig field is set.
   */
  @java.lang.Override
  public boolean hasEdsClusterConfig() {
    return edsClusterConfig_ != null;
  }
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   * @return The edsClusterConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig getEdsClusterConfig() {
    return edsClusterConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.getDefaultInstance() : edsClusterConfig_;
  }
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder getEdsClusterConfigOrBuilder() {
    return getEdsClusterConfig();
  }

  public static final int CONNECT_TIMEOUT_FIELD_NUMBER = 4;
  private com.google.protobuf.Duration connectTimeout_;
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the connectTimeout field is set.
   */
  @java.lang.Override
  public boolean hasConnectTimeout() {
    return connectTimeout_ != null;
  }
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   * @return The connectTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getConnectTimeout() {
    return connectTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : connectTimeout_;
  }
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getConnectTimeoutOrBuilder() {
    return getConnectTimeout();
  }

  public static final int PER_CONNECTION_BUFFER_LIMIT_BYTES_FIELD_NUMBER = 5;
  private com.google.protobuf.UInt32Value perConnectionBufferLimitBytes_;
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the perConnectionBufferLimitBytes field is set.
   */
  @java.lang.Override
  public boolean hasPerConnectionBufferLimitBytes() {
    return perConnectionBufferLimitBytes_ != null;
  }
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   * @return The perConnectionBufferLimitBytes.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes() {
    return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
  }
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder() {
    return getPerConnectionBufferLimitBytes();
  }

  public static final int LB_POLICY_FIELD_NUMBER = 6;
  private int lbPolicy_;
  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for lbPolicy.
   */
  @java.lang.Override public int getLbPolicyValue() {
    return lbPolicy_;
  }
  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   * @return The lbPolicy.
   */
  @java.lang.Override public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy getLbPolicy() {
    @SuppressWarnings("deprecation")
    io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy result = io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy.valueOf(lbPolicy_);
    return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy.UNRECOGNIZED : result;
  }

  public static final int LOAD_ASSIGNMENT_FIELD_NUMBER = 33;
  private io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment loadAssignment_;
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
   * @return Whether the loadAssignment field is set.
   */
  @java.lang.Override
  public boolean hasLoadAssignment() {
    return loadAssignment_ != null;
  }
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
   * @return The loadAssignment.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment getLoadAssignment() {
    return loadAssignment_ == null ? io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.getDefaultInstance() : loadAssignment_;
  }
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignmentOrBuilder getLoadAssignmentOrBuilder() {
    return getLoadAssignment();
  }

  public static final int HEALTH_CHECKS_FIELD_NUMBER = 8;
  private java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck> healthChecks_;
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck> getHealthChecksList() {
    return healthChecks_;
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder> 
      getHealthChecksOrBuilderList() {
    return healthChecks_;
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  @java.lang.Override
  public int getHealthChecksCount() {
    return healthChecks_.size();
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck getHealthChecks(int index) {
    return healthChecks_.get(index);
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder getHealthChecksOrBuilder(
      int index) {
    return healthChecks_.get(index);
  }

  public static final int MAX_REQUESTS_PER_CONNECTION_FIELD_NUMBER = 9;
  private com.google.protobuf.UInt32Value maxRequestsPerConnection_;
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   * @return Whether the maxRequestsPerConnection field is set.
   */
  @java.lang.Override
  public boolean hasMaxRequestsPerConnection() {
    return maxRequestsPerConnection_ != null;
  }
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   * @return The maxRequestsPerConnection.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getMaxRequestsPerConnection() {
    return maxRequestsPerConnection_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestsPerConnection_;
  }
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestsPerConnectionOrBuilder() {
    return getMaxRequestsPerConnection();
  }

  public static final int CIRCUIT_BREAKERS_FIELD_NUMBER = 10;
  private io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers circuitBreakers_;
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
   * @return Whether the circuitBreakers field is set.
   */
  @java.lang.Override
  public boolean hasCircuitBreakers() {
    return circuitBreakers_ != null;
  }
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
   * @return The circuitBreakers.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers getCircuitBreakers() {
    return circuitBreakers_ == null ? io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.getDefaultInstance() : circuitBreakers_;
  }
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder() {
    return getCircuitBreakers();
  }

  public static final int UPSTREAM_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 46;
  private io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions upstreamHttpProtocolOptions_;
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
   * @return Whether the upstreamHttpProtocolOptions field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasUpstreamHttpProtocolOptions() {
    return upstreamHttpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
   * @return The upstreamHttpProtocolOptions.
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions getUpstreamHttpProtocolOptions() {
    return upstreamHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.getDefaultInstance() : upstreamHttpProtocolOptions_;
  }
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptionsOrBuilder getUpstreamHttpProtocolOptionsOrBuilder() {
    return getUpstreamHttpProtocolOptions();
  }

  public static final int COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 29;
  private io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions commonHttpProtocolOptions_;
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
   * @return Whether the commonHttpProtocolOptions field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
   * @return The commonHttpProtocolOptions.
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
    return getCommonHttpProtocolOptions();
  }

  public static final int HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 13;
  private io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions httpProtocolOptions_;
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
   * @return Whether the httpProtocolOptions field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasHttpProtocolOptions() {
    return httpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
   * @return The httpProtocolOptions.
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions() {
    return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
    return getHttpProtocolOptions();
  }

  public static final int HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER = 14;
  private io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions http2ProtocolOptions_;
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
   * @return Whether the http2ProtocolOptions field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasHttp2ProtocolOptions() {
    return http2ProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
   * @return The http2ProtocolOptions.
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions() {
    return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
  }
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
    return getHttp2ProtocolOptions();
  }

  public static final int TYPED_EXTENSION_PROTOCOL_OPTIONS_FIELD_NUMBER = 36;
  private static final class TypedExtensionProtocolOptionsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, com.google.protobuf.Any> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, com.google.protobuf.Any>newDefaultInstance(
                io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_TypedExtensionProtocolOptionsEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.google.protobuf.Any.getDefaultInstance());
  }
  private com.google.protobuf.MapField<
      java.lang.String, com.google.protobuf.Any> typedExtensionProtocolOptions_;
  private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Any>
  internalGetTypedExtensionProtocolOptions() {
    if (typedExtensionProtocolOptions_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
    }
    return typedExtensionProtocolOptions_;
  }

  public int getTypedExtensionProtocolOptionsCount() {
    return internalGetTypedExtensionProtocolOptions().getMap().size();
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  @java.lang.Override
  public boolean containsTypedExtensionProtocolOptions(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    return internalGetTypedExtensionProtocolOptions().getMap().containsKey(key);
  }
  /**
   * Use {@link #getTypedExtensionProtocolOptionsMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptions() {
    return getTypedExtensionProtocolOptionsMap();
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  @java.lang.Override

  public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptionsMap() {
    return internalGetTypedExtensionProtocolOptions().getMap();
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  @java.lang.Override

  public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrDefault(
      java.lang.String key,
      com.google.protobuf.Any defaultValue) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, com.google.protobuf.Any> map =
        internalGetTypedExtensionProtocolOptions().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  @java.lang.Override

  public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, com.google.protobuf.Any> map =
        internalGetTypedExtensionProtocolOptions().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int DNS_REFRESH_RATE_FIELD_NUMBER = 16;
  private com.google.protobuf.Duration dnsRefreshRate_;
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsRefreshRate field is set.
   */
  @java.lang.Override
  public boolean hasDnsRefreshRate() {
    return dnsRefreshRate_ != null;
  }
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   * @return The dnsRefreshRate.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getDnsRefreshRate() {
    return dnsRefreshRate_ == null ? com.google.protobuf.Duration.getDefaultInstance() : dnsRefreshRate_;
  }
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder() {
    return getDnsRefreshRate();
  }

  public static final int DNS_FAILURE_REFRESH_RATE_FIELD_NUMBER = 44;
  private io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate dnsFailureRefreshRate_;
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   * @return Whether the dnsFailureRefreshRate field is set.
   */
  @java.lang.Override
  public boolean hasDnsFailureRefreshRate() {
    return dnsFailureRefreshRate_ != null;
  }
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   * @return The dnsFailureRefreshRate.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDnsFailureRefreshRate() {
    return dnsFailureRefreshRate_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.getDefaultInstance() : dnsFailureRefreshRate_;
  }
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder getDnsFailureRefreshRateOrBuilder() {
    return getDnsFailureRefreshRate();
  }

  public static final int RESPECT_DNS_TTL_FIELD_NUMBER = 39;
  private boolean respectDnsTtl_;
  /**
   * <pre>
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   * </pre>
   *
   * <code>bool respect_dns_ttl = 39;</code>
   * @return The respectDnsTtl.
   */
  @java.lang.Override
  public boolean getRespectDnsTtl() {
    return respectDnsTtl_;
  }

  public static final int DNS_LOOKUP_FAMILY_FIELD_NUMBER = 17;
  private int dnsLookupFamily_;
  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for dnsLookupFamily.
   */
  @java.lang.Override public int getDnsLookupFamilyValue() {
    return dnsLookupFamily_;
  }
  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   * @return The dnsLookupFamily.
   */
  @java.lang.Override public io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily getDnsLookupFamily() {
    @SuppressWarnings("deprecation")
    io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily result = io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily.valueOf(dnsLookupFamily_);
    return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily.UNRECOGNIZED : result;
  }

  public static final int DNS_RESOLVERS_FIELD_NUMBER = 18;
  private java.util.List<io.envoyproxy.envoy.config.core.v3.Address> dnsResolvers_;
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.core.v3.Address> getDnsResolversList() {
    return dnsResolvers_;
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> 
      getDnsResolversOrBuilderList() {
    return dnsResolvers_;
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  @java.lang.Override
  public int getDnsResolversCount() {
    return dnsResolvers_.size();
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Address getDnsResolvers(int index) {
    return dnsResolvers_.get(index);
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.AddressOrBuilder getDnsResolversOrBuilder(
      int index) {
    return dnsResolvers_.get(index);
  }

  public static final int USE_TCP_FOR_DNS_LOOKUPS_FIELD_NUMBER = 45;
  private boolean useTcpForDnsLookups_;
  /**
   * <pre>
   * [#next-major-version: Reconcile DNS options in a single message.]
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple' API only uses UDP for DNS resolution.
   * </pre>
   *
   * <code>bool use_tcp_for_dns_lookups = 45;</code>
   * @return The useTcpForDnsLookups.
   */
  @java.lang.Override
  public boolean getUseTcpForDnsLookups() {
    return useTcpForDnsLookups_;
  }

  public static final int OUTLIER_DETECTION_FIELD_NUMBER = 19;
  private io.envoyproxy.envoy.config.cluster.v3.OutlierDetection outlierDetection_;
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
   * @return Whether the outlierDetection field is set.
   */
  @java.lang.Override
  public boolean hasOutlierDetection() {
    return outlierDetection_ != null;
  }
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
   * @return The outlierDetection.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.OutlierDetection getOutlierDetection() {
    return outlierDetection_ == null ? io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.getDefaultInstance() : outlierDetection_;
  }
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder() {
    return getOutlierDetection();
  }

  public static final int CLEANUP_INTERVAL_FIELD_NUMBER = 20;
  private com.google.protobuf.Duration cleanupInterval_;
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   * @return Whether the cleanupInterval field is set.
   */
  @java.lang.Override
  public boolean hasCleanupInterval() {
    return cleanupInterval_ != null;
  }
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   * @return The cleanupInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getCleanupInterval() {
    return cleanupInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : cleanupInterval_;
  }
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getCleanupIntervalOrBuilder() {
    return getCleanupInterval();
  }

  public static final int UPSTREAM_BIND_CONFIG_FIELD_NUMBER = 21;
  private io.envoyproxy.envoy.config.core.v3.BindConfig upstreamBindConfig_;
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
   * @return Whether the upstreamBindConfig field is set.
   */
  @java.lang.Override
  public boolean hasUpstreamBindConfig() {
    return upstreamBindConfig_ != null;
  }
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
   * @return The upstreamBindConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.BindConfig getUpstreamBindConfig() {
    return upstreamBindConfig_ == null ? io.envoyproxy.envoy.config.core.v3.BindConfig.getDefaultInstance() : upstreamBindConfig_;
  }
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.BindConfigOrBuilder getUpstreamBindConfigOrBuilder() {
    return getUpstreamBindConfig();
  }

  public static final int LB_SUBSET_CONFIG_FIELD_NUMBER = 22;
  private io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig lbSubsetConfig_;
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   * @return Whether the lbSubsetConfig field is set.
   */
  @java.lang.Override
  public boolean hasLbSubsetConfig() {
    return lbSubsetConfig_ != null;
  }
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   * @return The lbSubsetConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig getLbSubsetConfig() {
    return lbSubsetConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.getDefaultInstance() : lbSubsetConfig_;
  }
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder getLbSubsetConfigOrBuilder() {
    return getLbSubsetConfig();
  }

  public static final int RING_HASH_LB_CONFIG_FIELD_NUMBER = 23;
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   * @return Whether the ringHashLbConfig field is set.
   */
  @java.lang.Override
  public boolean hasRingHashLbConfig() {
    return lbConfigCase_ == 23;
  }
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   * @return The ringHashLbConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig getRingHashLbConfig() {
    if (lbConfigCase_ == 23) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder getRingHashLbConfigOrBuilder() {
    if (lbConfigCase_ == 23) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
  }

  public static final int MAGLEV_LB_CONFIG_FIELD_NUMBER = 52;
  /**
   * <pre>
   * Optional configuration for the Maglev load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
   * @return Whether the maglevLbConfig field is set.
   */
  @java.lang.Override
  public boolean hasMaglevLbConfig() {
    return lbConfigCase_ == 52;
  }
  /**
   * <pre>
   * Optional configuration for the Maglev load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
   * @return The maglevLbConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig getMaglevLbConfig() {
    if (lbConfigCase_ == 52) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the Maglev load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder getMaglevLbConfigOrBuilder() {
    if (lbConfigCase_ == 52) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
  }

  public static final int ORIGINAL_DST_LB_CONFIG_FIELD_NUMBER = 34;
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   * @return Whether the originalDstLbConfig field is set.
   */
  @java.lang.Override
  public boolean hasOriginalDstLbConfig() {
    return lbConfigCase_ == 34;
  }
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   * @return The originalDstLbConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig getOriginalDstLbConfig() {
    if (lbConfigCase_ == 34) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder getOriginalDstLbConfigOrBuilder() {
    if (lbConfigCase_ == 34) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
  }

  public static final int LEAST_REQUEST_LB_CONFIG_FIELD_NUMBER = 37;
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   * @return Whether the leastRequestLbConfig field is set.
   */
  @java.lang.Override
  public boolean hasLeastRequestLbConfig() {
    return lbConfigCase_ == 37;
  }
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   * @return The leastRequestLbConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig getLeastRequestLbConfig() {
    if (lbConfigCase_ == 37) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder getLeastRequestLbConfigOrBuilder() {
    if (lbConfigCase_ == 37) {
       return (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_;
    }
    return io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
  }

  public static final int COMMON_LB_CONFIG_FIELD_NUMBER = 27;
  private io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig commonLbConfig_;
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
   * @return Whether the commonLbConfig field is set.
   */
  @java.lang.Override
  public boolean hasCommonLbConfig() {
    return commonLbConfig_ != null;
  }
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
   * @return The commonLbConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig getCommonLbConfig() {
    return commonLbConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.getDefaultInstance() : commonLbConfig_;
  }
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder getCommonLbConfigOrBuilder() {
    return getCommonLbConfig();
  }

  public static final int TRANSPORT_SOCKET_FIELD_NUMBER = 24;
  private io.envoyproxy.envoy.config.core.v3.TransportSocket transportSocket_;
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
   * @return Whether the transportSocket field is set.
   */
  @java.lang.Override
  public boolean hasTransportSocket() {
    return transportSocket_ != null;
  }
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
   * @return The transportSocket.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TransportSocket getTransportSocket() {
    return transportSocket_ == null ? io.envoyproxy.envoy.config.core.v3.TransportSocket.getDefaultInstance() : transportSocket_;
  }
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder getTransportSocketOrBuilder() {
    return getTransportSocket();
  }

  public static final int METADATA_FIELD_NUMBER = 25;
  private io.envoyproxy.envoy.config.core.v3.Metadata metadata_;
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
   * @return Whether the metadata field is set.
   */
  @java.lang.Override
  public boolean hasMetadata() {
    return metadata_ != null;
  }
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
   * @return The metadata.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Metadata getMetadata() {
    return metadata_ == null ? io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
  }
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder getMetadataOrBuilder() {
    return getMetadata();
  }

  public static final int PROTOCOL_SELECTION_FIELD_NUMBER = 26;
  private int protocolSelection_;
  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * This has been deprecated in favor of setting explicit protocol selection
   * in the :ref:`http_protocol_options
   * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
   * @return The enum numeric value on the wire for protocolSelection.
   */
  @java.lang.Override @java.lang.Deprecated public int getProtocolSelectionValue() {
    return protocolSelection_;
  }
  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * This has been deprecated in favor of setting explicit protocol selection
   * in the :ref:`http_protocol_options
   * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
   * @return The protocolSelection.
   */
  @java.lang.Override @java.lang.Deprecated public io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection getProtocolSelection() {
    @SuppressWarnings("deprecation")
    io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection result = io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.valueOf(protocolSelection_);
    return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.UNRECOGNIZED : result;
  }

  public static final int UPSTREAM_CONNECTION_OPTIONS_FIELD_NUMBER = 30;
  private io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions upstreamConnectionOptions_;
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   * @return Whether the upstreamConnectionOptions field is set.
   */
  @java.lang.Override
  public boolean hasUpstreamConnectionOptions() {
    return upstreamConnectionOptions_ != null;
  }
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   * @return The upstreamConnectionOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions getUpstreamConnectionOptions() {
    return upstreamConnectionOptions_ == null ? io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.getDefaultInstance() : upstreamConnectionOptions_;
  }
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptionsOrBuilder getUpstreamConnectionOptionsOrBuilder() {
    return getUpstreamConnectionOptions();
  }

  public static final int CLOSE_CONNECTIONS_ON_HOST_HEALTH_FAILURE_FIELD_NUMBER = 31;
  private boolean closeConnectionsOnHostHealthFailure_;
  /**
   * <pre>
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   * .. note::
   *   This is currently only supported for connections created by tcp_proxy.
   * .. note::
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   * </pre>
   *
   * <code>bool close_connections_on_host_health_failure = 31;</code>
   * @return The closeConnectionsOnHostHealthFailure.
   */
  @java.lang.Override
  public boolean getCloseConnectionsOnHostHealthFailure() {
    return closeConnectionsOnHostHealthFailure_;
  }

  public static final int IGNORE_HEALTH_ON_HOST_REMOVAL_FIELD_NUMBER = 32;
  private boolean ignoreHealthOnHostRemoval_;
  /**
   * <pre>
   * If set to true, Envoy will ignore the health value of a host when processing its removal
   * from service discovery. This means that if active health checking is used, Envoy will *not*
   * wait for the endpoint to go unhealthy before removing it.
   * </pre>
   *
   * <code>bool ignore_health_on_host_removal = 32;</code>
   * @return The ignoreHealthOnHostRemoval.
   */
  @java.lang.Override
  public boolean getIgnoreHealthOnHostRemoval() {
    return ignoreHealthOnHostRemoval_;
  }

  public static final int FILTERS_FIELD_NUMBER = 40;
  private java.util.List<io.envoyproxy.envoy.config.cluster.v3.Filter> filters_;
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Filter> getFiltersList() {
    return filters_;
  }
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder> 
      getFiltersOrBuilderList() {
    return filters_;
  }
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  @java.lang.Override
  public int getFiltersCount() {
    return filters_.size();
  }
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Filter getFilters(int index) {
    return filters_.get(index);
  }
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder getFiltersOrBuilder(
      int index) {
    return filters_.get(index);
  }

  public static final int LOAD_BALANCING_POLICY_FIELD_NUMBER = 41;
  private io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy loadBalancingPolicy_;
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
   * @return Whether the loadBalancingPolicy field is set.
   */
  @java.lang.Override
  public boolean hasLoadBalancingPolicy() {
    return loadBalancingPolicy_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
   * @return The loadBalancingPolicy.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy getLoadBalancingPolicy() {
    return loadBalancingPolicy_ == null ? io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.getDefaultInstance() : loadBalancingPolicy_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicyOrBuilder getLoadBalancingPolicyOrBuilder() {
    return getLoadBalancingPolicy();
  }

  public static final int LRS_SERVER_FIELD_NUMBER = 42;
  private io.envoyproxy.envoy.config.core.v3.ConfigSource lrsServer_;
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
   * @return Whether the lrsServer field is set.
   */
  @java.lang.Override
  public boolean hasLrsServer() {
    return lrsServer_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
   * @return The lrsServer.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.ConfigSource getLrsServer() {
    return lrsServer_ == null ? io.envoyproxy.envoy.config.core.v3.ConfigSource.getDefaultInstance() : lrsServer_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder getLrsServerOrBuilder() {
    return getLrsServer();
  }

  public static final int TRACK_TIMEOUT_BUDGETS_FIELD_NUMBER = 47;
  private boolean trackTimeoutBudgets_;
  /**
   * <pre>
   * If track_timeout_budgets is true, the :ref:`timeout budget histograms
   * &lt;config_cluster_manager_cluster_stats_timeout_budgets&gt;` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   * .. attention::
   *   This field has been deprecated in favor of `timeout_budgets`, part of
   *   :ref:`track_cluster_stats &lt;envoy_api_field_config.cluster.v3.Cluster.track_cluster_stats&gt;`.
   * </pre>
   *
   * <code>bool track_timeout_budgets = 47 [deprecated = true];</code>
   * @return The trackTimeoutBudgets.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean getTrackTimeoutBudgets() {
    return trackTimeoutBudgets_;
  }

  public static final int UPSTREAM_CONFIG_FIELD_NUMBER = 48;
  private io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig upstreamConfig_;
  /**
   * <pre>
   * Optional customization and configuration of upstream connection pool, and upstream type.
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from `http2_protocol_options`
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
   * @return Whether the upstreamConfig field is set.
   */
  @java.lang.Override
  public boolean hasUpstreamConfig() {
    return upstreamConfig_ != null;
  }
  /**
   * <pre>
   * Optional customization and configuration of upstream connection pool, and upstream type.
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from `http2_protocol_options`
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
   * @return The upstreamConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getUpstreamConfig() {
    return upstreamConfig_ == null ? io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : upstreamConfig_;
  }
  /**
   * <pre>
   * Optional customization and configuration of upstream connection pool, and upstream type.
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from `http2_protocol_options`
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getUpstreamConfigOrBuilder() {
    return getUpstreamConfig();
  }

  public static final int TRACK_CLUSTER_STATS_FIELD_NUMBER = 49;
  private io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats trackClusterStats_;
  /**
   * <pre>
   * Configuration to track optional cluster stats.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
   * @return Whether the trackClusterStats field is set.
   */
  @java.lang.Override
  public boolean hasTrackClusterStats() {
    return trackClusterStats_ != null;
  }
  /**
   * <pre>
   * Configuration to track optional cluster stats.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
   * @return The trackClusterStats.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats getTrackClusterStats() {
    return trackClusterStats_ == null ? io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.getDefaultInstance() : trackClusterStats_;
  }
  /**
   * <pre>
   * Configuration to track optional cluster stats.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.TrackClusterStatsOrBuilder getTrackClusterStatsOrBuilder() {
    return getTrackClusterStats();
  }

  public static final int PRECONNECT_POLICY_FIELD_NUMBER = 50;
  private io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnectPolicy_;
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Preconnect configuration for this cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
   * @return Whether the preconnectPolicy field is set.
   */
  @java.lang.Override
  public boolean hasPreconnectPolicy() {
    return preconnectPolicy_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Preconnect configuration for this cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
   * @return The preconnectPolicy.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy getPreconnectPolicy() {
    return preconnectPolicy_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.getDefaultInstance() : preconnectPolicy_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Preconnect configuration for this cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder getPreconnectPolicyOrBuilder() {
    return getPreconnectPolicy();
  }

  public static final int CONNECTION_POOL_PER_DOWNSTREAM_CONNECTION_FIELD_NUMBER = 51;
  private boolean connectionPoolPerDownstreamConnection_;
  /**
   * <pre>
   * If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
   * connection pool for every downstream connection
   * </pre>
   *
   * <code>bool connection_pool_per_downstream_connection = 51;</code>
   * @return The connectionPoolPerDownstreamConnection.
   */
  @java.lang.Override
  public boolean getConnectionPoolPerDownstreamConnection() {
    return connectionPoolPerDownstreamConnection_;
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!getNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
    }
    if (clusterDiscoveryTypeCase_ == 2) {
      output.writeEnum(2, ((java.lang.Integer) clusterDiscoveryType_));
    }
    if (edsClusterConfig_ != null) {
      output.writeMessage(3, getEdsClusterConfig());
    }
    if (connectTimeout_ != null) {
      output.writeMessage(4, getConnectTimeout());
    }
    if (perConnectionBufferLimitBytes_ != null) {
      output.writeMessage(5, getPerConnectionBufferLimitBytes());
    }
    if (lbPolicy_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy.ROUND_ROBIN.getNumber()) {
      output.writeEnum(6, lbPolicy_);
    }
    for (int i = 0; i < healthChecks_.size(); i++) {
      output.writeMessage(8, healthChecks_.get(i));
    }
    if (maxRequestsPerConnection_ != null) {
      output.writeMessage(9, getMaxRequestsPerConnection());
    }
    if (circuitBreakers_ != null) {
      output.writeMessage(10, getCircuitBreakers());
    }
    if (httpProtocolOptions_ != null) {
      output.writeMessage(13, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      output.writeMessage(14, getHttp2ProtocolOptions());
    }
    if (dnsRefreshRate_ != null) {
      output.writeMessage(16, getDnsRefreshRate());
    }
    if (dnsLookupFamily_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily.AUTO.getNumber()) {
      output.writeEnum(17, dnsLookupFamily_);
    }
    for (int i = 0; i < dnsResolvers_.size(); i++) {
      output.writeMessage(18, dnsResolvers_.get(i));
    }
    if (outlierDetection_ != null) {
      output.writeMessage(19, getOutlierDetection());
    }
    if (cleanupInterval_ != null) {
      output.writeMessage(20, getCleanupInterval());
    }
    if (upstreamBindConfig_ != null) {
      output.writeMessage(21, getUpstreamBindConfig());
    }
    if (lbSubsetConfig_ != null) {
      output.writeMessage(22, getLbSubsetConfig());
    }
    if (lbConfigCase_ == 23) {
      output.writeMessage(23, (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_);
    }
    if (transportSocket_ != null) {
      output.writeMessage(24, getTransportSocket());
    }
    if (metadata_ != null) {
      output.writeMessage(25, getMetadata());
    }
    if (protocolSelection_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL.getNumber()) {
      output.writeEnum(26, protocolSelection_);
    }
    if (commonLbConfig_ != null) {
      output.writeMessage(27, getCommonLbConfig());
    }
    if (!getAltStatNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 28, altStatName_);
    }
    if (commonHttpProtocolOptions_ != null) {
      output.writeMessage(29, getCommonHttpProtocolOptions());
    }
    if (upstreamConnectionOptions_ != null) {
      output.writeMessage(30, getUpstreamConnectionOptions());
    }
    if (closeConnectionsOnHostHealthFailure_ != false) {
      output.writeBool(31, closeConnectionsOnHostHealthFailure_);
    }
    if (ignoreHealthOnHostRemoval_ != false) {
      output.writeBool(32, ignoreHealthOnHostRemoval_);
    }
    if (loadAssignment_ != null) {
      output.writeMessage(33, getLoadAssignment());
    }
    if (lbConfigCase_ == 34) {
      output.writeMessage(34, (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_);
    }
    com.google.protobuf.GeneratedMessageV3
      .serializeStringMapTo(
        output,
        internalGetTypedExtensionProtocolOptions(),
        TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry,
        36);
    if (lbConfigCase_ == 37) {
      output.writeMessage(37, (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_);
    }
    if (clusterDiscoveryTypeCase_ == 38) {
      output.writeMessage(38, (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_);
    }
    if (respectDnsTtl_ != false) {
      output.writeBool(39, respectDnsTtl_);
    }
    for (int i = 0; i < filters_.size(); i++) {
      output.writeMessage(40, filters_.get(i));
    }
    if (loadBalancingPolicy_ != null) {
      output.writeMessage(41, getLoadBalancingPolicy());
    }
    if (lrsServer_ != null) {
      output.writeMessage(42, getLrsServer());
    }
    for (int i = 0; i < transportSocketMatches_.size(); i++) {
      output.writeMessage(43, transportSocketMatches_.get(i));
    }
    if (dnsFailureRefreshRate_ != null) {
      output.writeMessage(44, getDnsFailureRefreshRate());
    }
    if (useTcpForDnsLookups_ != false) {
      output.writeBool(45, useTcpForDnsLookups_);
    }
    if (upstreamHttpProtocolOptions_ != null) {
      output.writeMessage(46, getUpstreamHttpProtocolOptions());
    }
    if (trackTimeoutBudgets_ != false) {
      output.writeBool(47, trackTimeoutBudgets_);
    }
    if (upstreamConfig_ != null) {
      output.writeMessage(48, getUpstreamConfig());
    }
    if (trackClusterStats_ != null) {
      output.writeMessage(49, getTrackClusterStats());
    }
    if (preconnectPolicy_ != null) {
      output.writeMessage(50, getPreconnectPolicy());
    }
    if (connectionPoolPerDownstreamConnection_ != false) {
      output.writeBool(51, connectionPoolPerDownstreamConnection_);
    }
    if (lbConfigCase_ == 52) {
      output.writeMessage(52, (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!getNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
    }
    if (clusterDiscoveryTypeCase_ == 2) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(2, ((java.lang.Integer) clusterDiscoveryType_));
    }
    if (edsClusterConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, getEdsClusterConfig());
    }
    if (connectTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getConnectTimeout());
    }
    if (perConnectionBufferLimitBytes_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getPerConnectionBufferLimitBytes());
    }
    if (lbPolicy_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy.ROUND_ROBIN.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(6, lbPolicy_);
    }
    for (int i = 0; i < healthChecks_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, healthChecks_.get(i));
    }
    if (maxRequestsPerConnection_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getMaxRequestsPerConnection());
    }
    if (circuitBreakers_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(10, getCircuitBreakers());
    }
    if (httpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(13, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(14, getHttp2ProtocolOptions());
    }
    if (dnsRefreshRate_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(16, getDnsRefreshRate());
    }
    if (dnsLookupFamily_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily.AUTO.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(17, dnsLookupFamily_);
    }
    for (int i = 0; i < dnsResolvers_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(18, dnsResolvers_.get(i));
    }
    if (outlierDetection_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(19, getOutlierDetection());
    }
    if (cleanupInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(20, getCleanupInterval());
    }
    if (upstreamBindConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(21, getUpstreamBindConfig());
    }
    if (lbSubsetConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(22, getLbSubsetConfig());
    }
    if (lbConfigCase_ == 23) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(23, (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_);
    }
    if (transportSocket_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(24, getTransportSocket());
    }
    if (metadata_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(25, getMetadata());
    }
    if (protocolSelection_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(26, protocolSelection_);
    }
    if (commonLbConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(27, getCommonLbConfig());
    }
    if (!getAltStatNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(28, altStatName_);
    }
    if (commonHttpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(29, getCommonHttpProtocolOptions());
    }
    if (upstreamConnectionOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(30, getUpstreamConnectionOptions());
    }
    if (closeConnectionsOnHostHealthFailure_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(31, closeConnectionsOnHostHealthFailure_);
    }
    if (ignoreHealthOnHostRemoval_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(32, ignoreHealthOnHostRemoval_);
    }
    if (loadAssignment_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(33, getLoadAssignment());
    }
    if (lbConfigCase_ == 34) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(34, (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_);
    }
    for (java.util.Map.Entry<java.lang.String, com.google.protobuf.Any> entry
         : internalGetTypedExtensionProtocolOptions().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.Any>
      typedExtensionProtocolOptions__ = TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(36, typedExtensionProtocolOptions__);
    }
    if (lbConfigCase_ == 37) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(37, (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_);
    }
    if (clusterDiscoveryTypeCase_ == 38) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(38, (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_);
    }
    if (respectDnsTtl_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(39, respectDnsTtl_);
    }
    for (int i = 0; i < filters_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(40, filters_.get(i));
    }
    if (loadBalancingPolicy_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(41, getLoadBalancingPolicy());
    }
    if (lrsServer_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(42, getLrsServer());
    }
    for (int i = 0; i < transportSocketMatches_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(43, transportSocketMatches_.get(i));
    }
    if (dnsFailureRefreshRate_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(44, getDnsFailureRefreshRate());
    }
    if (useTcpForDnsLookups_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(45, useTcpForDnsLookups_);
    }
    if (upstreamHttpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(46, getUpstreamHttpProtocolOptions());
    }
    if (trackTimeoutBudgets_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(47, trackTimeoutBudgets_);
    }
    if (upstreamConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(48, getUpstreamConfig());
    }
    if (trackClusterStats_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(49, getTrackClusterStats());
    }
    if (preconnectPolicy_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(50, getPreconnectPolicy());
    }
    if (connectionPoolPerDownstreamConnection_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(51, connectionPoolPerDownstreamConnection_);
    }
    if (lbConfigCase_ == 52) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(52, (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster)) {
      return super.equals(obj);
    }
    io.envoyproxy.envoy.config.cluster.v3.Cluster other = (io.envoyproxy.envoy.config.cluster.v3.Cluster) obj;

    if (!getTransportSocketMatchesList()
        .equals(other.getTransportSocketMatchesList())) return false;
    if (!getName()
        .equals(other.getName())) return false;
    if (!getAltStatName()
        .equals(other.getAltStatName())) return false;
    if (hasEdsClusterConfig() != other.hasEdsClusterConfig()) return false;
    if (hasEdsClusterConfig()) {
      if (!getEdsClusterConfig()
          .equals(other.getEdsClusterConfig())) return false;
    }
    if (hasConnectTimeout() != other.hasConnectTimeout()) return false;
    if (hasConnectTimeout()) {
      if (!getConnectTimeout()
          .equals(other.getConnectTimeout())) return false;
    }
    if (hasPerConnectionBufferLimitBytes() != other.hasPerConnectionBufferLimitBytes()) return false;
    if (hasPerConnectionBufferLimitBytes()) {
      if (!getPerConnectionBufferLimitBytes()
          .equals(other.getPerConnectionBufferLimitBytes())) return false;
    }
    if (lbPolicy_ != other.lbPolicy_) return false;
    if (hasLoadAssignment() != other.hasLoadAssignment()) return false;
    if (hasLoadAssignment()) {
      if (!getLoadAssignment()
          .equals(other.getLoadAssignment())) return false;
    }
    if (!getHealthChecksList()
        .equals(other.getHealthChecksList())) return false;
    if (hasMaxRequestsPerConnection() != other.hasMaxRequestsPerConnection()) return false;
    if (hasMaxRequestsPerConnection()) {
      if (!getMaxRequestsPerConnection()
          .equals(other.getMaxRequestsPerConnection())) return false;
    }
    if (hasCircuitBreakers() != other.hasCircuitBreakers()) return false;
    if (hasCircuitBreakers()) {
      if (!getCircuitBreakers()
          .equals(other.getCircuitBreakers())) return false;
    }
    if (hasUpstreamHttpProtocolOptions() != other.hasUpstreamHttpProtocolOptions()) return false;
    if (hasUpstreamHttpProtocolOptions()) {
      if (!getUpstreamHttpProtocolOptions()
          .equals(other.getUpstreamHttpProtocolOptions())) return false;
    }
    if (hasCommonHttpProtocolOptions() != other.hasCommonHttpProtocolOptions()) return false;
    if (hasCommonHttpProtocolOptions()) {
      if (!getCommonHttpProtocolOptions()
          .equals(other.getCommonHttpProtocolOptions())) return false;
    }
    if (hasHttpProtocolOptions() != other.hasHttpProtocolOptions()) return false;
    if (hasHttpProtocolOptions()) {
      if (!getHttpProtocolOptions()
          .equals(other.getHttpProtocolOptions())) return false;
    }
    if (hasHttp2ProtocolOptions() != other.hasHttp2ProtocolOptions()) return false;
    if (hasHttp2ProtocolOptions()) {
      if (!getHttp2ProtocolOptions()
          .equals(other.getHttp2ProtocolOptions())) return false;
    }
    if (!internalGetTypedExtensionProtocolOptions().equals(
        other.internalGetTypedExtensionProtocolOptions())) return false;
    if (hasDnsRefreshRate() != other.hasDnsRefreshRate()) return false;
    if (hasDnsRefreshRate()) {
      if (!getDnsRefreshRate()
          .equals(other.getDnsRefreshRate())) return false;
    }
    if (hasDnsFailureRefreshRate() != other.hasDnsFailureRefreshRate()) return false;
    if (hasDnsFailureRefreshRate()) {
      if (!getDnsFailureRefreshRate()
          .equals(other.getDnsFailureRefreshRate())) return false;
    }
    if (getRespectDnsTtl()
        != other.getRespectDnsTtl()) return false;
    if (dnsLookupFamily_ != other.dnsLookupFamily_) return false;
    if (!getDnsResolversList()
        .equals(other.getDnsResolversList())) return false;
    if (getUseTcpForDnsLookups()
        != other.getUseTcpForDnsLookups()) return false;
    if (hasOutlierDetection() != other.hasOutlierDetection()) return false;
    if (hasOutlierDetection()) {
      if (!getOutlierDetection()
          .equals(other.getOutlierDetection())) return false;
    }
    if (hasCleanupInterval() != other.hasCleanupInterval()) return false;
    if (hasCleanupInterval()) {
      if (!getCleanupInterval()
          .equals(other.getCleanupInterval())) return false;
    }
    if (hasUpstreamBindConfig() != other.hasUpstreamBindConfig()) return false;
    if (hasUpstreamBindConfig()) {
      if (!getUpstreamBindConfig()
          .equals(other.getUpstreamBindConfig())) return false;
    }
    if (hasLbSubsetConfig() != other.hasLbSubsetConfig()) return false;
    if (hasLbSubsetConfig()) {
      if (!getLbSubsetConfig()
          .equals(other.getLbSubsetConfig())) return false;
    }
    if (hasCommonLbConfig() != other.hasCommonLbConfig()) return false;
    if (hasCommonLbConfig()) {
      if (!getCommonLbConfig()
          .equals(other.getCommonLbConfig())) return false;
    }
    if (hasTransportSocket() != other.hasTransportSocket()) return false;
    if (hasTransportSocket()) {
      if (!getTransportSocket()
          .equals(other.getTransportSocket())) return false;
    }
    if (hasMetadata() != other.hasMetadata()) return false;
    if (hasMetadata()) {
      if (!getMetadata()
          .equals(other.getMetadata())) return false;
    }
    if (protocolSelection_ != other.protocolSelection_) return false;
    if (hasUpstreamConnectionOptions() != other.hasUpstreamConnectionOptions()) return false;
    if (hasUpstreamConnectionOptions()) {
      if (!getUpstreamConnectionOptions()
          .equals(other.getUpstreamConnectionOptions())) return false;
    }
    if (getCloseConnectionsOnHostHealthFailure()
        != other.getCloseConnectionsOnHostHealthFailure()) return false;
    if (getIgnoreHealthOnHostRemoval()
        != other.getIgnoreHealthOnHostRemoval()) return false;
    if (!getFiltersList()
        .equals(other.getFiltersList())) return false;
    if (hasLoadBalancingPolicy() != other.hasLoadBalancingPolicy()) return false;
    if (hasLoadBalancingPolicy()) {
      if (!getLoadBalancingPolicy()
          .equals(other.getLoadBalancingPolicy())) return false;
    }
    if (hasLrsServer() != other.hasLrsServer()) return false;
    if (hasLrsServer()) {
      if (!getLrsServer()
          .equals(other.getLrsServer())) return false;
    }
    if (getTrackTimeoutBudgets()
        != other.getTrackTimeoutBudgets()) return false;
    if (hasUpstreamConfig() != other.hasUpstreamConfig()) return false;
    if (hasUpstreamConfig()) {
      if (!getUpstreamConfig()
          .equals(other.getUpstreamConfig())) return false;
    }
    if (hasTrackClusterStats() != other.hasTrackClusterStats()) return false;
    if (hasTrackClusterStats()) {
      if (!getTrackClusterStats()
          .equals(other.getTrackClusterStats())) return false;
    }
    if (hasPreconnectPolicy() != other.hasPreconnectPolicy()) return false;
    if (hasPreconnectPolicy()) {
      if (!getPreconnectPolicy()
          .equals(other.getPreconnectPolicy())) return false;
    }
    if (getConnectionPoolPerDownstreamConnection()
        != other.getConnectionPoolPerDownstreamConnection()) return false;
    if (!getClusterDiscoveryTypeCase().equals(other.getClusterDiscoveryTypeCase())) return false;
    switch (clusterDiscoveryTypeCase_) {
      case 2:
        if (getTypeValue()
            != other.getTypeValue()) return false;
        break;
      case 38:
        if (!getClusterType()
            .equals(other.getClusterType())) return false;
        break;
      case 0:
      default:
    }
    if (!getLbConfigCase().equals(other.getLbConfigCase())) return false;
    switch (lbConfigCase_) {
      case 23:
        if (!getRingHashLbConfig()
            .equals(other.getRingHashLbConfig())) return false;
        break;
      case 52:
        if (!getMaglevLbConfig()
            .equals(other.getMaglevLbConfig())) return false;
        break;
      case 34:
        if (!getOriginalDstLbConfig()
            .equals(other.getOriginalDstLbConfig())) return false;
        break;
      case 37:
        if (!getLeastRequestLbConfig()
            .equals(other.getLeastRequestLbConfig())) return false;
        break;
      case 0:
      default:
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getTransportSocketMatchesCount() > 0) {
      hash = (37 * hash) + TRANSPORT_SOCKET_MATCHES_FIELD_NUMBER;
      hash = (53 * hash) + getTransportSocketMatchesList().hashCode();
    }
    hash = (37 * hash) + NAME_FIELD_NUMBER;
    hash = (53 * hash) + getName().hashCode();
    hash = (37 * hash) + ALT_STAT_NAME_FIELD_NUMBER;
    hash = (53 * hash) + getAltStatName().hashCode();
    if (hasEdsClusterConfig()) {
      hash = (37 * hash) + EDS_CLUSTER_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getEdsClusterConfig().hashCode();
    }
    if (hasConnectTimeout()) {
      hash = (37 * hash) + CONNECT_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getConnectTimeout().hashCode();
    }
    if (hasPerConnectionBufferLimitBytes()) {
      hash = (37 * hash) + PER_CONNECTION_BUFFER_LIMIT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getPerConnectionBufferLimitBytes().hashCode();
    }
    hash = (37 * hash) + LB_POLICY_FIELD_NUMBER;
    hash = (53 * hash) + lbPolicy_;
    if (hasLoadAssignment()) {
      hash = (37 * hash) + LOAD_ASSIGNMENT_FIELD_NUMBER;
      hash = (53 * hash) + getLoadAssignment().hashCode();
    }
    if (getHealthChecksCount() > 0) {
      hash = (37 * hash) + HEALTH_CHECKS_FIELD_NUMBER;
      hash = (53 * hash) + getHealthChecksList().hashCode();
    }
    if (hasMaxRequestsPerConnection()) {
      hash = (37 * hash) + MAX_REQUESTS_PER_CONNECTION_FIELD_NUMBER;
      hash = (53 * hash) + getMaxRequestsPerConnection().hashCode();
    }
    if (hasCircuitBreakers()) {
      hash = (37 * hash) + CIRCUIT_BREAKERS_FIELD_NUMBER;
      hash = (53 * hash) + getCircuitBreakers().hashCode();
    }
    if (hasUpstreamHttpProtocolOptions()) {
      hash = (37 * hash) + UPSTREAM_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getUpstreamHttpProtocolOptions().hashCode();
    }
    if (hasCommonHttpProtocolOptions()) {
      hash = (37 * hash) + COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getCommonHttpProtocolOptions().hashCode();
    }
    if (hasHttpProtocolOptions()) {
      hash = (37 * hash) + HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttpProtocolOptions().hashCode();
    }
    if (hasHttp2ProtocolOptions()) {
      hash = (37 * hash) + HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttp2ProtocolOptions().hashCode();
    }
    if (!internalGetTypedExtensionProtocolOptions().getMap().isEmpty()) {
      hash = (37 * hash) + TYPED_EXTENSION_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetTypedExtensionProtocolOptions().hashCode();
    }
    if (hasDnsRefreshRate()) {
      hash = (37 * hash) + DNS_REFRESH_RATE_FIELD_NUMBER;
      hash = (53 * hash) + getDnsRefreshRate().hashCode();
    }
    if (hasDnsFailureRefreshRate()) {
      hash = (37 * hash) + DNS_FAILURE_REFRESH_RATE_FIELD_NUMBER;
      hash = (53 * hash) + getDnsFailureRefreshRate().hashCode();
    }
    hash = (37 * hash) + RESPECT_DNS_TTL_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getRespectDnsTtl());
    hash = (37 * hash) + DNS_LOOKUP_FAMILY_FIELD_NUMBER;
    hash = (53 * hash) + dnsLookupFamily_;
    if (getDnsResolversCount() > 0) {
      hash = (37 * hash) + DNS_RESOLVERS_FIELD_NUMBER;
      hash = (53 * hash) + getDnsResolversList().hashCode();
    }
    hash = (37 * hash) + USE_TCP_FOR_DNS_LOOKUPS_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getUseTcpForDnsLookups());
    if (hasOutlierDetection()) {
      hash = (37 * hash) + OUTLIER_DETECTION_FIELD_NUMBER;
      hash = (53 * hash) + getOutlierDetection().hashCode();
    }
    if (hasCleanupInterval()) {
      hash = (37 * hash) + CLEANUP_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getCleanupInterval().hashCode();
    }
    if (hasUpstreamBindConfig()) {
      hash = (37 * hash) + UPSTREAM_BIND_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getUpstreamBindConfig().hashCode();
    }
    if (hasLbSubsetConfig()) {
      hash = (37 * hash) + LB_SUBSET_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getLbSubsetConfig().hashCode();
    }
    if (hasCommonLbConfig()) {
      hash = (37 * hash) + COMMON_LB_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getCommonLbConfig().hashCode();
    }
    if (hasTransportSocket()) {
      hash = (37 * hash) + TRANSPORT_SOCKET_FIELD_NUMBER;
      hash = (53 * hash) + getTransportSocket().hashCode();
    }
    if (hasMetadata()) {
      hash = (37 * hash) + METADATA_FIELD_NUMBER;
      hash = (53 * hash) + getMetadata().hashCode();
    }
    hash = (37 * hash) + PROTOCOL_SELECTION_FIELD_NUMBER;
    hash = (53 * hash) + protocolSelection_;
    if (hasUpstreamConnectionOptions()) {
      hash = (37 * hash) + UPSTREAM_CONNECTION_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getUpstreamConnectionOptions().hashCode();
    }
    hash = (37 * hash) + CLOSE_CONNECTIONS_ON_HOST_HEALTH_FAILURE_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getCloseConnectionsOnHostHealthFailure());
    hash = (37 * hash) + IGNORE_HEALTH_ON_HOST_REMOVAL_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getIgnoreHealthOnHostRemoval());
    if (getFiltersCount() > 0) {
      hash = (37 * hash) + FILTERS_FIELD_NUMBER;
      hash = (53 * hash) + getFiltersList().hashCode();
    }
    if (hasLoadBalancingPolicy()) {
      hash = (37 * hash) + LOAD_BALANCING_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + getLoadBalancingPolicy().hashCode();
    }
    if (hasLrsServer()) {
      hash = (37 * hash) + LRS_SERVER_FIELD_NUMBER;
      hash = (53 * hash) + getLrsServer().hashCode();
    }
    hash = (37 * hash) + TRACK_TIMEOUT_BUDGETS_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getTrackTimeoutBudgets());
    if (hasUpstreamConfig()) {
      hash = (37 * hash) + UPSTREAM_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getUpstreamConfig().hashCode();
    }
    if (hasTrackClusterStats()) {
      hash = (37 * hash) + TRACK_CLUSTER_STATS_FIELD_NUMBER;
      hash = (53 * hash) + getTrackClusterStats().hashCode();
    }
    if (hasPreconnectPolicy()) {
      hash = (37 * hash) + PRECONNECT_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + getPreconnectPolicy().hashCode();
    }
    hash = (37 * hash) + CONNECTION_POOL_PER_DOWNSTREAM_CONNECTION_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getConnectionPoolPerDownstreamConnection());
    switch (clusterDiscoveryTypeCase_) {
      case 2:
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getTypeValue();
        break;
      case 38:
        hash = (37 * hash) + CLUSTER_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getClusterType().hashCode();
        break;
      case 0:
      default:
    }
    switch (lbConfigCase_) {
      case 23:
        hash = (37 * hash) + RING_HASH_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getRingHashLbConfig().hashCode();
        break;
      case 52:
        hash = (37 * hash) + MAGLEV_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getMaglevLbConfig().hashCode();
        break;
      case 34:
        hash = (37 * hash) + ORIGINAL_DST_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getOriginalDstLbConfig().hashCode();
        break;
      case 37:
        hash = (37 * hash) + LEAST_REQUEST_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getLeastRequestLbConfig().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.cluster.v3.Cluster parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.envoyproxy.envoy.config.cluster.v3.Cluster prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Configuration for a single upstream cluster.
   * [#next-free-field: 53]
   * </pre>
   *
   * Protobuf type {@code envoy.config.cluster.v3.Cluster}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.config.cluster.v3.Cluster)
      io.envoyproxy.envoy.config.cluster.v3.ClusterOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 36:
          return internalGetTypedExtensionProtocolOptions();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMutableMapField(
        int number) {
      switch (number) {
        case 36:
          return internalGetMutableTypedExtensionProtocolOptions();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.cluster.v3.Cluster.class, io.envoyproxy.envoy.config.cluster.v3.Cluster.Builder.class);
    }

    // Construct using io.envoyproxy.envoy.config.cluster.v3.Cluster.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getTransportSocketMatchesFieldBuilder();
        getHealthChecksFieldBuilder();
        getDnsResolversFieldBuilder();
        getFiltersFieldBuilder();
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      if (transportSocketMatchesBuilder_ == null) {
        transportSocketMatches_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
      } else {
        transportSocketMatchesBuilder_.clear();
      }
      name_ = "";

      altStatName_ = "";

      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfig_ = null;
      } else {
        edsClusterConfig_ = null;
        edsClusterConfigBuilder_ = null;
      }
      if (connectTimeoutBuilder_ == null) {
        connectTimeout_ = null;
      } else {
        connectTimeout_ = null;
        connectTimeoutBuilder_ = null;
      }
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = null;
      } else {
        perConnectionBufferLimitBytes_ = null;
        perConnectionBufferLimitBytesBuilder_ = null;
      }
      lbPolicy_ = 0;

      if (loadAssignmentBuilder_ == null) {
        loadAssignment_ = null;
      } else {
        loadAssignment_ = null;
        loadAssignmentBuilder_ = null;
      }
      if (healthChecksBuilder_ == null) {
        healthChecks_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
      } else {
        healthChecksBuilder_.clear();
      }
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnection_ = null;
      } else {
        maxRequestsPerConnection_ = null;
        maxRequestsPerConnectionBuilder_ = null;
      }
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = null;
      } else {
        circuitBreakers_ = null;
        circuitBreakersBuilder_ = null;
      }
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        upstreamHttpProtocolOptions_ = null;
      } else {
        upstreamHttpProtocolOptions_ = null;
        upstreamHttpProtocolOptionsBuilder_ = null;
      }
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = null;
      } else {
        commonHttpProtocolOptions_ = null;
        commonHttpProtocolOptionsBuilder_ = null;
      }
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = null;
      } else {
        httpProtocolOptions_ = null;
        httpProtocolOptionsBuilder_ = null;
      }
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = null;
      } else {
        http2ProtocolOptions_ = null;
        http2ProtocolOptionsBuilder_ = null;
      }
      internalGetMutableTypedExtensionProtocolOptions().clear();
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRate_ = null;
      } else {
        dnsRefreshRate_ = null;
        dnsRefreshRateBuilder_ = null;
      }
      if (dnsFailureRefreshRateBuilder_ == null) {
        dnsFailureRefreshRate_ = null;
      } else {
        dnsFailureRefreshRate_ = null;
        dnsFailureRefreshRateBuilder_ = null;
      }
      respectDnsTtl_ = false;

      dnsLookupFamily_ = 0;

      if (dnsResolversBuilder_ == null) {
        dnsResolvers_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
      } else {
        dnsResolversBuilder_.clear();
      }
      useTcpForDnsLookups_ = false;

      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = null;
      } else {
        outlierDetection_ = null;
        outlierDetectionBuilder_ = null;
      }
      if (cleanupIntervalBuilder_ == null) {
        cleanupInterval_ = null;
      } else {
        cleanupInterval_ = null;
        cleanupIntervalBuilder_ = null;
      }
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfig_ = null;
      } else {
        upstreamBindConfig_ = null;
        upstreamBindConfigBuilder_ = null;
      }
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfig_ = null;
      } else {
        lbSubsetConfig_ = null;
        lbSubsetConfigBuilder_ = null;
      }
      if (commonLbConfigBuilder_ == null) {
        commonLbConfig_ = null;
      } else {
        commonLbConfig_ = null;
        commonLbConfigBuilder_ = null;
      }
      if (transportSocketBuilder_ == null) {
        transportSocket_ = null;
      } else {
        transportSocket_ = null;
        transportSocketBuilder_ = null;
      }
      if (metadataBuilder_ == null) {
        metadata_ = null;
      } else {
        metadata_ = null;
        metadataBuilder_ = null;
      }
      protocolSelection_ = 0;

      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptions_ = null;
      } else {
        upstreamConnectionOptions_ = null;
        upstreamConnectionOptionsBuilder_ = null;
      }
      closeConnectionsOnHostHealthFailure_ = false;

      ignoreHealthOnHostRemoval_ = false;

      if (filtersBuilder_ == null) {
        filters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
      } else {
        filtersBuilder_.clear();
      }
      if (loadBalancingPolicyBuilder_ == null) {
        loadBalancingPolicy_ = null;
      } else {
        loadBalancingPolicy_ = null;
        loadBalancingPolicyBuilder_ = null;
      }
      if (lrsServerBuilder_ == null) {
        lrsServer_ = null;
      } else {
        lrsServer_ = null;
        lrsServerBuilder_ = null;
      }
      trackTimeoutBudgets_ = false;

      if (upstreamConfigBuilder_ == null) {
        upstreamConfig_ = null;
      } else {
        upstreamConfig_ = null;
        upstreamConfigBuilder_ = null;
      }
      if (trackClusterStatsBuilder_ == null) {
        trackClusterStats_ = null;
      } else {
        trackClusterStats_ = null;
        trackClusterStatsBuilder_ = null;
      }
      if (preconnectPolicyBuilder_ == null) {
        preconnectPolicy_ = null;
      } else {
        preconnectPolicy_ = null;
        preconnectPolicyBuilder_ = null;
      }
      connectionPoolPerDownstreamConnection_ = false;

      clusterDiscoveryTypeCase_ = 0;
      clusterDiscoveryType_ = null;
      lbConfigCase_ = 0;
      lbConfig_ = null;
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.envoyproxy.envoy.config.cluster.v3.ClusterProto.internal_static_envoy_config_cluster_v3_Cluster_descriptor;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster getDefaultInstanceForType() {
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.getDefaultInstance();
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster build() {
      io.envoyproxy.envoy.config.cluster.v3.Cluster result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster buildPartial() {
      io.envoyproxy.envoy.config.cluster.v3.Cluster result = new io.envoyproxy.envoy.config.cluster.v3.Cluster(this);
      int from_bitField0_ = bitField0_;
      if (transportSocketMatchesBuilder_ == null) {
        if (((bitField0_ & 0x00000001) != 0)) {
          transportSocketMatches_ = java.util.Collections.unmodifiableList(transportSocketMatches_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.transportSocketMatches_ = transportSocketMatches_;
      } else {
        result.transportSocketMatches_ = transportSocketMatchesBuilder_.build();
      }
      result.name_ = name_;
      result.altStatName_ = altStatName_;
      if (clusterDiscoveryTypeCase_ == 2) {
        result.clusterDiscoveryType_ = clusterDiscoveryType_;
      }
      if (clusterDiscoveryTypeCase_ == 38) {
        if (clusterTypeBuilder_ == null) {
          result.clusterDiscoveryType_ = clusterDiscoveryType_;
        } else {
          result.clusterDiscoveryType_ = clusterTypeBuilder_.build();
        }
      }
      if (edsClusterConfigBuilder_ == null) {
        result.edsClusterConfig_ = edsClusterConfig_;
      } else {
        result.edsClusterConfig_ = edsClusterConfigBuilder_.build();
      }
      if (connectTimeoutBuilder_ == null) {
        result.connectTimeout_ = connectTimeout_;
      } else {
        result.connectTimeout_ = connectTimeoutBuilder_.build();
      }
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        result.perConnectionBufferLimitBytes_ = perConnectionBufferLimitBytes_;
      } else {
        result.perConnectionBufferLimitBytes_ = perConnectionBufferLimitBytesBuilder_.build();
      }
      result.lbPolicy_ = lbPolicy_;
      if (loadAssignmentBuilder_ == null) {
        result.loadAssignment_ = loadAssignment_;
      } else {
        result.loadAssignment_ = loadAssignmentBuilder_.build();
      }
      if (healthChecksBuilder_ == null) {
        if (((bitField0_ & 0x00000002) != 0)) {
          healthChecks_ = java.util.Collections.unmodifiableList(healthChecks_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.healthChecks_ = healthChecks_;
      } else {
        result.healthChecks_ = healthChecksBuilder_.build();
      }
      if (maxRequestsPerConnectionBuilder_ == null) {
        result.maxRequestsPerConnection_ = maxRequestsPerConnection_;
      } else {
        result.maxRequestsPerConnection_ = maxRequestsPerConnectionBuilder_.build();
      }
      if (circuitBreakersBuilder_ == null) {
        result.circuitBreakers_ = circuitBreakers_;
      } else {
        result.circuitBreakers_ = circuitBreakersBuilder_.build();
      }
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        result.upstreamHttpProtocolOptions_ = upstreamHttpProtocolOptions_;
      } else {
        result.upstreamHttpProtocolOptions_ = upstreamHttpProtocolOptionsBuilder_.build();
      }
      if (commonHttpProtocolOptionsBuilder_ == null) {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptions_;
      } else {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptionsBuilder_.build();
      }
      if (httpProtocolOptionsBuilder_ == null) {
        result.httpProtocolOptions_ = httpProtocolOptions_;
      } else {
        result.httpProtocolOptions_ = httpProtocolOptionsBuilder_.build();
      }
      if (http2ProtocolOptionsBuilder_ == null) {
        result.http2ProtocolOptions_ = http2ProtocolOptions_;
      } else {
        result.http2ProtocolOptions_ = http2ProtocolOptionsBuilder_.build();
      }
      result.typedExtensionProtocolOptions_ = internalGetTypedExtensionProtocolOptions();
      result.typedExtensionProtocolOptions_.makeImmutable();
      if (dnsRefreshRateBuilder_ == null) {
        result.dnsRefreshRate_ = dnsRefreshRate_;
      } else {
        result.dnsRefreshRate_ = dnsRefreshRateBuilder_.build();
      }
      if (dnsFailureRefreshRateBuilder_ == null) {
        result.dnsFailureRefreshRate_ = dnsFailureRefreshRate_;
      } else {
        result.dnsFailureRefreshRate_ = dnsFailureRefreshRateBuilder_.build();
      }
      result.respectDnsTtl_ = respectDnsTtl_;
      result.dnsLookupFamily_ = dnsLookupFamily_;
      if (dnsResolversBuilder_ == null) {
        if (((bitField0_ & 0x00000008) != 0)) {
          dnsResolvers_ = java.util.Collections.unmodifiableList(dnsResolvers_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.dnsResolvers_ = dnsResolvers_;
      } else {
        result.dnsResolvers_ = dnsResolversBuilder_.build();
      }
      result.useTcpForDnsLookups_ = useTcpForDnsLookups_;
      if (outlierDetectionBuilder_ == null) {
        result.outlierDetection_ = outlierDetection_;
      } else {
        result.outlierDetection_ = outlierDetectionBuilder_.build();
      }
      if (cleanupIntervalBuilder_ == null) {
        result.cleanupInterval_ = cleanupInterval_;
      } else {
        result.cleanupInterval_ = cleanupIntervalBuilder_.build();
      }
      if (upstreamBindConfigBuilder_ == null) {
        result.upstreamBindConfig_ = upstreamBindConfig_;
      } else {
        result.upstreamBindConfig_ = upstreamBindConfigBuilder_.build();
      }
      if (lbSubsetConfigBuilder_ == null) {
        result.lbSubsetConfig_ = lbSubsetConfig_;
      } else {
        result.lbSubsetConfig_ = lbSubsetConfigBuilder_.build();
      }
      if (lbConfigCase_ == 23) {
        if (ringHashLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = ringHashLbConfigBuilder_.build();
        }
      }
      if (lbConfigCase_ == 52) {
        if (maglevLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = maglevLbConfigBuilder_.build();
        }
      }
      if (lbConfigCase_ == 34) {
        if (originalDstLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = originalDstLbConfigBuilder_.build();
        }
      }
      if (lbConfigCase_ == 37) {
        if (leastRequestLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = leastRequestLbConfigBuilder_.build();
        }
      }
      if (commonLbConfigBuilder_ == null) {
        result.commonLbConfig_ = commonLbConfig_;
      } else {
        result.commonLbConfig_ = commonLbConfigBuilder_.build();
      }
      if (transportSocketBuilder_ == null) {
        result.transportSocket_ = transportSocket_;
      } else {
        result.transportSocket_ = transportSocketBuilder_.build();
      }
      if (metadataBuilder_ == null) {
        result.metadata_ = metadata_;
      } else {
        result.metadata_ = metadataBuilder_.build();
      }
      result.protocolSelection_ = protocolSelection_;
      if (upstreamConnectionOptionsBuilder_ == null) {
        result.upstreamConnectionOptions_ = upstreamConnectionOptions_;
      } else {
        result.upstreamConnectionOptions_ = upstreamConnectionOptionsBuilder_.build();
      }
      result.closeConnectionsOnHostHealthFailure_ = closeConnectionsOnHostHealthFailure_;
      result.ignoreHealthOnHostRemoval_ = ignoreHealthOnHostRemoval_;
      if (filtersBuilder_ == null) {
        if (((bitField0_ & 0x00000010) != 0)) {
          filters_ = java.util.Collections.unmodifiableList(filters_);
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.filters_ = filters_;
      } else {
        result.filters_ = filtersBuilder_.build();
      }
      if (loadBalancingPolicyBuilder_ == null) {
        result.loadBalancingPolicy_ = loadBalancingPolicy_;
      } else {
        result.loadBalancingPolicy_ = loadBalancingPolicyBuilder_.build();
      }
      if (lrsServerBuilder_ == null) {
        result.lrsServer_ = lrsServer_;
      } else {
        result.lrsServer_ = lrsServerBuilder_.build();
      }
      result.trackTimeoutBudgets_ = trackTimeoutBudgets_;
      if (upstreamConfigBuilder_ == null) {
        result.upstreamConfig_ = upstreamConfig_;
      } else {
        result.upstreamConfig_ = upstreamConfigBuilder_.build();
      }
      if (trackClusterStatsBuilder_ == null) {
        result.trackClusterStats_ = trackClusterStats_;
      } else {
        result.trackClusterStats_ = trackClusterStatsBuilder_.build();
      }
      if (preconnectPolicyBuilder_ == null) {
        result.preconnectPolicy_ = preconnectPolicy_;
      } else {
        result.preconnectPolicy_ = preconnectPolicyBuilder_.build();
      }
      result.connectionPoolPerDownstreamConnection_ = connectionPoolPerDownstreamConnection_;
      result.clusterDiscoveryTypeCase_ = clusterDiscoveryTypeCase_;
      result.lbConfigCase_ = lbConfigCase_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.envoyproxy.envoy.config.cluster.v3.Cluster) {
        return mergeFrom((io.envoyproxy.envoy.config.cluster.v3.Cluster)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.envoyproxy.envoy.config.cluster.v3.Cluster other) {
      if (other == io.envoyproxy.envoy.config.cluster.v3.Cluster.getDefaultInstance()) return this;
      if (transportSocketMatchesBuilder_ == null) {
        if (!other.transportSocketMatches_.isEmpty()) {
          if (transportSocketMatches_.isEmpty()) {
            transportSocketMatches_ = other.transportSocketMatches_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureTransportSocketMatchesIsMutable();
            transportSocketMatches_.addAll(other.transportSocketMatches_);
          }
          onChanged();
        }
      } else {
        if (!other.transportSocketMatches_.isEmpty()) {
          if (transportSocketMatchesBuilder_.isEmpty()) {
            transportSocketMatchesBuilder_.dispose();
            transportSocketMatchesBuilder_ = null;
            transportSocketMatches_ = other.transportSocketMatches_;
            bitField0_ = (bitField0_ & ~0x00000001);
            transportSocketMatchesBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getTransportSocketMatchesFieldBuilder() : null;
          } else {
            transportSocketMatchesBuilder_.addAllMessages(other.transportSocketMatches_);
          }
        }
      }
      if (!other.getName().isEmpty()) {
        name_ = other.name_;
        onChanged();
      }
      if (!other.getAltStatName().isEmpty()) {
        altStatName_ = other.altStatName_;
        onChanged();
      }
      if (other.hasEdsClusterConfig()) {
        mergeEdsClusterConfig(other.getEdsClusterConfig());
      }
      if (other.hasConnectTimeout()) {
        mergeConnectTimeout(other.getConnectTimeout());
      }
      if (other.hasPerConnectionBufferLimitBytes()) {
        mergePerConnectionBufferLimitBytes(other.getPerConnectionBufferLimitBytes());
      }
      if (other.lbPolicy_ != 0) {
        setLbPolicyValue(other.getLbPolicyValue());
      }
      if (other.hasLoadAssignment()) {
        mergeLoadAssignment(other.getLoadAssignment());
      }
      if (healthChecksBuilder_ == null) {
        if (!other.healthChecks_.isEmpty()) {
          if (healthChecks_.isEmpty()) {
            healthChecks_ = other.healthChecks_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureHealthChecksIsMutable();
            healthChecks_.addAll(other.healthChecks_);
          }
          onChanged();
        }
      } else {
        if (!other.healthChecks_.isEmpty()) {
          if (healthChecksBuilder_.isEmpty()) {
            healthChecksBuilder_.dispose();
            healthChecksBuilder_ = null;
            healthChecks_ = other.healthChecks_;
            bitField0_ = (bitField0_ & ~0x00000002);
            healthChecksBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getHealthChecksFieldBuilder() : null;
          } else {
            healthChecksBuilder_.addAllMessages(other.healthChecks_);
          }
        }
      }
      if (other.hasMaxRequestsPerConnection()) {
        mergeMaxRequestsPerConnection(other.getMaxRequestsPerConnection());
      }
      if (other.hasCircuitBreakers()) {
        mergeCircuitBreakers(other.getCircuitBreakers());
      }
      if (other.hasUpstreamHttpProtocolOptions()) {
        mergeUpstreamHttpProtocolOptions(other.getUpstreamHttpProtocolOptions());
      }
      if (other.hasCommonHttpProtocolOptions()) {
        mergeCommonHttpProtocolOptions(other.getCommonHttpProtocolOptions());
      }
      if (other.hasHttpProtocolOptions()) {
        mergeHttpProtocolOptions(other.getHttpProtocolOptions());
      }
      if (other.hasHttp2ProtocolOptions()) {
        mergeHttp2ProtocolOptions(other.getHttp2ProtocolOptions());
      }
      internalGetMutableTypedExtensionProtocolOptions().mergeFrom(
          other.internalGetTypedExtensionProtocolOptions());
      if (other.hasDnsRefreshRate()) {
        mergeDnsRefreshRate(other.getDnsRefreshRate());
      }
      if (other.hasDnsFailureRefreshRate()) {
        mergeDnsFailureRefreshRate(other.getDnsFailureRefreshRate());
      }
      if (other.getRespectDnsTtl() != false) {
        setRespectDnsTtl(other.getRespectDnsTtl());
      }
      if (other.dnsLookupFamily_ != 0) {
        setDnsLookupFamilyValue(other.getDnsLookupFamilyValue());
      }
      if (dnsResolversBuilder_ == null) {
        if (!other.dnsResolvers_.isEmpty()) {
          if (dnsResolvers_.isEmpty()) {
            dnsResolvers_ = other.dnsResolvers_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureDnsResolversIsMutable();
            dnsResolvers_.addAll(other.dnsResolvers_);
          }
          onChanged();
        }
      } else {
        if (!other.dnsResolvers_.isEmpty()) {
          if (dnsResolversBuilder_.isEmpty()) {
            dnsResolversBuilder_.dispose();
            dnsResolversBuilder_ = null;
            dnsResolvers_ = other.dnsResolvers_;
            bitField0_ = (bitField0_ & ~0x00000008);
            dnsResolversBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getDnsResolversFieldBuilder() : null;
          } else {
            dnsResolversBuilder_.addAllMessages(other.dnsResolvers_);
          }
        }
      }
      if (other.getUseTcpForDnsLookups() != false) {
        setUseTcpForDnsLookups(other.getUseTcpForDnsLookups());
      }
      if (other.hasOutlierDetection()) {
        mergeOutlierDetection(other.getOutlierDetection());
      }
      if (other.hasCleanupInterval()) {
        mergeCleanupInterval(other.getCleanupInterval());
      }
      if (other.hasUpstreamBindConfig()) {
        mergeUpstreamBindConfig(other.getUpstreamBindConfig());
      }
      if (other.hasLbSubsetConfig()) {
        mergeLbSubsetConfig(other.getLbSubsetConfig());
      }
      if (other.hasCommonLbConfig()) {
        mergeCommonLbConfig(other.getCommonLbConfig());
      }
      if (other.hasTransportSocket()) {
        mergeTransportSocket(other.getTransportSocket());
      }
      if (other.hasMetadata()) {
        mergeMetadata(other.getMetadata());
      }
      if (other.protocolSelection_ != 0) {
        setProtocolSelectionValue(other.getProtocolSelectionValue());
      }
      if (other.hasUpstreamConnectionOptions()) {
        mergeUpstreamConnectionOptions(other.getUpstreamConnectionOptions());
      }
      if (other.getCloseConnectionsOnHostHealthFailure() != false) {
        setCloseConnectionsOnHostHealthFailure(other.getCloseConnectionsOnHostHealthFailure());
      }
      if (other.getIgnoreHealthOnHostRemoval() != false) {
        setIgnoreHealthOnHostRemoval(other.getIgnoreHealthOnHostRemoval());
      }
      if (filtersBuilder_ == null) {
        if (!other.filters_.isEmpty()) {
          if (filters_.isEmpty()) {
            filters_ = other.filters_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureFiltersIsMutable();
            filters_.addAll(other.filters_);
          }
          onChanged();
        }
      } else {
        if (!other.filters_.isEmpty()) {
          if (filtersBuilder_.isEmpty()) {
            filtersBuilder_.dispose();
            filtersBuilder_ = null;
            filters_ = other.filters_;
            bitField0_ = (bitField0_ & ~0x00000010);
            filtersBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getFiltersFieldBuilder() : null;
          } else {
            filtersBuilder_.addAllMessages(other.filters_);
          }
        }
      }
      if (other.hasLoadBalancingPolicy()) {
        mergeLoadBalancingPolicy(other.getLoadBalancingPolicy());
      }
      if (other.hasLrsServer()) {
        mergeLrsServer(other.getLrsServer());
      }
      if (other.getTrackTimeoutBudgets() != false) {
        setTrackTimeoutBudgets(other.getTrackTimeoutBudgets());
      }
      if (other.hasUpstreamConfig()) {
        mergeUpstreamConfig(other.getUpstreamConfig());
      }
      if (other.hasTrackClusterStats()) {
        mergeTrackClusterStats(other.getTrackClusterStats());
      }
      if (other.hasPreconnectPolicy()) {
        mergePreconnectPolicy(other.getPreconnectPolicy());
      }
      if (other.getConnectionPoolPerDownstreamConnection() != false) {
        setConnectionPoolPerDownstreamConnection(other.getConnectionPoolPerDownstreamConnection());
      }
      switch (other.getClusterDiscoveryTypeCase()) {
        case TYPE: {
          setTypeValue(other.getTypeValue());
          break;
        }
        case CLUSTER_TYPE: {
          mergeClusterType(other.getClusterType());
          break;
        }
        case CLUSTERDISCOVERYTYPE_NOT_SET: {
          break;
        }
      }
      switch (other.getLbConfigCase()) {
        case RING_HASH_LB_CONFIG: {
          mergeRingHashLbConfig(other.getRingHashLbConfig());
          break;
        }
        case MAGLEV_LB_CONFIG: {
          mergeMaglevLbConfig(other.getMaglevLbConfig());
          break;
        }
        case ORIGINAL_DST_LB_CONFIG: {
          mergeOriginalDstLbConfig(other.getOriginalDstLbConfig());
          break;
        }
        case LEAST_REQUEST_LB_CONFIG: {
          mergeLeastRequestLbConfig(other.getLeastRequestLbConfig());
          break;
        }
        case LBCONFIG_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.envoyproxy.envoy.config.cluster.v3.Cluster parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.envoyproxy.envoy.config.cluster.v3.Cluster) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int clusterDiscoveryTypeCase_ = 0;
    private java.lang.Object clusterDiscoveryType_;
    public ClusterDiscoveryTypeCase
        getClusterDiscoveryTypeCase() {
      return ClusterDiscoveryTypeCase.forNumber(
          clusterDiscoveryTypeCase_);
    }

    public Builder clearClusterDiscoveryType() {
      clusterDiscoveryTypeCase_ = 0;
      clusterDiscoveryType_ = null;
      onChanged();
      return this;
    }

    private int lbConfigCase_ = 0;
    private java.lang.Object lbConfig_;
    public LbConfigCase
        getLbConfigCase() {
      return LbConfigCase.forNumber(
          lbConfigCase_);
    }

    public Builder clearLbConfig() {
      lbConfigCase_ = 0;
      lbConfig_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;

    private java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch> transportSocketMatches_ =
      java.util.Collections.emptyList();
    private void ensureTransportSocketMatchesIsMutable() {
      if (!((bitField0_ & 0x00000001) != 0)) {
        transportSocketMatches_ = new java.util.ArrayList<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch>(transportSocketMatches_);
        bitField0_ |= 0x00000001;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder> transportSocketMatchesBuilder_;

    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch> getTransportSocketMatchesList() {
      if (transportSocketMatchesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(transportSocketMatches_);
      } else {
        return transportSocketMatchesBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public int getTransportSocketMatchesCount() {
      if (transportSocketMatchesBuilder_ == null) {
        return transportSocketMatches_.size();
      } else {
        return transportSocketMatchesBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch getTransportSocketMatches(int index) {
      if (transportSocketMatchesBuilder_ == null) {
        return transportSocketMatches_.get(index);
      } else {
        return transportSocketMatchesBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder setTransportSocketMatches(
        int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch value) {
      if (transportSocketMatchesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.set(index, value);
        onChanged();
      } else {
        transportSocketMatchesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder setTransportSocketMatches(
        int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder builderForValue) {
      if (transportSocketMatchesBuilder_ == null) {
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.set(index, builderForValue.build());
        onChanged();
      } else {
        transportSocketMatchesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder addTransportSocketMatches(io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch value) {
      if (transportSocketMatchesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.add(value);
        onChanged();
      } else {
        transportSocketMatchesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder addTransportSocketMatches(
        int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch value) {
      if (transportSocketMatchesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.add(index, value);
        onChanged();
      } else {
        transportSocketMatchesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder addTransportSocketMatches(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder builderForValue) {
      if (transportSocketMatchesBuilder_ == null) {
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.add(builderForValue.build());
        onChanged();
      } else {
        transportSocketMatchesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder addTransportSocketMatches(
        int index, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder builderForValue) {
      if (transportSocketMatchesBuilder_ == null) {
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.add(index, builderForValue.build());
        onChanged();
      } else {
        transportSocketMatchesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder addAllTransportSocketMatches(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch> values) {
      if (transportSocketMatchesBuilder_ == null) {
        ensureTransportSocketMatchesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, transportSocketMatches_);
        onChanged();
      } else {
        transportSocketMatchesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder clearTransportSocketMatches() {
      if (transportSocketMatchesBuilder_ == null) {
        transportSocketMatches_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
      } else {
        transportSocketMatchesBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public Builder removeTransportSocketMatches(int index) {
      if (transportSocketMatchesBuilder_ == null) {
        ensureTransportSocketMatchesIsMutable();
        transportSocketMatches_.remove(index);
        onChanged();
      } else {
        transportSocketMatchesBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder getTransportSocketMatchesBuilder(
        int index) {
      return getTransportSocketMatchesFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder getTransportSocketMatchesOrBuilder(
        int index) {
      if (transportSocketMatchesBuilder_ == null) {
        return transportSocketMatches_.get(index);  } else {
        return transportSocketMatchesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder> 
         getTransportSocketMatchesOrBuilderList() {
      if (transportSocketMatchesBuilder_ != null) {
        return transportSocketMatchesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(transportSocketMatches_);
      }
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder addTransportSocketMatchesBuilder() {
      return getTransportSocketMatchesFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder addTransportSocketMatchesBuilder(
        int index) {
      return getTransportSocketMatchesFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration to use different transport sockets for different endpoints.
     * The entry of *envoy.transport_socket_match* in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
     * For example, with the following match
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
     * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
     * *transport_socket* specified in this cluster.
     * This field allows gradual and flexible transport socket configuration changes.
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
     * *transport_socket_match* set, and still send plain text traffic to the same cluster.
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder> 
         getTransportSocketMatchesBuilderList() {
      return getTransportSocketMatchesFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder> 
        getTransportSocketMatchesFieldBuilder() {
      if (transportSocketMatchesBuilder_ == null) {
        transportSocketMatchesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder>(
                transportSocketMatches_,
                ((bitField0_ & 0x00000001) != 0),
                getParentForChildren(),
                isClean());
        transportSocketMatches_ = null;
      }
      return transportSocketMatchesBuilder_;
    }

    private java.lang.Object name_ = "";
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      name_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearName() {
      
      name_ = getDefaultInstance().getName();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      name_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object altStatName_ = "";
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     * @return The altStatName.
     */
    public java.lang.String getAltStatName() {
      java.lang.Object ref = altStatName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        altStatName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     * @return The bytes for altStatName.
     */
    public com.google.protobuf.ByteString
        getAltStatNameBytes() {
      java.lang.Object ref = altStatName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        altStatName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     * @param value The altStatName to set.
     * @return This builder for chaining.
     */
    public Builder setAltStatName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      altStatName_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     * @return This builder for chaining.
     */
    public Builder clearAltStatName() {
      
      altStatName_ = getDefaultInstance().getAltStatName();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     * @param value The bytes for altStatName to set.
     * @return This builder for chaining.
     */
    public Builder setAltStatNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      altStatName_ = value;
      onChanged();
      return this;
    }

    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return clusterDiscoveryTypeCase_ == 2;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override
    public int getTypeValue() {
      if (clusterDiscoveryTypeCase_ == 2) {
        return ((java.lang.Integer) clusterDiscoveryType_).intValue();
      }
      return 0;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for type to set.
     * @return This builder for chaining.
     */
    public Builder setTypeValue(int value) {
      clusterDiscoveryTypeCase_ = 2;
      clusterDiscoveryType_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     * @return The type.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType getType() {
      if (clusterDiscoveryTypeCase_ == 2) {
        @SuppressWarnings("deprecation")
        io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType result = io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType.valueOf(
            (java.lang.Integer) clusterDiscoveryType_);
        return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType.UNRECOGNIZED : result;
      }
      return io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType.STATIC;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     * @param value The type to set.
     * @return This builder for chaining.
     */
    public Builder setType(io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      clusterDiscoveryTypeCase_ = 2;
      clusterDiscoveryType_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearType() {
      if (clusterDiscoveryTypeCase_ == 2) {
        clusterDiscoveryTypeCase_ = 0;
        clusterDiscoveryType_ = null;
        onChanged();
      }
      return this;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder> clusterTypeBuilder_;
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     * @return Whether the clusterType field is set.
     */
    @java.lang.Override
    public boolean hasClusterType() {
      return clusterDiscoveryTypeCase_ == 38;
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     * @return The clusterType.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType getClusterType() {
      if (clusterTypeBuilder_ == null) {
        if (clusterDiscoveryTypeCase_ == 38) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
      } else {
        if (clusterDiscoveryTypeCase_ == 38) {
          return clusterTypeBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    public Builder setClusterType(io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType value) {
      if (clusterTypeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        clusterDiscoveryType_ = value;
        onChanged();
      } else {
        clusterTypeBuilder_.setMessage(value);
      }
      clusterDiscoveryTypeCase_ = 38;
      return this;
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    public Builder setClusterType(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder builderForValue) {
      if (clusterTypeBuilder_ == null) {
        clusterDiscoveryType_ = builderForValue.build();
        onChanged();
      } else {
        clusterTypeBuilder_.setMessage(builderForValue.build());
      }
      clusterDiscoveryTypeCase_ = 38;
      return this;
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    public Builder mergeClusterType(io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType value) {
      if (clusterTypeBuilder_ == null) {
        if (clusterDiscoveryTypeCase_ == 38 &&
            clusterDiscoveryType_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance()) {
          clusterDiscoveryType_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_)
              .mergeFrom(value).buildPartial();
        } else {
          clusterDiscoveryType_ = value;
        }
        onChanged();
      } else {
        if (clusterDiscoveryTypeCase_ == 38) {
          clusterTypeBuilder_.mergeFrom(value);
        }
        clusterTypeBuilder_.setMessage(value);
      }
      clusterDiscoveryTypeCase_ = 38;
      return this;
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    public Builder clearClusterType() {
      if (clusterTypeBuilder_ == null) {
        if (clusterDiscoveryTypeCase_ == 38) {
          clusterDiscoveryTypeCase_ = 0;
          clusterDiscoveryType_ = null;
          onChanged();
        }
      } else {
        if (clusterDiscoveryTypeCase_ == 38) {
          clusterDiscoveryTypeCase_ = 0;
          clusterDiscoveryType_ = null;
        }
        clusterTypeBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder getClusterTypeBuilder() {
      return getClusterTypeFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder getClusterTypeOrBuilder() {
      if ((clusterDiscoveryTypeCase_ == 38) && (clusterTypeBuilder_ != null)) {
        return clusterTypeBuilder_.getMessageOrBuilder();
      } else {
        if (clusterDiscoveryTypeCase_ == 38) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The custom cluster type.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder> 
        getClusterTypeFieldBuilder() {
      if (clusterTypeBuilder_ == null) {
        if (!(clusterDiscoveryTypeCase_ == 38)) {
          clusterDiscoveryType_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.getDefaultInstance();
        }
        clusterTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder>(
                (io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType) clusterDiscoveryType_,
                getParentForChildren(),
                isClean());
        clusterDiscoveryType_ = null;
      }
      clusterDiscoveryTypeCase_ = 38;
      onChanged();;
      return clusterTypeBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig edsClusterConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder> edsClusterConfigBuilder_;
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     * @return Whether the edsClusterConfig field is set.
     */
    public boolean hasEdsClusterConfig() {
      return edsClusterConfigBuilder_ != null || edsClusterConfig_ != null;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     * @return The edsClusterConfig.
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig getEdsClusterConfig() {
      if (edsClusterConfigBuilder_ == null) {
        return edsClusterConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.getDefaultInstance() : edsClusterConfig_;
      } else {
        return edsClusterConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder setEdsClusterConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig value) {
      if (edsClusterConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        edsClusterConfig_ = value;
        onChanged();
      } else {
        edsClusterConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder setEdsClusterConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder builderForValue) {
      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfig_ = builderForValue.build();
        onChanged();
      } else {
        edsClusterConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder mergeEdsClusterConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig value) {
      if (edsClusterConfigBuilder_ == null) {
        if (edsClusterConfig_ != null) {
          edsClusterConfig_ =
            io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.newBuilder(edsClusterConfig_).mergeFrom(value).buildPartial();
        } else {
          edsClusterConfig_ = value;
        }
        onChanged();
      } else {
        edsClusterConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder clearEdsClusterConfig() {
      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfig_ = null;
        onChanged();
      } else {
        edsClusterConfig_ = null;
        edsClusterConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder getEdsClusterConfigBuilder() {
      
      onChanged();
      return getEdsClusterConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder getEdsClusterConfigOrBuilder() {
      if (edsClusterConfigBuilder_ != null) {
        return edsClusterConfigBuilder_.getMessageOrBuilder();
      } else {
        return edsClusterConfig_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.getDefaultInstance() : edsClusterConfig_;
      }
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder> 
        getEdsClusterConfigFieldBuilder() {
      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder>(
                getEdsClusterConfig(),
                getParentForChildren(),
                isClean());
        edsClusterConfig_ = null;
      }
      return edsClusterConfigBuilder_;
    }

    private com.google.protobuf.Duration connectTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> connectTimeoutBuilder_;
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     * @return Whether the connectTimeout field is set.
     */
    public boolean hasConnectTimeout() {
      return connectTimeoutBuilder_ != null || connectTimeout_ != null;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     * @return The connectTimeout.
     */
    public com.google.protobuf.Duration getConnectTimeout() {
      if (connectTimeoutBuilder_ == null) {
        return connectTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : connectTimeout_;
      } else {
        return connectTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder setConnectTimeout(com.google.protobuf.Duration value) {
      if (connectTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        connectTimeout_ = value;
        onChanged();
      } else {
        connectTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder setConnectTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (connectTimeoutBuilder_ == null) {
        connectTimeout_ = builderForValue.build();
        onChanged();
      } else {
        connectTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeConnectTimeout(com.google.protobuf.Duration value) {
      if (connectTimeoutBuilder_ == null) {
        if (connectTimeout_ != null) {
          connectTimeout_ =
            com.google.protobuf.Duration.newBuilder(connectTimeout_).mergeFrom(value).buildPartial();
        } else {
          connectTimeout_ = value;
        }
        onChanged();
      } else {
        connectTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder clearConnectTimeout() {
      if (connectTimeoutBuilder_ == null) {
        connectTimeout_ = null;
        onChanged();
      } else {
        connectTimeout_ = null;
        connectTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getConnectTimeoutBuilder() {
      
      onChanged();
      return getConnectTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getConnectTimeoutOrBuilder() {
      if (connectTimeoutBuilder_ != null) {
        return connectTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return connectTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : connectTimeout_;
      }
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getConnectTimeoutFieldBuilder() {
      if (connectTimeoutBuilder_ == null) {
        connectTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getConnectTimeout(),
                getParentForChildren(),
                isClean());
        connectTimeout_ = null;
      }
      return connectTimeoutBuilder_;
    }

    private com.google.protobuf.UInt32Value perConnectionBufferLimitBytes_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> perConnectionBufferLimitBytesBuilder_;
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the perConnectionBufferLimitBytes field is set.
     */
    public boolean hasPerConnectionBufferLimitBytes() {
      return perConnectionBufferLimitBytesBuilder_ != null || perConnectionBufferLimitBytes_ != null;
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     * @return The perConnectionBufferLimitBytes.
     */
    public com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
      } else {
        return perConnectionBufferLimitBytesBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setPerConnectionBufferLimitBytes(com.google.protobuf.UInt32Value value) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        perConnectionBufferLimitBytes_ = value;
        onChanged();
      } else {
        perConnectionBufferLimitBytesBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setPerConnectionBufferLimitBytes(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = builderForValue.build();
        onChanged();
      } else {
        perConnectionBufferLimitBytesBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergePerConnectionBufferLimitBytes(com.google.protobuf.UInt32Value value) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        if (perConnectionBufferLimitBytes_ != null) {
          perConnectionBufferLimitBytes_ =
            com.google.protobuf.UInt32Value.newBuilder(perConnectionBufferLimitBytes_).mergeFrom(value).buildPartial();
        } else {
          perConnectionBufferLimitBytes_ = value;
        }
        onChanged();
      } else {
        perConnectionBufferLimitBytesBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearPerConnectionBufferLimitBytes() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = null;
        onChanged();
      } else {
        perConnectionBufferLimitBytes_ = null;
        perConnectionBufferLimitBytesBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value.Builder getPerConnectionBufferLimitBytesBuilder() {
      
      onChanged();
      return getPerConnectionBufferLimitBytesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder() {
      if (perConnectionBufferLimitBytesBuilder_ != null) {
        return perConnectionBufferLimitBytesBuilder_.getMessageOrBuilder();
      } else {
        return perConnectionBufferLimitBytes_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
      }
    }
    /**
     * <pre>
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getPerConnectionBufferLimitBytesFieldBuilder() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getPerConnectionBufferLimitBytes(),
                getParentForChildren(),
                isClean());
        perConnectionBufferLimitBytes_ = null;
      }
      return perConnectionBufferLimitBytesBuilder_;
    }

    private int lbPolicy_ = 0;
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for lbPolicy.
     */
    @java.lang.Override public int getLbPolicyValue() {
      return lbPolicy_;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for lbPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setLbPolicyValue(int value) {
      
      lbPolicy_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     * @return The lbPolicy.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy getLbPolicy() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy result = io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy.valueOf(lbPolicy_);
      return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     * @param value The lbPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setLbPolicy(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      lbPolicy_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearLbPolicy() {
      
      lbPolicy_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment loadAssignment_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment, io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Builder, io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignmentOrBuilder> loadAssignmentBuilder_;
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     * @return Whether the loadAssignment field is set.
     */
    public boolean hasLoadAssignment() {
      return loadAssignmentBuilder_ != null || loadAssignment_ != null;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     * @return The loadAssignment.
     */
    public io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment getLoadAssignment() {
      if (loadAssignmentBuilder_ == null) {
        return loadAssignment_ == null ? io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.getDefaultInstance() : loadAssignment_;
      } else {
        return loadAssignmentBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder setLoadAssignment(io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment value) {
      if (loadAssignmentBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        loadAssignment_ = value;
        onChanged();
      } else {
        loadAssignmentBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder setLoadAssignment(
        io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Builder builderForValue) {
      if (loadAssignmentBuilder_ == null) {
        loadAssignment_ = builderForValue.build();
        onChanged();
      } else {
        loadAssignmentBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder mergeLoadAssignment(io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment value) {
      if (loadAssignmentBuilder_ == null) {
        if (loadAssignment_ != null) {
          loadAssignment_ =
            io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.newBuilder(loadAssignment_).mergeFrom(value).buildPartial();
        } else {
          loadAssignment_ = value;
        }
        onChanged();
      } else {
        loadAssignmentBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder clearLoadAssignment() {
      if (loadAssignmentBuilder_ == null) {
        loadAssignment_ = null;
        onChanged();
      } else {
        loadAssignment_ = null;
        loadAssignmentBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Builder getLoadAssignmentBuilder() {
      
      onChanged();
      return getLoadAssignmentFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignmentOrBuilder getLoadAssignmentOrBuilder() {
      if (loadAssignmentBuilder_ != null) {
        return loadAssignmentBuilder_.getMessageOrBuilder();
      } else {
        return loadAssignment_ == null ?
            io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.getDefaultInstance() : loadAssignment_;
      }
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes the *hosts* field in the v2 API.
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
     * </pre>
     *
     * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment, io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Builder, io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignmentOrBuilder> 
        getLoadAssignmentFieldBuilder() {
      if (loadAssignmentBuilder_ == null) {
        loadAssignmentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment, io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment.Builder, io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignmentOrBuilder>(
                getLoadAssignment(),
                getParentForChildren(),
                isClean());
        loadAssignment_ = null;
      }
      return loadAssignmentBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck> healthChecks_ =
      java.util.Collections.emptyList();
    private void ensureHealthChecksIsMutable() {
      if (!((bitField0_ & 0x00000002) != 0)) {
        healthChecks_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.HealthCheck>(healthChecks_);
        bitField0_ |= 0x00000002;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder> healthChecksBuilder_;

    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck> getHealthChecksList() {
      if (healthChecksBuilder_ == null) {
        return java.util.Collections.unmodifiableList(healthChecks_);
      } else {
        return healthChecksBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public int getHealthChecksCount() {
      if (healthChecksBuilder_ == null) {
        return healthChecks_.size();
      } else {
        return healthChecksBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck getHealthChecks(int index) {
      if (healthChecksBuilder_ == null) {
        return healthChecks_.get(index);
      } else {
        return healthChecksBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder setHealthChecks(
        int index, io.envoyproxy.envoy.config.core.v3.HealthCheck value) {
      if (healthChecksBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHealthChecksIsMutable();
        healthChecks_.set(index, value);
        onChanged();
      } else {
        healthChecksBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder setHealthChecks(
        int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder builderForValue) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.set(index, builderForValue.build());
        onChanged();
      } else {
        healthChecksBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(io.envoyproxy.envoy.config.core.v3.HealthCheck value) {
      if (healthChecksBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHealthChecksIsMutable();
        healthChecks_.add(value);
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(
        int index, io.envoyproxy.envoy.config.core.v3.HealthCheck value) {
      if (healthChecksBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHealthChecksIsMutable();
        healthChecks_.add(index, value);
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(
        io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder builderForValue) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.add(builderForValue.build());
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(
        int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder builderForValue) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.add(index, builderForValue.build());
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder addAllHealthChecks(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck> values) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, healthChecks_);
        onChanged();
      } else {
        healthChecksBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder clearHealthChecks() {
      if (healthChecksBuilder_ == null) {
        healthChecks_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
      } else {
        healthChecksBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public Builder removeHealthChecks(int index) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.remove(index);
        onChanged();
      } else {
        healthChecksBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder getHealthChecksBuilder(
        int index) {
      return getHealthChecksFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder getHealthChecksOrBuilder(
        int index) {
      if (healthChecksBuilder_ == null) {
        return healthChecks_.get(index);  } else {
        return healthChecksBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder> 
         getHealthChecksOrBuilderList() {
      if (healthChecksBuilder_ != null) {
        return healthChecksBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(healthChecks_);
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder addHealthChecksBuilder() {
      return getHealthChecksFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.core.v3.HealthCheck.getDefaultInstance());
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder addHealthChecksBuilder(
        int index) {
      return getHealthChecksFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.core.v3.HealthCheck.getDefaultInstance());
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder> 
         getHealthChecksBuilderList() {
      return getHealthChecksFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder> 
        getHealthChecksFieldBuilder() {
      if (healthChecksBuilder_ == null) {
        healthChecksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder>(
                healthChecks_,
                ((bitField0_ & 0x00000002) != 0),
                getParentForChildren(),
                isClean());
        healthChecks_ = null;
      }
      return healthChecksBuilder_;
    }

    private com.google.protobuf.UInt32Value maxRequestsPerConnection_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxRequestsPerConnectionBuilder_;
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     * @return Whether the maxRequestsPerConnection field is set.
     */
    public boolean hasMaxRequestsPerConnection() {
      return maxRequestsPerConnectionBuilder_ != null || maxRequestsPerConnection_ != null;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     * @return The maxRequestsPerConnection.
     */
    public com.google.protobuf.UInt32Value getMaxRequestsPerConnection() {
      if (maxRequestsPerConnectionBuilder_ == null) {
        return maxRequestsPerConnection_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestsPerConnection_;
      } else {
        return maxRequestsPerConnectionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder setMaxRequestsPerConnection(com.google.protobuf.UInt32Value value) {
      if (maxRequestsPerConnectionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxRequestsPerConnection_ = value;
        onChanged();
      } else {
        maxRequestsPerConnectionBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder setMaxRequestsPerConnection(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnection_ = builderForValue.build();
        onChanged();
      } else {
        maxRequestsPerConnectionBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder mergeMaxRequestsPerConnection(com.google.protobuf.UInt32Value value) {
      if (maxRequestsPerConnectionBuilder_ == null) {
        if (maxRequestsPerConnection_ != null) {
          maxRequestsPerConnection_ =
            com.google.protobuf.UInt32Value.newBuilder(maxRequestsPerConnection_).mergeFrom(value).buildPartial();
        } else {
          maxRequestsPerConnection_ = value;
        }
        onChanged();
      } else {
        maxRequestsPerConnectionBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder clearMaxRequestsPerConnection() {
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnection_ = null;
        onChanged();
      } else {
        maxRequestsPerConnection_ = null;
        maxRequestsPerConnectionBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getMaxRequestsPerConnectionBuilder() {
      
      onChanged();
      return getMaxRequestsPerConnectionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestsPerConnectionOrBuilder() {
      if (maxRequestsPerConnectionBuilder_ != null) {
        return maxRequestsPerConnectionBuilder_.getMessageOrBuilder();
      } else {
        return maxRequestsPerConnection_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestsPerConnection_;
      }
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getMaxRequestsPerConnectionFieldBuilder() {
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnectionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getMaxRequestsPerConnection(),
                getParentForChildren(),
                isClean());
        maxRequestsPerConnection_ = null;
      }
      return maxRequestsPerConnectionBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers circuitBreakers_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers, io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.Builder, io.envoyproxy.envoy.config.cluster.v3.CircuitBreakersOrBuilder> circuitBreakersBuilder_;
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     * @return Whether the circuitBreakers field is set.
     */
    public boolean hasCircuitBreakers() {
      return circuitBreakersBuilder_ != null || circuitBreakers_ != null;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     * @return The circuitBreakers.
     */
    public io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers getCircuitBreakers() {
      if (circuitBreakersBuilder_ == null) {
        return circuitBreakers_ == null ? io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.getDefaultInstance() : circuitBreakers_;
      } else {
        return circuitBreakersBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder setCircuitBreakers(io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers value) {
      if (circuitBreakersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        circuitBreakers_ = value;
        onChanged();
      } else {
        circuitBreakersBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder setCircuitBreakers(
        io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.Builder builderForValue) {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = builderForValue.build();
        onChanged();
      } else {
        circuitBreakersBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder mergeCircuitBreakers(io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers value) {
      if (circuitBreakersBuilder_ == null) {
        if (circuitBreakers_ != null) {
          circuitBreakers_ =
            io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.newBuilder(circuitBreakers_).mergeFrom(value).buildPartial();
        } else {
          circuitBreakers_ = value;
        }
        onChanged();
      } else {
        circuitBreakersBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder clearCircuitBreakers() {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = null;
        onChanged();
      } else {
        circuitBreakers_ = null;
        circuitBreakersBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.Builder getCircuitBreakersBuilder() {
      
      onChanged();
      return getCircuitBreakersFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder() {
      if (circuitBreakersBuilder_ != null) {
        return circuitBreakersBuilder_.getMessageOrBuilder();
      } else {
        return circuitBreakers_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.getDefaultInstance() : circuitBreakers_;
      }
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers, io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.Builder, io.envoyproxy.envoy.config.cluster.v3.CircuitBreakersOrBuilder> 
        getCircuitBreakersFieldBuilder() {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers, io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers.Builder, io.envoyproxy.envoy.config.cluster.v3.CircuitBreakersOrBuilder>(
                getCircuitBreakers(),
                getParentForChildren(),
                isClean());
        circuitBreakers_ = null;
      }
      return circuitBreakersBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions upstreamHttpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptionsOrBuilder> upstreamHttpProtocolOptionsBuilder_;
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     * @return Whether the upstreamHttpProtocolOptions field is set.
     */
    @java.lang.Deprecated public boolean hasUpstreamHttpProtocolOptions() {
      return upstreamHttpProtocolOptionsBuilder_ != null || upstreamHttpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     * @return The upstreamHttpProtocolOptions.
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions getUpstreamHttpProtocolOptions() {
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        return upstreamHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.getDefaultInstance() : upstreamHttpProtocolOptions_;
      } else {
        return upstreamHttpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setUpstreamHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions value) {
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        upstreamHttpProtocolOptions_ = value;
        onChanged();
      } else {
        upstreamHttpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setUpstreamHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.Builder builderForValue) {
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        upstreamHttpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        upstreamHttpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder mergeUpstreamHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions value) {
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        if (upstreamHttpProtocolOptions_ != null) {
          upstreamHttpProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.newBuilder(upstreamHttpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          upstreamHttpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        upstreamHttpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearUpstreamHttpProtocolOptions() {
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        upstreamHttpProtocolOptions_ = null;
        onChanged();
      } else {
        upstreamHttpProtocolOptions_ = null;
        upstreamHttpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.Builder getUpstreamHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getUpstreamHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptionsOrBuilder getUpstreamHttpProtocolOptionsOrBuilder() {
      if (upstreamHttpProtocolOptionsBuilder_ != null) {
        return upstreamHttpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return upstreamHttpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.getDefaultInstance() : upstreamHttpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptionsOrBuilder> 
        getUpstreamHttpProtocolOptionsFieldBuilder() {
      if (upstreamHttpProtocolOptionsBuilder_ == null) {
        upstreamHttpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptionsOrBuilder>(
                getUpstreamHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        upstreamHttpProtocolOptions_ = null;
      }
      return upstreamHttpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions commonHttpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder> commonHttpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     * @return Whether the commonHttpProtocolOptions field is set.
     */
    @java.lang.Deprecated public boolean hasCommonHttpProtocolOptions() {
      return commonHttpProtocolOptionsBuilder_ != null || commonHttpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     * @return The commonHttpProtocolOptions.
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      } else {
        return commonHttpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setCommonHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        commonHttpProtocolOptions_ = value;
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setCommonHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder builderForValue) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder mergeCommonHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (commonHttpProtocolOptions_ != null) {
          commonHttpProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.newBuilder(commonHttpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          commonHttpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = null;
        onChanged();
      } else {
        commonHttpProtocolOptions_ = null;
        commonHttpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder getCommonHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getCommonHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
      if (commonHttpProtocolOptionsBuilder_ != null) {
        return commonHttpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return commonHttpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
     * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder> 
        getCommonHttpProtocolOptionsFieldBuilder() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder>(
                getCommonHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        commonHttpProtocolOptions_ = null;
      }
      return commonHttpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions httpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder> httpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     * @return Whether the httpProtocolOptions field is set.
     */
    @java.lang.Deprecated public boolean hasHttpProtocolOptions() {
      return httpProtocolOptionsBuilder_ != null || httpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     * @return The httpProtocolOptions.
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      } else {
        return httpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        httpProtocolOptions_ = value;
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder builderForValue) {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder mergeHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (httpProtocolOptions_ != null) {
          httpProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.newBuilder(httpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          httpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = null;
        onChanged();
      } else {
        httpProtocolOptions_ = null;
        httpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder getHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
      if (httpProtocolOptionsBuilder_ != null) {
        return httpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return httpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder> 
        getHttpProtocolOptionsFieldBuilder() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder>(
                getHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        httpProtocolOptions_ = null;
      }
      return httpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions http2ProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder> http2ProtocolOptionsBuilder_;
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     * @return Whether the http2ProtocolOptions field is set.
     */
    @java.lang.Deprecated public boolean hasHttp2ProtocolOptions() {
      return http2ProtocolOptionsBuilder_ != null || http2ProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     * @return The http2ProtocolOptions.
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      } else {
        return http2ProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    @java.lang.Deprecated public Builder setHttp2ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        http2ProtocolOptions_ = value;
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    @java.lang.Deprecated public Builder setHttp2ProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder builderForValue) {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    @java.lang.Deprecated public Builder mergeHttp2ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (http2ProtocolOptions_ != null) {
          http2ProtocolOptions_ =
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.newBuilder(http2ProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          http2ProtocolOptions_ = value;
        }
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    @java.lang.Deprecated public Builder clearHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = null;
        onChanged();
      } else {
        http2ProtocolOptions_ = null;
        http2ProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder getHttp2ProtocolOptionsBuilder() {
      
      onChanged();
      return getHttp2ProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
      if (http2ProtocolOptionsBuilder_ != null) {
        return http2ProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return http2ProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the in the
     * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * See ref:`upstream_http_protocol_options
     * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
     * for example usage.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder> 
        getHttp2ProtocolOptionsFieldBuilder() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder>(
                getHttp2ProtocolOptions(),
                getParentForChildren(),
                isClean());
        http2ProtocolOptions_ = null;
      }
      return http2ProtocolOptionsBuilder_;
    }

    private com.google.protobuf.MapField<
        java.lang.String, com.google.protobuf.Any> typedExtensionProtocolOptions_;
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Any>
    internalGetTypedExtensionProtocolOptions() {
      if (typedExtensionProtocolOptions_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
      }
      return typedExtensionProtocolOptions_;
    }
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Any>
    internalGetMutableTypedExtensionProtocolOptions() {
      onChanged();;
      if (typedExtensionProtocolOptions_ == null) {
        typedExtensionProtocolOptions_ = com.google.protobuf.MapField.newMapField(
            TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
      }
      if (!typedExtensionProtocolOptions_.isMutable()) {
        typedExtensionProtocolOptions_ = typedExtensionProtocolOptions_.copy();
      }
      return typedExtensionProtocolOptions_;
    }

    public int getTypedExtensionProtocolOptionsCount() {
      return internalGetTypedExtensionProtocolOptions().getMap().size();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    @java.lang.Override
    public boolean containsTypedExtensionProtocolOptions(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetTypedExtensionProtocolOptions().getMap().containsKey(key);
    }
    /**
     * Use {@link #getTypedExtensionProtocolOptionsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptions() {
      return getTypedExtensionProtocolOptionsMap();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptionsMap() {
      return internalGetTypedExtensionProtocolOptions().getMap();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */
    @java.lang.Override

    public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrDefault(
        java.lang.String key,
        com.google.protobuf.Any defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.Any> map =
          internalGetTypedExtensionProtocolOptions().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */
    @java.lang.Override

    public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.Any> map =
          internalGetTypedExtensionProtocolOptions().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public Builder clearTypedExtensionProtocolOptions() {
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public Builder removeTypedExtensionProtocolOptions(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.Any>
    getMutableTypedExtensionProtocolOptions() {
      return internalGetMutableTypedExtensionProtocolOptions().getMutableMap();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */
    public Builder putTypedExtensionProtocolOptions(
        java.lang.String key,
        com.google.protobuf.Any value) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      if (value == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .put(key, value);
      return this;
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public Builder putAllTypedExtensionProtocolOptions(
        java.util.Map<java.lang.String, com.google.protobuf.Any> values) {
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .putAll(values);
      return this;
    }

    private com.google.protobuf.Duration dnsRefreshRate_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> dnsRefreshRateBuilder_;
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     * @return Whether the dnsRefreshRate field is set.
     */
    public boolean hasDnsRefreshRate() {
      return dnsRefreshRateBuilder_ != null || dnsRefreshRate_ != null;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     * @return The dnsRefreshRate.
     */
    public com.google.protobuf.Duration getDnsRefreshRate() {
      if (dnsRefreshRateBuilder_ == null) {
        return dnsRefreshRate_ == null ? com.google.protobuf.Duration.getDefaultInstance() : dnsRefreshRate_;
      } else {
        return dnsRefreshRateBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder setDnsRefreshRate(com.google.protobuf.Duration value) {
      if (dnsRefreshRateBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        dnsRefreshRate_ = value;
        onChanged();
      } else {
        dnsRefreshRateBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder setDnsRefreshRate(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRate_ = builderForValue.build();
        onChanged();
      } else {
        dnsRefreshRateBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeDnsRefreshRate(com.google.protobuf.Duration value) {
      if (dnsRefreshRateBuilder_ == null) {
        if (dnsRefreshRate_ != null) {
          dnsRefreshRate_ =
            com.google.protobuf.Duration.newBuilder(dnsRefreshRate_).mergeFrom(value).buildPartial();
        } else {
          dnsRefreshRate_ = value;
        }
        onChanged();
      } else {
        dnsRefreshRateBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder clearDnsRefreshRate() {
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRate_ = null;
        onChanged();
      } else {
        dnsRefreshRate_ = null;
        dnsRefreshRateBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getDnsRefreshRateBuilder() {
      
      onChanged();
      return getDnsRefreshRateFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder() {
      if (dnsRefreshRateBuilder_ != null) {
        return dnsRefreshRateBuilder_.getMessageOrBuilder();
      } else {
        return dnsRefreshRate_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : dnsRefreshRate_;
      }
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getDnsRefreshRateFieldBuilder() {
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getDnsRefreshRate(),
                getParentForChildren(),
                isClean());
        dnsRefreshRate_ = null;
      }
      return dnsRefreshRateBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate dnsFailureRefreshRate_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder> dnsFailureRefreshRateBuilder_;
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     * @return Whether the dnsFailureRefreshRate field is set.
     */
    public boolean hasDnsFailureRefreshRate() {
      return dnsFailureRefreshRateBuilder_ != null || dnsFailureRefreshRate_ != null;
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     * @return The dnsFailureRefreshRate.
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDnsFailureRefreshRate() {
      if (dnsFailureRefreshRateBuilder_ == null) {
        return dnsFailureRefreshRate_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.getDefaultInstance() : dnsFailureRefreshRate_;
      } else {
        return dnsFailureRefreshRateBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    public Builder setDnsFailureRefreshRate(io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate value) {
      if (dnsFailureRefreshRateBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        dnsFailureRefreshRate_ = value;
        onChanged();
      } else {
        dnsFailureRefreshRateBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    public Builder setDnsFailureRefreshRate(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder builderForValue) {
      if (dnsFailureRefreshRateBuilder_ == null) {
        dnsFailureRefreshRate_ = builderForValue.build();
        onChanged();
      } else {
        dnsFailureRefreshRateBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    public Builder mergeDnsFailureRefreshRate(io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate value) {
      if (dnsFailureRefreshRateBuilder_ == null) {
        if (dnsFailureRefreshRate_ != null) {
          dnsFailureRefreshRate_ =
            io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.newBuilder(dnsFailureRefreshRate_).mergeFrom(value).buildPartial();
        } else {
          dnsFailureRefreshRate_ = value;
        }
        onChanged();
      } else {
        dnsFailureRefreshRateBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    public Builder clearDnsFailureRefreshRate() {
      if (dnsFailureRefreshRateBuilder_ == null) {
        dnsFailureRefreshRate_ = null;
        onChanged();
      } else {
        dnsFailureRefreshRate_ = null;
        dnsFailureRefreshRateBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder getDnsFailureRefreshRateBuilder() {
      
      onChanged();
      return getDnsFailureRefreshRateFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder getDnsFailureRefreshRateOrBuilder() {
      if (dnsFailureRefreshRateBuilder_ != null) {
        return dnsFailureRefreshRateBuilder_.getMessageOrBuilder();
      } else {
        return dnsFailureRefreshRate_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.getDefaultInstance() : dnsFailureRefreshRate_;
      }
    }
    /**
     * <pre>
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
     * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
     * ignored.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder> 
        getDnsFailureRefreshRateFieldBuilder() {
      if (dnsFailureRefreshRateBuilder_ == null) {
        dnsFailureRefreshRateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder>(
                getDnsFailureRefreshRate(),
                getParentForChildren(),
                isClean());
        dnsFailureRefreshRate_ = null;
      }
      return dnsFailureRefreshRateBuilder_;
    }

    private boolean respectDnsTtl_ ;
    /**
     * <pre>
     * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
     * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
     * resolution.
     * </pre>
     *
     * <code>bool respect_dns_ttl = 39;</code>
     * @return The respectDnsTtl.
     */
    @java.lang.Override
    public boolean getRespectDnsTtl() {
      return respectDnsTtl_;
    }
    /**
     * <pre>
     * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
     * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
     * resolution.
     * </pre>
     *
     * <code>bool respect_dns_ttl = 39;</code>
     * @param value The respectDnsTtl to set.
     * @return This builder for chaining.
     */
    public Builder setRespectDnsTtl(boolean value) {
      
      respectDnsTtl_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
     * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
     * resolution.
     * </pre>
     *
     * <code>bool respect_dns_ttl = 39;</code>
     * @return This builder for chaining.
     */
    public Builder clearRespectDnsTtl() {
      
      respectDnsTtl_ = false;
      onChanged();
      return this;
    }

    private int dnsLookupFamily_ = 0;
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for dnsLookupFamily.
     */
    @java.lang.Override public int getDnsLookupFamilyValue() {
      return dnsLookupFamily_;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for dnsLookupFamily to set.
     * @return This builder for chaining.
     */
    public Builder setDnsLookupFamilyValue(int value) {
      
      dnsLookupFamily_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     * @return The dnsLookupFamily.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily getDnsLookupFamily() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily result = io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily.valueOf(dnsLookupFamily_);
      return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     * @param value The dnsLookupFamily to set.
     * @return This builder for chaining.
     */
    public Builder setDnsLookupFamily(io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      dnsLookupFamily_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearDnsLookupFamily() {
      
      dnsLookupFamily_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.config.core.v3.Address> dnsResolvers_ =
      java.util.Collections.emptyList();
    private void ensureDnsResolversIsMutable() {
      if (!((bitField0_ & 0x00000008) != 0)) {
        dnsResolvers_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.Address>(dnsResolvers_);
        bitField0_ |= 0x00000008;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Address, io.envoyproxy.envoy.config.core.v3.Address.Builder, io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> dnsResolversBuilder_;

    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.Address> getDnsResolversList() {
      if (dnsResolversBuilder_ == null) {
        return java.util.Collections.unmodifiableList(dnsResolvers_);
      } else {
        return dnsResolversBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public int getDnsResolversCount() {
      if (dnsResolversBuilder_ == null) {
        return dnsResolvers_.size();
      } else {
        return dnsResolversBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Address getDnsResolvers(int index) {
      if (dnsResolversBuilder_ == null) {
        return dnsResolvers_.get(index);
      } else {
        return dnsResolversBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder setDnsResolvers(
        int index, io.envoyproxy.envoy.config.core.v3.Address value) {
      if (dnsResolversBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDnsResolversIsMutable();
        dnsResolvers_.set(index, value);
        onChanged();
      } else {
        dnsResolversBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder setDnsResolvers(
        int index, io.envoyproxy.envoy.config.core.v3.Address.Builder builderForValue) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.set(index, builderForValue.build());
        onChanged();
      } else {
        dnsResolversBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(io.envoyproxy.envoy.config.core.v3.Address value) {
      if (dnsResolversBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(value);
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(
        int index, io.envoyproxy.envoy.config.core.v3.Address value) {
      if (dnsResolversBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(index, value);
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(
        io.envoyproxy.envoy.config.core.v3.Address.Builder builderForValue) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(builderForValue.build());
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(
        int index, io.envoyproxy.envoy.config.core.v3.Address.Builder builderForValue) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(index, builderForValue.build());
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder addAllDnsResolvers(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.Address> values) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dnsResolvers_);
        onChanged();
      } else {
        dnsResolversBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder clearDnsResolvers() {
      if (dnsResolversBuilder_ == null) {
        dnsResolvers_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
      } else {
        dnsResolversBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public Builder removeDnsResolvers(int index) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.remove(index);
        onChanged();
      } else {
        dnsResolversBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Address.Builder getDnsResolversBuilder(
        int index) {
      return getDnsResolversFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.AddressOrBuilder getDnsResolversOrBuilder(
        int index) {
      if (dnsResolversBuilder_ == null) {
        return dnsResolvers_.get(index);  } else {
        return dnsResolversBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> 
         getDnsResolversOrBuilderList() {
      if (dnsResolversBuilder_ != null) {
        return dnsResolversBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(dnsResolvers_);
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Address.Builder addDnsResolversBuilder() {
      return getDnsResolversFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance());
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Address.Builder addDnsResolversBuilder(
        int index) {
      return getDnsResolversFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance());
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple's API only allows overriding DNS resolvers via system settings.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.Address.Builder> 
         getDnsResolversBuilderList() {
      return getDnsResolversFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Address, io.envoyproxy.envoy.config.core.v3.Address.Builder, io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> 
        getDnsResolversFieldBuilder() {
      if (dnsResolversBuilder_ == null) {
        dnsResolversBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Address, io.envoyproxy.envoy.config.core.v3.Address.Builder, io.envoyproxy.envoy.config.core.v3.AddressOrBuilder>(
                dnsResolvers_,
                ((bitField0_ & 0x00000008) != 0),
                getParentForChildren(),
                isClean());
        dnsResolvers_ = null;
      }
      return dnsResolversBuilder_;
    }

    private boolean useTcpForDnsLookups_ ;
    /**
     * <pre>
     * [#next-major-version: Reconcile DNS options in a single message.]
     * Always use TCP queries instead of UDP queries for DNS lookups.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple' API only uses UDP for DNS resolution.
     * </pre>
     *
     * <code>bool use_tcp_for_dns_lookups = 45;</code>
     * @return The useTcpForDnsLookups.
     */
    @java.lang.Override
    public boolean getUseTcpForDnsLookups() {
      return useTcpForDnsLookups_;
    }
    /**
     * <pre>
     * [#next-major-version: Reconcile DNS options in a single message.]
     * Always use TCP queries instead of UDP queries for DNS lookups.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple' API only uses UDP for DNS resolution.
     * </pre>
     *
     * <code>bool use_tcp_for_dns_lookups = 45;</code>
     * @param value The useTcpForDnsLookups to set.
     * @return This builder for chaining.
     */
    public Builder setUseTcpForDnsLookups(boolean value) {
      
      useTcpForDnsLookups_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#next-major-version: Reconcile DNS options in a single message.]
     * Always use TCP queries instead of UDP queries for DNS lookups.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple' API only uses UDP for DNS resolution.
     * </pre>
     *
     * <code>bool use_tcp_for_dns_lookups = 45;</code>
     * @return This builder for chaining.
     */
    public Builder clearUseTcpForDnsLookups() {
      
      useTcpForDnsLookups_ = false;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.cluster.v3.OutlierDetection outlierDetection_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.OutlierDetection, io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.Builder, io.envoyproxy.envoy.config.cluster.v3.OutlierDetectionOrBuilder> outlierDetectionBuilder_;
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     * @return Whether the outlierDetection field is set.
     */
    public boolean hasOutlierDetection() {
      return outlierDetectionBuilder_ != null || outlierDetection_ != null;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     * @return The outlierDetection.
     */
    public io.envoyproxy.envoy.config.cluster.v3.OutlierDetection getOutlierDetection() {
      if (outlierDetectionBuilder_ == null) {
        return outlierDetection_ == null ? io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.getDefaultInstance() : outlierDetection_;
      } else {
        return outlierDetectionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder setOutlierDetection(io.envoyproxy.envoy.config.cluster.v3.OutlierDetection value) {
      if (outlierDetectionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        outlierDetection_ = value;
        onChanged();
      } else {
        outlierDetectionBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder setOutlierDetection(
        io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.Builder builderForValue) {
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = builderForValue.build();
        onChanged();
      } else {
        outlierDetectionBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder mergeOutlierDetection(io.envoyproxy.envoy.config.cluster.v3.OutlierDetection value) {
      if (outlierDetectionBuilder_ == null) {
        if (outlierDetection_ != null) {
          outlierDetection_ =
            io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.newBuilder(outlierDetection_).mergeFrom(value).buildPartial();
        } else {
          outlierDetection_ = value;
        }
        onChanged();
      } else {
        outlierDetectionBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder clearOutlierDetection() {
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = null;
        onChanged();
      } else {
        outlierDetection_ = null;
        outlierDetectionBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.Builder getOutlierDetectionBuilder() {
      
      onChanged();
      return getOutlierDetectionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder() {
      if (outlierDetectionBuilder_ != null) {
        return outlierDetectionBuilder_.getMessageOrBuilder();
      } else {
        return outlierDetection_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.getDefaultInstance() : outlierDetection_;
      }
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.OutlierDetection, io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.Builder, io.envoyproxy.envoy.config.cluster.v3.OutlierDetectionOrBuilder> 
        getOutlierDetectionFieldBuilder() {
      if (outlierDetectionBuilder_ == null) {
        outlierDetectionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.OutlierDetection, io.envoyproxy.envoy.config.cluster.v3.OutlierDetection.Builder, io.envoyproxy.envoy.config.cluster.v3.OutlierDetectionOrBuilder>(
                getOutlierDetection(),
                getParentForChildren(),
                isClean());
        outlierDetection_ = null;
      }
      return outlierDetectionBuilder_;
    }

    private com.google.protobuf.Duration cleanupInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> cleanupIntervalBuilder_;
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     * @return Whether the cleanupInterval field is set.
     */
    public boolean hasCleanupInterval() {
      return cleanupIntervalBuilder_ != null || cleanupInterval_ != null;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     * @return The cleanupInterval.
     */
    public com.google.protobuf.Duration getCleanupInterval() {
      if (cleanupIntervalBuilder_ == null) {
        return cleanupInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : cleanupInterval_;
      } else {
        return cleanupIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder setCleanupInterval(com.google.protobuf.Duration value) {
      if (cleanupIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        cleanupInterval_ = value;
        onChanged();
      } else {
        cleanupIntervalBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder setCleanupInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (cleanupIntervalBuilder_ == null) {
        cleanupInterval_ = builderForValue.build();
        onChanged();
      } else {
        cleanupIntervalBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeCleanupInterval(com.google.protobuf.Duration value) {
      if (cleanupIntervalBuilder_ == null) {
        if (cleanupInterval_ != null) {
          cleanupInterval_ =
            com.google.protobuf.Duration.newBuilder(cleanupInterval_).mergeFrom(value).buildPartial();
        } else {
          cleanupInterval_ = value;
        }
        onChanged();
      } else {
        cleanupIntervalBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder clearCleanupInterval() {
      if (cleanupIntervalBuilder_ == null) {
        cleanupInterval_ = null;
        onChanged();
      } else {
        cleanupInterval_ = null;
        cleanupIntervalBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getCleanupIntervalBuilder() {
      
      onChanged();
      return getCleanupIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getCleanupIntervalOrBuilder() {
      if (cleanupIntervalBuilder_ != null) {
        return cleanupIntervalBuilder_.getMessageOrBuilder();
      } else {
        return cleanupInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : cleanupInterval_;
      }
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getCleanupIntervalFieldBuilder() {
      if (cleanupIntervalBuilder_ == null) {
        cleanupIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getCleanupInterval(),
                getParentForChildren(),
                isClean());
        cleanupInterval_ = null;
      }
      return cleanupIntervalBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.BindConfig upstreamBindConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.BindConfig, io.envoyproxy.envoy.config.core.v3.BindConfig.Builder, io.envoyproxy.envoy.config.core.v3.BindConfigOrBuilder> upstreamBindConfigBuilder_;
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     * @return Whether the upstreamBindConfig field is set.
     */
    public boolean hasUpstreamBindConfig() {
      return upstreamBindConfigBuilder_ != null || upstreamBindConfig_ != null;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     * @return The upstreamBindConfig.
     */
    public io.envoyproxy.envoy.config.core.v3.BindConfig getUpstreamBindConfig() {
      if (upstreamBindConfigBuilder_ == null) {
        return upstreamBindConfig_ == null ? io.envoyproxy.envoy.config.core.v3.BindConfig.getDefaultInstance() : upstreamBindConfig_;
      } else {
        return upstreamBindConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder setUpstreamBindConfig(io.envoyproxy.envoy.config.core.v3.BindConfig value) {
      if (upstreamBindConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        upstreamBindConfig_ = value;
        onChanged();
      } else {
        upstreamBindConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder setUpstreamBindConfig(
        io.envoyproxy.envoy.config.core.v3.BindConfig.Builder builderForValue) {
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfig_ = builderForValue.build();
        onChanged();
      } else {
        upstreamBindConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder mergeUpstreamBindConfig(io.envoyproxy.envoy.config.core.v3.BindConfig value) {
      if (upstreamBindConfigBuilder_ == null) {
        if (upstreamBindConfig_ != null) {
          upstreamBindConfig_ =
            io.envoyproxy.envoy.config.core.v3.BindConfig.newBuilder(upstreamBindConfig_).mergeFrom(value).buildPartial();
        } else {
          upstreamBindConfig_ = value;
        }
        onChanged();
      } else {
        upstreamBindConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder clearUpstreamBindConfig() {
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfig_ = null;
        onChanged();
      } else {
        upstreamBindConfig_ = null;
        upstreamBindConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.BindConfig.Builder getUpstreamBindConfigBuilder() {
      
      onChanged();
      return getUpstreamBindConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.BindConfigOrBuilder getUpstreamBindConfigOrBuilder() {
      if (upstreamBindConfigBuilder_ != null) {
        return upstreamBindConfigBuilder_.getMessageOrBuilder();
      } else {
        return upstreamBindConfig_ == null ?
            io.envoyproxy.envoy.config.core.v3.BindConfig.getDefaultInstance() : upstreamBindConfig_;
      }
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.BindConfig, io.envoyproxy.envoy.config.core.v3.BindConfig.Builder, io.envoyproxy.envoy.config.core.v3.BindConfigOrBuilder> 
        getUpstreamBindConfigFieldBuilder() {
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.BindConfig, io.envoyproxy.envoy.config.core.v3.BindConfig.Builder, io.envoyproxy.envoy.config.core.v3.BindConfigOrBuilder>(
                getUpstreamBindConfig(),
                getParentForChildren(),
                isClean());
        upstreamBindConfig_ = null;
      }
      return upstreamBindConfigBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig lbSubsetConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder> lbSubsetConfigBuilder_;
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     * @return Whether the lbSubsetConfig field is set.
     */
    public boolean hasLbSubsetConfig() {
      return lbSubsetConfigBuilder_ != null || lbSubsetConfig_ != null;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     * @return The lbSubsetConfig.
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig getLbSubsetConfig() {
      if (lbSubsetConfigBuilder_ == null) {
        return lbSubsetConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.getDefaultInstance() : lbSubsetConfig_;
      } else {
        return lbSubsetConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder setLbSubsetConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig value) {
      if (lbSubsetConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbSubsetConfig_ = value;
        onChanged();
      } else {
        lbSubsetConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder setLbSubsetConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder builderForValue) {
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfig_ = builderForValue.build();
        onChanged();
      } else {
        lbSubsetConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder mergeLbSubsetConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig value) {
      if (lbSubsetConfigBuilder_ == null) {
        if (lbSubsetConfig_ != null) {
          lbSubsetConfig_ =
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.newBuilder(lbSubsetConfig_).mergeFrom(value).buildPartial();
        } else {
          lbSubsetConfig_ = value;
        }
        onChanged();
      } else {
        lbSubsetConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder clearLbSubsetConfig() {
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfig_ = null;
        onChanged();
      } else {
        lbSubsetConfig_ = null;
        lbSubsetConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder getLbSubsetConfigBuilder() {
      
      onChanged();
      return getLbSubsetConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder getLbSubsetConfigOrBuilder() {
      if (lbSubsetConfigBuilder_ != null) {
        return lbSubsetConfigBuilder_.getMessageOrBuilder();
      } else {
        return lbSubsetConfig_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.getDefaultInstance() : lbSubsetConfig_;
      }
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder> 
        getLbSubsetConfigFieldBuilder() {
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder>(
                getLbSubsetConfig(),
                getParentForChildren(),
                isClean());
        lbSubsetConfig_ = null;
      }
      return lbSubsetConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder> ringHashLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     * @return Whether the ringHashLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasRingHashLbConfig() {
      return lbConfigCase_ == 23;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     * @return The ringHashLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig getRingHashLbConfig() {
      if (ringHashLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 23) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 23) {
          return ringHashLbConfigBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder setRingHashLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig value) {
      if (ringHashLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        ringHashLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 23;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder setRingHashLbConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder builderForValue) {
      if (ringHashLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        ringHashLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 23;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder mergeRingHashLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig value) {
      if (ringHashLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 23 &&
            lbConfig_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance()) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 23) {
          ringHashLbConfigBuilder_.mergeFrom(value);
        }
        ringHashLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 23;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder clearRingHashLbConfig() {
      if (ringHashLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 23) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 23) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        ringHashLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder getRingHashLbConfigBuilder() {
      return getRingHashLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder getRingHashLbConfigOrBuilder() {
      if ((lbConfigCase_ == 23) && (ringHashLbConfigBuilder_ != null)) {
        return ringHashLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 23) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder> 
        getRingHashLbConfigFieldBuilder() {
      if (ringHashLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 23)) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.getDefaultInstance();
        }
        ringHashLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder>(
                (io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 23;
      onChanged();;
      return ringHashLbConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder> maglevLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     * @return Whether the maglevLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasMaglevLbConfig() {
      return lbConfigCase_ == 52;
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     * @return The maglevLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig getMaglevLbConfig() {
      if (maglevLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 52) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 52) {
          return maglevLbConfigBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    public Builder setMaglevLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig value) {
      if (maglevLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        maglevLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 52;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    public Builder setMaglevLbConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder builderForValue) {
      if (maglevLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        maglevLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 52;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    public Builder mergeMaglevLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig value) {
      if (maglevLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 52 &&
            lbConfig_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance()) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 52) {
          maglevLbConfigBuilder_.mergeFrom(value);
        }
        maglevLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 52;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    public Builder clearMaglevLbConfig() {
      if (maglevLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 52) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 52) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        maglevLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder getMaglevLbConfigBuilder() {
      return getMaglevLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder getMaglevLbConfigOrBuilder() {
      if ((lbConfigCase_ == 52) && (maglevLbConfigBuilder_ != null)) {
        return maglevLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 52) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Maglev load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder> 
        getMaglevLbConfigFieldBuilder() {
      if (maglevLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 52)) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.getDefaultInstance();
        }
        maglevLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder>(
                (io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 52;
      onChanged();;
      return maglevLbConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder> originalDstLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     * @return Whether the originalDstLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasOriginalDstLbConfig() {
      return lbConfigCase_ == 34;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     * @return The originalDstLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig getOriginalDstLbConfig() {
      if (originalDstLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 34) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 34) {
          return originalDstLbConfigBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder setOriginalDstLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig value) {
      if (originalDstLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        originalDstLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 34;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder setOriginalDstLbConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder builderForValue) {
      if (originalDstLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        originalDstLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 34;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder mergeOriginalDstLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig value) {
      if (originalDstLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 34 &&
            lbConfig_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance()) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 34) {
          originalDstLbConfigBuilder_.mergeFrom(value);
        }
        originalDstLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 34;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder clearOriginalDstLbConfig() {
      if (originalDstLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 34) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 34) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        originalDstLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder getOriginalDstLbConfigBuilder() {
      return getOriginalDstLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder getOriginalDstLbConfigOrBuilder() {
      if ((lbConfigCase_ == 34) && (originalDstLbConfigBuilder_ != null)) {
        return originalDstLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 34) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder> 
        getOriginalDstLbConfigFieldBuilder() {
      if (originalDstLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 34)) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.getDefaultInstance();
        }
        originalDstLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder>(
                (io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 34;
      onChanged();;
      return originalDstLbConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder> leastRequestLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     * @return Whether the leastRequestLbConfig field is set.
     */
    @java.lang.Override
    public boolean hasLeastRequestLbConfig() {
      return lbConfigCase_ == 37;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     * @return The leastRequestLbConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig getLeastRequestLbConfig() {
      if (leastRequestLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 37) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 37) {
          return leastRequestLbConfigBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder setLeastRequestLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig value) {
      if (leastRequestLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        leastRequestLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 37;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder setLeastRequestLbConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder builderForValue) {
      if (leastRequestLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        leastRequestLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 37;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder mergeLeastRequestLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig value) {
      if (leastRequestLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 37 &&
            lbConfig_ != io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance()) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.newBuilder((io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 37) {
          leastRequestLbConfigBuilder_.mergeFrom(value);
        }
        leastRequestLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 37;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder clearLeastRequestLbConfig() {
      if (leastRequestLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 37) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 37) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        leastRequestLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder getLeastRequestLbConfigBuilder() {
      return getLeastRequestLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder getLeastRequestLbConfigOrBuilder() {
      if ((lbConfigCase_ == 37) && (leastRequestLbConfigBuilder_ != null)) {
        return leastRequestLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 37) {
          return (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_;
        }
        return io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder> 
        getLeastRequestLbConfigFieldBuilder() {
      if (leastRequestLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 37)) {
          lbConfig_ = io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.getDefaultInstance();
        }
        leastRequestLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder>(
                (io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 37;
      onChanged();;
      return leastRequestLbConfigBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig commonLbConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder> commonLbConfigBuilder_;
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     * @return Whether the commonLbConfig field is set.
     */
    public boolean hasCommonLbConfig() {
      return commonLbConfigBuilder_ != null || commonLbConfig_ != null;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     * @return The commonLbConfig.
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig getCommonLbConfig() {
      if (commonLbConfigBuilder_ == null) {
        return commonLbConfig_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.getDefaultInstance() : commonLbConfig_;
      } else {
        return commonLbConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder setCommonLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig value) {
      if (commonLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        commonLbConfig_ = value;
        onChanged();
      } else {
        commonLbConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder setCommonLbConfig(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder builderForValue) {
      if (commonLbConfigBuilder_ == null) {
        commonLbConfig_ = builderForValue.build();
        onChanged();
      } else {
        commonLbConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder mergeCommonLbConfig(io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig value) {
      if (commonLbConfigBuilder_ == null) {
        if (commonLbConfig_ != null) {
          commonLbConfig_ =
            io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.newBuilder(commonLbConfig_).mergeFrom(value).buildPartial();
        } else {
          commonLbConfig_ = value;
        }
        onChanged();
      } else {
        commonLbConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder clearCommonLbConfig() {
      if (commonLbConfigBuilder_ == null) {
        commonLbConfig_ = null;
        onChanged();
      } else {
        commonLbConfig_ = null;
        commonLbConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder getCommonLbConfigBuilder() {
      
      onChanged();
      return getCommonLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder getCommonLbConfigOrBuilder() {
      if (commonLbConfigBuilder_ != null) {
        return commonLbConfigBuilder_.getMessageOrBuilder();
      } else {
        return commonLbConfig_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.getDefaultInstance() : commonLbConfig_;
      }
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder> 
        getCommonLbConfigFieldBuilder() {
      if (commonLbConfigBuilder_ == null) {
        commonLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder>(
                getCommonLbConfig(),
                getParentForChildren(),
                isClean());
        commonLbConfig_ = null;
      }
      return commonLbConfigBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.TransportSocket transportSocket_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TransportSocket, io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder, io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder> transportSocketBuilder_;
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     * @return Whether the transportSocket field is set.
     */
    public boolean hasTransportSocket() {
      return transportSocketBuilder_ != null || transportSocket_ != null;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     * @return The transportSocket.
     */
    public io.envoyproxy.envoy.config.core.v3.TransportSocket getTransportSocket() {
      if (transportSocketBuilder_ == null) {
        return transportSocket_ == null ? io.envoyproxy.envoy.config.core.v3.TransportSocket.getDefaultInstance() : transportSocket_;
      } else {
        return transportSocketBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    public Builder setTransportSocket(io.envoyproxy.envoy.config.core.v3.TransportSocket value) {
      if (transportSocketBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        transportSocket_ = value;
        onChanged();
      } else {
        transportSocketBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    public Builder setTransportSocket(
        io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder builderForValue) {
      if (transportSocketBuilder_ == null) {
        transportSocket_ = builderForValue.build();
        onChanged();
      } else {
        transportSocketBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    public Builder mergeTransportSocket(io.envoyproxy.envoy.config.core.v3.TransportSocket value) {
      if (transportSocketBuilder_ == null) {
        if (transportSocket_ != null) {
          transportSocket_ =
            io.envoyproxy.envoy.config.core.v3.TransportSocket.newBuilder(transportSocket_).mergeFrom(value).buildPartial();
        } else {
          transportSocket_ = value;
        }
        onChanged();
      } else {
        transportSocketBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    public Builder clearTransportSocket() {
      if (transportSocketBuilder_ == null) {
        transportSocket_ = null;
        onChanged();
      } else {
        transportSocket_ = null;
        transportSocketBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder getTransportSocketBuilder() {
      
      onChanged();
      return getTransportSocketFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder getTransportSocketOrBuilder() {
      if (transportSocketBuilder_ != null) {
        return transportSocketBuilder_.getMessageOrBuilder();
      } else {
        return transportSocket_ == null ?
            io.envoyproxy.envoy.config.core.v3.TransportSocket.getDefaultInstance() : transportSocket_;
      }
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TransportSocket, io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder, io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder> 
        getTransportSocketFieldBuilder() {
      if (transportSocketBuilder_ == null) {
        transportSocketBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.TransportSocket, io.envoyproxy.envoy.config.core.v3.TransportSocket.Builder, io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder>(
                getTransportSocket(),
                getParentForChildren(),
                isClean());
        transportSocket_ = null;
      }
      return transportSocketBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Metadata metadata_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Metadata, io.envoyproxy.envoy.config.core.v3.Metadata.Builder, io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder> metadataBuilder_;
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     * @return Whether the metadata field is set.
     */
    public boolean hasMetadata() {
      return metadataBuilder_ != null || metadata_ != null;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     * @return The metadata.
     */
    public io.envoyproxy.envoy.config.core.v3.Metadata getMetadata() {
      if (metadataBuilder_ == null) {
        return metadata_ == null ? io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
      } else {
        return metadataBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    public Builder setMetadata(io.envoyproxy.envoy.config.core.v3.Metadata value) {
      if (metadataBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        metadata_ = value;
        onChanged();
      } else {
        metadataBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    public Builder setMetadata(
        io.envoyproxy.envoy.config.core.v3.Metadata.Builder builderForValue) {
      if (metadataBuilder_ == null) {
        metadata_ = builderForValue.build();
        onChanged();
      } else {
        metadataBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    public Builder mergeMetadata(io.envoyproxy.envoy.config.core.v3.Metadata value) {
      if (metadataBuilder_ == null) {
        if (metadata_ != null) {
          metadata_ =
            io.envoyproxy.envoy.config.core.v3.Metadata.newBuilder(metadata_).mergeFrom(value).buildPartial();
        } else {
          metadata_ = value;
        }
        onChanged();
      } else {
        metadataBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    public Builder clearMetadata() {
      if (metadataBuilder_ == null) {
        metadata_ = null;
        onChanged();
      } else {
        metadata_ = null;
        metadataBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Metadata.Builder getMetadataBuilder() {
      
      onChanged();
      return getMetadataFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder getMetadataOrBuilder() {
      if (metadataBuilder_ != null) {
        return metadataBuilder_.getMessageOrBuilder();
      } else {
        return metadata_ == null ?
            io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
      }
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Metadata, io.envoyproxy.envoy.config.core.v3.Metadata.Builder, io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder> 
        getMetadataFieldBuilder() {
      if (metadataBuilder_ == null) {
        metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Metadata, io.envoyproxy.envoy.config.core.v3.Metadata.Builder, io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder>(
                getMetadata(),
                getParentForChildren(),
                isClean());
        metadata_ = null;
      }
      return metadataBuilder_;
    }

    private int protocolSelection_ = 0;
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * This has been deprecated in favor of setting explicit protocol selection
     * in the :ref:`http_protocol_options
     * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
     * @return The enum numeric value on the wire for protocolSelection.
     */
    @java.lang.Override @java.lang.Deprecated public int getProtocolSelectionValue() {
      return protocolSelection_;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * This has been deprecated in favor of setting explicit protocol selection
     * in the :ref:`http_protocol_options
     * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
     * @param value The enum numeric value on the wire for protocolSelection to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setProtocolSelectionValue(int value) {
      
      protocolSelection_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * This has been deprecated in favor of setting explicit protocol selection
     * in the :ref:`http_protocol_options
     * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
     * @return The protocolSelection.
     */
    @java.lang.Override
    @java.lang.Deprecated public io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection getProtocolSelection() {
      @SuppressWarnings("deprecation")
      io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection result = io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.valueOf(protocolSelection_);
      return result == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * This has been deprecated in favor of setting explicit protocol selection
     * in the :ref:`http_protocol_options
     * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
     * @param value The protocolSelection to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setProtocolSelection(io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      protocolSelection_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * This has been deprecated in favor of setting explicit protocol selection
     * in the :ref:`http_protocol_options
     * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearProtocolSelection() {
      
      protocolSelection_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions upstreamConnectionOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions, io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.Builder, io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptionsOrBuilder> upstreamConnectionOptionsBuilder_;
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     * @return Whether the upstreamConnectionOptions field is set.
     */
    public boolean hasUpstreamConnectionOptions() {
      return upstreamConnectionOptionsBuilder_ != null || upstreamConnectionOptions_ != null;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     * @return The upstreamConnectionOptions.
     */
    public io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions getUpstreamConnectionOptions() {
      if (upstreamConnectionOptionsBuilder_ == null) {
        return upstreamConnectionOptions_ == null ? io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.getDefaultInstance() : upstreamConnectionOptions_;
      } else {
        return upstreamConnectionOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder setUpstreamConnectionOptions(io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions value) {
      if (upstreamConnectionOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        upstreamConnectionOptions_ = value;
        onChanged();
      } else {
        upstreamConnectionOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder setUpstreamConnectionOptions(
        io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.Builder builderForValue) {
      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptions_ = builderForValue.build();
        onChanged();
      } else {
        upstreamConnectionOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder mergeUpstreamConnectionOptions(io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions value) {
      if (upstreamConnectionOptionsBuilder_ == null) {
        if (upstreamConnectionOptions_ != null) {
          upstreamConnectionOptions_ =
            io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.newBuilder(upstreamConnectionOptions_).mergeFrom(value).buildPartial();
        } else {
          upstreamConnectionOptions_ = value;
        }
        onChanged();
      } else {
        upstreamConnectionOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder clearUpstreamConnectionOptions() {
      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptions_ = null;
        onChanged();
      } else {
        upstreamConnectionOptions_ = null;
        upstreamConnectionOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.Builder getUpstreamConnectionOptionsBuilder() {
      
      onChanged();
      return getUpstreamConnectionOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptionsOrBuilder getUpstreamConnectionOptionsOrBuilder() {
      if (upstreamConnectionOptionsBuilder_ != null) {
        return upstreamConnectionOptionsBuilder_.getMessageOrBuilder();
      } else {
        return upstreamConnectionOptions_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.getDefaultInstance() : upstreamConnectionOptions_;
      }
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions, io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.Builder, io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptionsOrBuilder> 
        getUpstreamConnectionOptionsFieldBuilder() {
      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions, io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions.Builder, io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptionsOrBuilder>(
                getUpstreamConnectionOptions(),
                getParentForChildren(),
                isClean());
        upstreamConnectionOptions_ = null;
      }
      return upstreamConnectionOptionsBuilder_;
    }

    private boolean closeConnectionsOnHostHealthFailure_ ;
    /**
     * <pre>
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     * .. note::
     *   This is currently only supported for connections created by tcp_proxy.
     * .. note::
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     * </pre>
     *
     * <code>bool close_connections_on_host_health_failure = 31;</code>
     * @return The closeConnectionsOnHostHealthFailure.
     */
    @java.lang.Override
    public boolean getCloseConnectionsOnHostHealthFailure() {
      return closeConnectionsOnHostHealthFailure_;
    }
    /**
     * <pre>
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     * .. note::
     *   This is currently only supported for connections created by tcp_proxy.
     * .. note::
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     * </pre>
     *
     * <code>bool close_connections_on_host_health_failure = 31;</code>
     * @param value The closeConnectionsOnHostHealthFailure to set.
     * @return This builder for chaining.
     */
    public Builder setCloseConnectionsOnHostHealthFailure(boolean value) {
      
      closeConnectionsOnHostHealthFailure_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     * .. note::
     *   This is currently only supported for connections created by tcp_proxy.
     * .. note::
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     * </pre>
     *
     * <code>bool close_connections_on_host_health_failure = 31;</code>
     * @return This builder for chaining.
     */
    public Builder clearCloseConnectionsOnHostHealthFailure() {
      
      closeConnectionsOnHostHealthFailure_ = false;
      onChanged();
      return this;
    }

    private boolean ignoreHealthOnHostRemoval_ ;
    /**
     * <pre>
     * If set to true, Envoy will ignore the health value of a host when processing its removal
     * from service discovery. This means that if active health checking is used, Envoy will *not*
     * wait for the endpoint to go unhealthy before removing it.
     * </pre>
     *
     * <code>bool ignore_health_on_host_removal = 32;</code>
     * @return The ignoreHealthOnHostRemoval.
     */
    @java.lang.Override
    public boolean getIgnoreHealthOnHostRemoval() {
      return ignoreHealthOnHostRemoval_;
    }
    /**
     * <pre>
     * If set to true, Envoy will ignore the health value of a host when processing its removal
     * from service discovery. This means that if active health checking is used, Envoy will *not*
     * wait for the endpoint to go unhealthy before removing it.
     * </pre>
     *
     * <code>bool ignore_health_on_host_removal = 32;</code>
     * @param value The ignoreHealthOnHostRemoval to set.
     * @return This builder for chaining.
     */
    public Builder setIgnoreHealthOnHostRemoval(boolean value) {
      
      ignoreHealthOnHostRemoval_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set to true, Envoy will ignore the health value of a host when processing its removal
     * from service discovery. This means that if active health checking is used, Envoy will *not*
     * wait for the endpoint to go unhealthy before removing it.
     * </pre>
     *
     * <code>bool ignore_health_on_host_removal = 32;</code>
     * @return This builder for chaining.
     */
    public Builder clearIgnoreHealthOnHostRemoval() {
      
      ignoreHealthOnHostRemoval_ = false;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.config.cluster.v3.Filter> filters_ =
      java.util.Collections.emptyList();
    private void ensureFiltersIsMutable() {
      if (!((bitField0_ & 0x00000010) != 0)) {
        filters_ = new java.util.ArrayList<io.envoyproxy.envoy.config.cluster.v3.Filter>(filters_);
        bitField0_ |= 0x00000010;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Filter, io.envoyproxy.envoy.config.cluster.v3.Filter.Builder, io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder> filtersBuilder_;

    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Filter> getFiltersList() {
      if (filtersBuilder_ == null) {
        return java.util.Collections.unmodifiableList(filters_);
      } else {
        return filtersBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public int getFiltersCount() {
      if (filtersBuilder_ == null) {
        return filters_.size();
      } else {
        return filtersBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Filter getFilters(int index) {
      if (filtersBuilder_ == null) {
        return filters_.get(index);
      } else {
        return filtersBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder setFilters(
        int index, io.envoyproxy.envoy.config.cluster.v3.Filter value) {
      if (filtersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFiltersIsMutable();
        filters_.set(index, value);
        onChanged();
      } else {
        filtersBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder setFilters(
        int index, io.envoyproxy.envoy.config.cluster.v3.Filter.Builder builderForValue) {
      if (filtersBuilder_ == null) {
        ensureFiltersIsMutable();
        filters_.set(index, builderForValue.build());
        onChanged();
      } else {
        filtersBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder addFilters(io.envoyproxy.envoy.config.cluster.v3.Filter value) {
      if (filtersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFiltersIsMutable();
        filters_.add(value);
        onChanged();
      } else {
        filtersBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder addFilters(
        int index, io.envoyproxy.envoy.config.cluster.v3.Filter value) {
      if (filtersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFiltersIsMutable();
        filters_.add(index, value);
        onChanged();
      } else {
        filtersBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder addFilters(
        io.envoyproxy.envoy.config.cluster.v3.Filter.Builder builderForValue) {
      if (filtersBuilder_ == null) {
        ensureFiltersIsMutable();
        filters_.add(builderForValue.build());
        onChanged();
      } else {
        filtersBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder addFilters(
        int index, io.envoyproxy.envoy.config.cluster.v3.Filter.Builder builderForValue) {
      if (filtersBuilder_ == null) {
        ensureFiltersIsMutable();
        filters_.add(index, builderForValue.build());
        onChanged();
      } else {
        filtersBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder addAllFilters(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.cluster.v3.Filter> values) {
      if (filtersBuilder_ == null) {
        ensureFiltersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, filters_);
        onChanged();
      } else {
        filtersBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder clearFilters() {
      if (filtersBuilder_ == null) {
        filters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
      } else {
        filtersBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public Builder removeFilters(int index) {
      if (filtersBuilder_ == null) {
        ensureFiltersIsMutable();
        filters_.remove(index);
        onChanged();
      } else {
        filtersBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Filter.Builder getFiltersBuilder(
        int index) {
      return getFiltersFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder getFiltersOrBuilder(
        int index) {
      if (filtersBuilder_ == null) {
        return filters_.get(index);  } else {
        return filtersBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder> 
         getFiltersOrBuilderList() {
      if (filtersBuilder_ != null) {
        return filtersBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(filters_);
      }
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Filter.Builder addFiltersBuilder() {
      return getFiltersFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.cluster.v3.Filter.getDefaultInstance());
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Filter.Builder addFiltersBuilder(
        int index) {
      return getFiltersFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.cluster.v3.Filter.getDefaultInstance());
    }
    /**
     * <pre>
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     * </pre>
     *
     * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.cluster.v3.Filter.Builder> 
         getFiltersBuilderList() {
      return getFiltersFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Filter, io.envoyproxy.envoy.config.cluster.v3.Filter.Builder, io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder> 
        getFiltersFieldBuilder() {
      if (filtersBuilder_ == null) {
        filtersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Filter, io.envoyproxy.envoy.config.cluster.v3.Filter.Builder, io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder>(
                filters_,
                ((bitField0_ & 0x00000010) != 0),
                getParentForChildren(),
                isClean());
        filters_ = null;
      }
      return filtersBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy loadBalancingPolicy_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy, io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.Builder, io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicyOrBuilder> loadBalancingPolicyBuilder_;
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     * @return Whether the loadBalancingPolicy field is set.
     */
    public boolean hasLoadBalancingPolicy() {
      return loadBalancingPolicyBuilder_ != null || loadBalancingPolicy_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     * @return The loadBalancingPolicy.
     */
    public io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy getLoadBalancingPolicy() {
      if (loadBalancingPolicyBuilder_ == null) {
        return loadBalancingPolicy_ == null ? io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.getDefaultInstance() : loadBalancingPolicy_;
      } else {
        return loadBalancingPolicyBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    public Builder setLoadBalancingPolicy(io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy value) {
      if (loadBalancingPolicyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        loadBalancingPolicy_ = value;
        onChanged();
      } else {
        loadBalancingPolicyBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    public Builder setLoadBalancingPolicy(
        io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.Builder builderForValue) {
      if (loadBalancingPolicyBuilder_ == null) {
        loadBalancingPolicy_ = builderForValue.build();
        onChanged();
      } else {
        loadBalancingPolicyBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    public Builder mergeLoadBalancingPolicy(io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy value) {
      if (loadBalancingPolicyBuilder_ == null) {
        if (loadBalancingPolicy_ != null) {
          loadBalancingPolicy_ =
            io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.newBuilder(loadBalancingPolicy_).mergeFrom(value).buildPartial();
        } else {
          loadBalancingPolicy_ = value;
        }
        onChanged();
      } else {
        loadBalancingPolicyBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    public Builder clearLoadBalancingPolicy() {
      if (loadBalancingPolicyBuilder_ == null) {
        loadBalancingPolicy_ = null;
        onChanged();
      } else {
        loadBalancingPolicy_ = null;
        loadBalancingPolicyBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.Builder getLoadBalancingPolicyBuilder() {
      
      onChanged();
      return getLoadBalancingPolicyFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicyOrBuilder getLoadBalancingPolicyOrBuilder() {
      if (loadBalancingPolicyBuilder_ != null) {
        return loadBalancingPolicyBuilder_.getMessageOrBuilder();
      } else {
        return loadBalancingPolicy_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.getDefaultInstance() : loadBalancingPolicy_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
     * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
     * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy, io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.Builder, io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicyOrBuilder> 
        getLoadBalancingPolicyFieldBuilder() {
      if (loadBalancingPolicyBuilder_ == null) {
        loadBalancingPolicyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy, io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy.Builder, io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicyOrBuilder>(
                getLoadBalancingPolicy(),
                getParentForChildren(),
                isClean());
        loadBalancingPolicy_ = null;
      }
      return loadBalancingPolicyBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.ConfigSource lrsServer_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.ConfigSource, io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder, io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder> lrsServerBuilder_;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     * @return Whether the lrsServer field is set.
     */
    public boolean hasLrsServer() {
      return lrsServerBuilder_ != null || lrsServer_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     * @return The lrsServer.
     */
    public io.envoyproxy.envoy.config.core.v3.ConfigSource getLrsServer() {
      if (lrsServerBuilder_ == null) {
        return lrsServer_ == null ? io.envoyproxy.envoy.config.core.v3.ConfigSource.getDefaultInstance() : lrsServer_;
      } else {
        return lrsServerBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    public Builder setLrsServer(io.envoyproxy.envoy.config.core.v3.ConfigSource value) {
      if (lrsServerBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lrsServer_ = value;
        onChanged();
      } else {
        lrsServerBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    public Builder setLrsServer(
        io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder builderForValue) {
      if (lrsServerBuilder_ == null) {
        lrsServer_ = builderForValue.build();
        onChanged();
      } else {
        lrsServerBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    public Builder mergeLrsServer(io.envoyproxy.envoy.config.core.v3.ConfigSource value) {
      if (lrsServerBuilder_ == null) {
        if (lrsServer_ != null) {
          lrsServer_ =
            io.envoyproxy.envoy.config.core.v3.ConfigSource.newBuilder(lrsServer_).mergeFrom(value).buildPartial();
        } else {
          lrsServer_ = value;
        }
        onChanged();
      } else {
        lrsServerBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    public Builder clearLrsServer() {
      if (lrsServerBuilder_ == null) {
        lrsServer_ = null;
        onChanged();
      } else {
        lrsServer_ = null;
        lrsServerBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder getLrsServerBuilder() {
      
      onChanged();
      return getLrsServerFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder getLrsServerOrBuilder() {
      if (lrsServerBuilder_ != null) {
        return lrsServerBuilder_.getMessageOrBuilder();
      } else {
        return lrsServer_ == null ?
            io.envoyproxy.envoy.config.core.v3.ConfigSource.getDefaultInstance() : lrsServer_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     * </pre>
     *
     * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.ConfigSource, io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder, io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder> 
        getLrsServerFieldBuilder() {
      if (lrsServerBuilder_ == null) {
        lrsServerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.ConfigSource, io.envoyproxy.envoy.config.core.v3.ConfigSource.Builder, io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder>(
                getLrsServer(),
                getParentForChildren(),
                isClean());
        lrsServer_ = null;
      }
      return lrsServerBuilder_;
    }

    private boolean trackTimeoutBudgets_ ;
    /**
     * <pre>
     * If track_timeout_budgets is true, the :ref:`timeout budget histograms
     * &lt;config_cluster_manager_cluster_stats_timeout_budgets&gt;` will be published for each
     * request. These show what percentage of a request's per try and global timeout was used. A value
     * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
     * of 100 would indicate that the request took the entirety of the timeout given to it.
     * .. attention::
     *   This field has been deprecated in favor of `timeout_budgets`, part of
     *   :ref:`track_cluster_stats &lt;envoy_api_field_config.cluster.v3.Cluster.track_cluster_stats&gt;`.
     * </pre>
     *
     * <code>bool track_timeout_budgets = 47 [deprecated = true];</code>
     * @return The trackTimeoutBudgets.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getTrackTimeoutBudgets() {
      return trackTimeoutBudgets_;
    }
    /**
     * <pre>
     * If track_timeout_budgets is true, the :ref:`timeout budget histograms
     * &lt;config_cluster_manager_cluster_stats_timeout_budgets&gt;` will be published for each
     * request. These show what percentage of a request's per try and global timeout was used. A value
     * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
     * of 100 would indicate that the request took the entirety of the timeout given to it.
     * .. attention::
     *   This field has been deprecated in favor of `timeout_budgets`, part of
     *   :ref:`track_cluster_stats &lt;envoy_api_field_config.cluster.v3.Cluster.track_cluster_stats&gt;`.
     * </pre>
     *
     * <code>bool track_timeout_budgets = 47 [deprecated = true];</code>
     * @param value The trackTimeoutBudgets to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setTrackTimeoutBudgets(boolean value) {
      
      trackTimeoutBudgets_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If track_timeout_budgets is true, the :ref:`timeout budget histograms
     * &lt;config_cluster_manager_cluster_stats_timeout_budgets&gt;` will be published for each
     * request. These show what percentage of a request's per try and global timeout was used. A value
     * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
     * of 100 would indicate that the request took the entirety of the timeout given to it.
     * .. attention::
     *   This field has been deprecated in favor of `timeout_budgets`, part of
     *   :ref:`track_cluster_stats &lt;envoy_api_field_config.cluster.v3.Cluster.track_cluster_stats&gt;`.
     * </pre>
     *
     * <code>bool track_timeout_budgets = 47 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearTrackTimeoutBudgets() {
      
      trackTimeoutBudgets_ = false;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig upstreamConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> upstreamConfigBuilder_;
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     * @return Whether the upstreamConfig field is set.
     */
    public boolean hasUpstreamConfig() {
      return upstreamConfigBuilder_ != null || upstreamConfig_ != null;
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     * @return The upstreamConfig.
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getUpstreamConfig() {
      if (upstreamConfigBuilder_ == null) {
        return upstreamConfig_ == null ? io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : upstreamConfig_;
      } else {
        return upstreamConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    public Builder setUpstreamConfig(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (upstreamConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        upstreamConfig_ = value;
        onChanged();
      } else {
        upstreamConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    public Builder setUpstreamConfig(
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (upstreamConfigBuilder_ == null) {
        upstreamConfig_ = builderForValue.build();
        onChanged();
      } else {
        upstreamConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    public Builder mergeUpstreamConfig(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (upstreamConfigBuilder_ == null) {
        if (upstreamConfig_ != null) {
          upstreamConfig_ =
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.newBuilder(upstreamConfig_).mergeFrom(value).buildPartial();
        } else {
          upstreamConfig_ = value;
        }
        onChanged();
      } else {
        upstreamConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    public Builder clearUpstreamConfig() {
      if (upstreamConfigBuilder_ == null) {
        upstreamConfig_ = null;
        onChanged();
      } else {
        upstreamConfig_ = null;
        upstreamConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder getUpstreamConfigBuilder() {
      
      onChanged();
      return getUpstreamConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getUpstreamConfigOrBuilder() {
      if (upstreamConfigBuilder_ != null) {
        return upstreamConfigBuilder_.getMessageOrBuilder();
      } else {
        return upstreamConfig_ == null ?
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : upstreamConfig_;
      }
    }
    /**
     * <pre>
     * Optional customization and configuration of upstream connection pool, and upstream type.
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from `http2_protocol_options`
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
        getUpstreamConfigFieldBuilder() {
      if (upstreamConfigBuilder_ == null) {
        upstreamConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder>(
                getUpstreamConfig(),
                getParentForChildren(),
                isClean());
        upstreamConfig_ = null;
      }
      return upstreamConfigBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats trackClusterStats_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats, io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.Builder, io.envoyproxy.envoy.config.cluster.v3.TrackClusterStatsOrBuilder> trackClusterStatsBuilder_;
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     * @return Whether the trackClusterStats field is set.
     */
    public boolean hasTrackClusterStats() {
      return trackClusterStatsBuilder_ != null || trackClusterStats_ != null;
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     * @return The trackClusterStats.
     */
    public io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats getTrackClusterStats() {
      if (trackClusterStatsBuilder_ == null) {
        return trackClusterStats_ == null ? io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.getDefaultInstance() : trackClusterStats_;
      } else {
        return trackClusterStatsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    public Builder setTrackClusterStats(io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats value) {
      if (trackClusterStatsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        trackClusterStats_ = value;
        onChanged();
      } else {
        trackClusterStatsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    public Builder setTrackClusterStats(
        io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.Builder builderForValue) {
      if (trackClusterStatsBuilder_ == null) {
        trackClusterStats_ = builderForValue.build();
        onChanged();
      } else {
        trackClusterStatsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    public Builder mergeTrackClusterStats(io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats value) {
      if (trackClusterStatsBuilder_ == null) {
        if (trackClusterStats_ != null) {
          trackClusterStats_ =
            io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.newBuilder(trackClusterStats_).mergeFrom(value).buildPartial();
        } else {
          trackClusterStats_ = value;
        }
        onChanged();
      } else {
        trackClusterStatsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    public Builder clearTrackClusterStats() {
      if (trackClusterStatsBuilder_ == null) {
        trackClusterStats_ = null;
        onChanged();
      } else {
        trackClusterStats_ = null;
        trackClusterStatsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.Builder getTrackClusterStatsBuilder() {
      
      onChanged();
      return getTrackClusterStatsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.TrackClusterStatsOrBuilder getTrackClusterStatsOrBuilder() {
      if (trackClusterStatsBuilder_ != null) {
        return trackClusterStatsBuilder_.getMessageOrBuilder();
      } else {
        return trackClusterStats_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.getDefaultInstance() : trackClusterStats_;
      }
    }
    /**
     * <pre>
     * Configuration to track optional cluster stats.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats, io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.Builder, io.envoyproxy.envoy.config.cluster.v3.TrackClusterStatsOrBuilder> 
        getTrackClusterStatsFieldBuilder() {
      if (trackClusterStatsBuilder_ == null) {
        trackClusterStatsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats, io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats.Builder, io.envoyproxy.envoy.config.cluster.v3.TrackClusterStatsOrBuilder>(
                getTrackClusterStats(),
                getParentForChildren(),
                isClean());
        trackClusterStats_ = null;
      }
      return trackClusterStatsBuilder_;
    }

    private io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnectPolicy_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder> preconnectPolicyBuilder_;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     * @return Whether the preconnectPolicy field is set.
     */
    public boolean hasPreconnectPolicy() {
      return preconnectPolicyBuilder_ != null || preconnectPolicy_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     * @return The preconnectPolicy.
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy getPreconnectPolicy() {
      if (preconnectPolicyBuilder_ == null) {
        return preconnectPolicy_ == null ? io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.getDefaultInstance() : preconnectPolicy_;
      } else {
        return preconnectPolicyBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    public Builder setPreconnectPolicy(io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy value) {
      if (preconnectPolicyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        preconnectPolicy_ = value;
        onChanged();
      } else {
        preconnectPolicyBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    public Builder setPreconnectPolicy(
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder builderForValue) {
      if (preconnectPolicyBuilder_ == null) {
        preconnectPolicy_ = builderForValue.build();
        onChanged();
      } else {
        preconnectPolicyBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    public Builder mergePreconnectPolicy(io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy value) {
      if (preconnectPolicyBuilder_ == null) {
        if (preconnectPolicy_ != null) {
          preconnectPolicy_ =
            io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.newBuilder(preconnectPolicy_).mergeFrom(value).buildPartial();
        } else {
          preconnectPolicy_ = value;
        }
        onChanged();
      } else {
        preconnectPolicyBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    public Builder clearPreconnectPolicy() {
      if (preconnectPolicyBuilder_ == null) {
        preconnectPolicy_ = null;
        onChanged();
      } else {
        preconnectPolicy_ = null;
        preconnectPolicyBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder getPreconnectPolicyBuilder() {
      
      onChanged();
      return getPreconnectPolicyFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    public io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder getPreconnectPolicyOrBuilder() {
      if (preconnectPolicyBuilder_ != null) {
        return preconnectPolicyBuilder_.getMessageOrBuilder();
      } else {
        return preconnectPolicy_ == null ?
            io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.getDefaultInstance() : preconnectPolicy_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * Preconnect configuration for this cluster.
     * </pre>
     *
     * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder> 
        getPreconnectPolicyFieldBuilder() {
      if (preconnectPolicyBuilder_ == null) {
        preconnectPolicyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy.Builder, io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder>(
                getPreconnectPolicy(),
                getParentForChildren(),
                isClean());
        preconnectPolicy_ = null;
      }
      return preconnectPolicyBuilder_;
    }

    private boolean connectionPoolPerDownstreamConnection_ ;
    /**
     * <pre>
     * If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
     * connection pool for every downstream connection
     * </pre>
     *
     * <code>bool connection_pool_per_downstream_connection = 51;</code>
     * @return The connectionPoolPerDownstreamConnection.
     */
    @java.lang.Override
    public boolean getConnectionPoolPerDownstreamConnection() {
      return connectionPoolPerDownstreamConnection_;
    }
    /**
     * <pre>
     * If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
     * connection pool for every downstream connection
     * </pre>
     *
     * <code>bool connection_pool_per_downstream_connection = 51;</code>
     * @param value The connectionPoolPerDownstreamConnection to set.
     * @return This builder for chaining.
     */
    public Builder setConnectionPoolPerDownstreamConnection(boolean value) {
      
      connectionPoolPerDownstreamConnection_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
     * connection pool for every downstream connection
     * </pre>
     *
     * <code>bool connection_pool_per_downstream_connection = 51;</code>
     * @return This builder for chaining.
     */
    public Builder clearConnectionPoolPerDownstreamConnection() {
      
      connectionPoolPerDownstreamConnection_ = false;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.config.cluster.v3.Cluster)
  }

  // @@protoc_insertion_point(class_scope:envoy.config.cluster.v3.Cluster)
  private static final io.envoyproxy.envoy.config.cluster.v3.Cluster DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.cluster.v3.Cluster();
  }

  public static io.envoyproxy.envoy.config.cluster.v3.Cluster getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Cluster>
      PARSER = new com.google.protobuf.AbstractParser<Cluster>() {
    @java.lang.Override
    public Cluster parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new Cluster(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<Cluster> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Cluster> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.envoyproxy.envoy.config.cluster.v3.Cluster getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

