// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/cluster/v3/cluster.proto

package io.envoyproxy.envoy.config.cluster.v3;

public interface ClusterOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.cluster.v3.Cluster)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch> 
      getTransportSocketMatchesList();
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatch getTransportSocketMatches(int index);
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  int getTransportSocketMatchesCount();
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder> 
      getTransportSocketMatchesOrBuilderList();
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria &lt;envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria&gt;` field.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.TransportSocketMatchOrBuilder getTransportSocketMatchesOrBuilder(
      int index);

  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_config.cluster.v3.Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   * @return The altStatName.
   */
  java.lang.String getAltStatName();
  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   * @return The bytes for altStatName.
   */
  com.google.protobuf.ByteString
      getAltStatNameBytes();

  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the type field is set.
   */
  boolean hasType();
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for type.
   */
  int getTypeValue();
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return The type.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType getType();

  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
   * @return Whether the clusterType field is set.
   */
  boolean hasClusterType();
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
   * @return The clusterType.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterType getClusterType();
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.CustomClusterTypeOrBuilder getClusterTypeOrBuilder();

  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   * @return Whether the edsClusterConfig field is set.
   */
  boolean hasEdsClusterConfig();
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   * @return The edsClusterConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig getEdsClusterConfig();
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfigOrBuilder getEdsClusterConfigOrBuilder();

  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the connectTimeout field is set.
   */
  boolean hasConnectTimeout();
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   * @return The connectTimeout.
   */
  com.google.protobuf.Duration getConnectTimeout();
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getConnectTimeoutOrBuilder();

  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the perConnectionBufferLimitBytes field is set.
   */
  boolean hasPerConnectionBufferLimitBytes();
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   * @return The perConnectionBufferLimitBytes.
   */
  com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes();
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder();

  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for lbPolicy.
   */
  int getLbPolicyValue();
  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * [#comment:TODO: Remove enum constraint :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;` when implemented.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   * @return The lbPolicy.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy getLbPolicy();

  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
   * @return Whether the loadAssignment field is set.
   */
  boolean hasLoadAssignment();
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
   * @return The loadAssignment.
   */
  io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment getLoadAssignment();
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;</code>
   */
  io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignmentOrBuilder getLoadAssignmentOrBuilder();

  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck> 
      getHealthChecksList();
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  io.envoyproxy.envoy.config.core.v3.HealthCheck getHealthChecks(int index);
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  int getHealthChecksCount();
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder> 
      getHealthChecksOrBuilderList();
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HealthCheck health_checks = 8;</code>
   */
  io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder getHealthChecksOrBuilder(
      int index);

  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   * @return Whether the maxRequestsPerConnection field is set.
   */
  boolean hasMaxRequestsPerConnection();
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   * @return The maxRequestsPerConnection.
   */
  com.google.protobuf.UInt32Value getMaxRequestsPerConnection();
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxRequestsPerConnectionOrBuilder();

  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
   * @return Whether the circuitBreakers field is set.
   */
  boolean hasCircuitBreakers();
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
   * @return The circuitBreakers.
   */
  io.envoyproxy.envoy.config.cluster.v3.CircuitBreakers getCircuitBreakers();
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder();

  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
   * @return Whether the upstreamHttpProtocolOptions field is set.
   */
  @java.lang.Deprecated boolean hasUpstreamHttpProtocolOptions();
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
   * @return The upstreamHttpProtocolOptions.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptions getUpstreamHttpProtocolOptions();
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.UpstreamHttpProtocolOptionsOrBuilder getUpstreamHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
   * @return Whether the commonHttpProtocolOptions field is set.
   */
  @java.lang.Deprecated boolean hasCommonHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
   * @return The commonHttpProtocolOptions.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options&gt;`
   * in the :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
   * @return Whether the httpProtocolOptions field is set.
   */
  @java.lang.Deprecated boolean hasHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
   * @return The httpProtocolOptions.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
   * @return Whether the http2ProtocolOptions field is set.
   */
  @java.lang.Deprecated boolean hasHttp2ProtocolOptions();
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
   * @return The http2ProtocolOptions.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions();
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the in the
   * :ref:`http_protocol_options &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * See ref:`upstream_http_protocol_options
   * &lt;envoy_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options&gt;`
   * for example usage.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true, (.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder();

  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  int getTypedExtensionProtocolOptionsCount();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  boolean containsTypedExtensionProtocolOptions(
      java.lang.String key);
  /**
   * Use {@link #getTypedExtensionProtocolOptionsMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, com.google.protobuf.Any>
  getTypedExtensionProtocolOptions();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  java.util.Map<java.lang.String, com.google.protobuf.Any>
  getTypedExtensionProtocolOptionsMap();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  com.google.protobuf.Any getTypedExtensionProtocolOptionsOrDefault(
      java.lang.String key,
      com.google.protobuf.Any defaultValue);
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  com.google.protobuf.Any getTypedExtensionProtocolOptionsOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsRefreshRate field is set.
   */
  boolean hasDnsRefreshRate();
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   * @return The dnsRefreshRate.
   */
  com.google.protobuf.Duration getDnsRefreshRate();
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder();

  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   * @return Whether the dnsFailureRefreshRate field is set.
   */
  boolean hasDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   * @return The dnsFailureRefreshRate.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder getDnsFailureRefreshRateOrBuilder();

  /**
   * <pre>
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   * </pre>
   *
   * <code>bool respect_dns_ttl = 39;</code>
   * @return The respectDnsTtl.
   */
  boolean getRespectDnsTtl();

  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for dnsLookupFamily.
   */
  int getDnsLookupFamilyValue();
  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   * @return The dnsLookupFamily.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily getDnsLookupFamily();

  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.Address> 
      getDnsResolversList();
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  io.envoyproxy.envoy.config.core.v3.Address getDnsResolvers(int index);
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  int getDnsResolversCount();
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> 
      getDnsResolversOrBuilderList();
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Address dns_resolvers = 18;</code>
   */
  io.envoyproxy.envoy.config.core.v3.AddressOrBuilder getDnsResolversOrBuilder(
      int index);

  /**
   * <pre>
   * [#next-major-version: Reconcile DNS options in a single message.]
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple' API only uses UDP for DNS resolution.
   * </pre>
   *
   * <code>bool use_tcp_for_dns_lookups = 45;</code>
   * @return The useTcpForDnsLookups.
   */
  boolean getUseTcpForDnsLookups();

  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
   * @return Whether the outlierDetection field is set.
   */
  boolean hasOutlierDetection();
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
   * @return The outlierDetection.
   */
  io.envoyproxy.envoy.config.cluster.v3.OutlierDetection getOutlierDetection();
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder();

  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   * @return Whether the cleanupInterval field is set.
   */
  boolean hasCleanupInterval();
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   * @return The cleanupInterval.
   */
  com.google.protobuf.Duration getCleanupInterval();
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getCleanupIntervalOrBuilder();

  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
   * @return Whether the upstreamBindConfig field is set.
   */
  boolean hasUpstreamBindConfig();
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
   * @return The upstreamBindConfig.
   */
  io.envoyproxy.envoy.config.core.v3.BindConfig getUpstreamBindConfig();
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.config.core.v3.BindConfig upstream_bind_config = 21;</code>
   */
  io.envoyproxy.envoy.config.core.v3.BindConfigOrBuilder getUpstreamBindConfigOrBuilder();

  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   * @return Whether the lbSubsetConfig field is set.
   */
  boolean hasLbSubsetConfig();
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   * @return The lbSubsetConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfig getLbSubsetConfig();
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.LbSubsetConfigOrBuilder getLbSubsetConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   * @return Whether the ringHashLbConfig field is set.
   */
  boolean hasRingHashLbConfig();
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   * @return The ringHashLbConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfig getRingHashLbConfig();
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RingHashLbConfigOrBuilder getRingHashLbConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the Maglev load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
   * @return Whether the maglevLbConfig field is set.
   */
  boolean hasMaglevLbConfig();
  /**
   * <pre>
   * Optional configuration for the Maglev load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
   * @return The maglevLbConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfig getMaglevLbConfig();
  /**
   * <pre>
   * Optional configuration for the Maglev load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.MaglevLbConfigOrBuilder getMaglevLbConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   * @return Whether the originalDstLbConfig field is set.
   */
  boolean hasOriginalDstLbConfig();
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   * @return The originalDstLbConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig getOriginalDstLbConfig();
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigOrBuilder getOriginalDstLbConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   * @return Whether the leastRequestLbConfig field is set.
   */
  boolean hasLeastRequestLbConfig();
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   * @return The leastRequestLbConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig getLeastRequestLbConfig();
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigOrBuilder getLeastRequestLbConfigOrBuilder();

  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
   * @return Whether the commonLbConfig field is set.
   */
  boolean hasCommonLbConfig();
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
   * @return The commonLbConfig.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfig getCommonLbConfig();
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.CommonLbConfigOrBuilder getCommonLbConfigOrBuilder();

  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
   * @return Whether the transportSocket field is set.
   */
  boolean hasTransportSocket();
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
   * @return The transportSocket.
   */
  io.envoyproxy.envoy.config.core.v3.TransportSocket getTransportSocket();
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TransportSocket transport_socket = 24;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TransportSocketOrBuilder getTransportSocketOrBuilder();

  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
   * @return Whether the metadata field is set.
   */
  boolean hasMetadata();
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
   * @return The metadata.
   */
  io.envoyproxy.envoy.config.core.v3.Metadata getMetadata();
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 25;</code>
   */
  io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder getMetadataOrBuilder();

  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * This has been deprecated in favor of setting explicit protocol selection
   * in the :ref:`http_protocol_options
   * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
   * @return The enum numeric value on the wire for protocolSelection.
   */
  @java.lang.Deprecated int getProtocolSelectionValue();
  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * This has been deprecated in favor of setting explicit protocol selection
   * in the :ref:`http_protocol_options
   * &lt;envoy_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions&gt;` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options&lt;envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];</code>
   * @return The protocolSelection.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterProtocolSelection getProtocolSelection();

  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   * @return Whether the upstreamConnectionOptions field is set.
   */
  boolean hasUpstreamConnectionOptions();
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   * @return The upstreamConnectionOptions.
   */
  io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptions getUpstreamConnectionOptions();
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.UpstreamConnectionOptionsOrBuilder getUpstreamConnectionOptionsOrBuilder();

  /**
   * <pre>
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   * .. note::
   *   This is currently only supported for connections created by tcp_proxy.
   * .. note::
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   * </pre>
   *
   * <code>bool close_connections_on_host_health_failure = 31;</code>
   * @return The closeConnectionsOnHostHealthFailure.
   */
  boolean getCloseConnectionsOnHostHealthFailure();

  /**
   * <pre>
   * If set to true, Envoy will ignore the health value of a host when processing its removal
   * from service discovery. This means that if active health checking is used, Envoy will *not*
   * wait for the endpoint to go unhealthy before removing it.
   * </pre>
   *
   * <code>bool ignore_health_on_host_removal = 32;</code>
   * @return The ignoreHealthOnHostRemoval.
   */
  boolean getIgnoreHealthOnHostRemoval();

  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.cluster.v3.Filter> 
      getFiltersList();
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Filter getFilters(int index);
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  int getFiltersCount();
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder> 
      getFiltersOrBuilderList();
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.config.cluster.v3.Filter filters = 40;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.FilterOrBuilder getFiltersOrBuilder(
      int index);

  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
   * @return Whether the loadBalancingPolicy field is set.
   */
  boolean hasLoadBalancingPolicy();
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
   * @return The loadBalancingPolicy.
   */
  io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicy getLoadBalancingPolicy();
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_config.cluster.v3.Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.LoadBalancingPolicyOrBuilder getLoadBalancingPolicyOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
   * @return Whether the lrsServer field is set.
   */
  boolean hasLrsServer();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
   * @return The lrsServer.
   */
  io.envoyproxy.envoy.config.core.v3.ConfigSource getLrsServer();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.config.core.v3.ConfigSource lrs_server = 42;</code>
   */
  io.envoyproxy.envoy.config.core.v3.ConfigSourceOrBuilder getLrsServerOrBuilder();

  /**
   * <pre>
   * If track_timeout_budgets is true, the :ref:`timeout budget histograms
   * &lt;config_cluster_manager_cluster_stats_timeout_budgets&gt;` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   * .. attention::
   *   This field has been deprecated in favor of `timeout_budgets`, part of
   *   :ref:`track_cluster_stats &lt;envoy_api_field_config.cluster.v3.Cluster.track_cluster_stats&gt;`.
   * </pre>
   *
   * <code>bool track_timeout_budgets = 47 [deprecated = true];</code>
   * @return The trackTimeoutBudgets.
   */
  @java.lang.Deprecated boolean getTrackTimeoutBudgets();

  /**
   * <pre>
   * Optional customization and configuration of upstream connection pool, and upstream type.
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from `http2_protocol_options`
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
   * @return Whether the upstreamConfig field is set.
   */
  boolean hasUpstreamConfig();
  /**
   * <pre>
   * Optional customization and configuration of upstream connection pool, and upstream type.
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from `http2_protocol_options`
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
   * @return The upstreamConfig.
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getUpstreamConfig();
  /**
   * <pre>
   * Optional customization and configuration of upstream connection pool, and upstream type.
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from `http2_protocol_options`
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getUpstreamConfigOrBuilder();

  /**
   * <pre>
   * Configuration to track optional cluster stats.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
   * @return Whether the trackClusterStats field is set.
   */
  boolean hasTrackClusterStats();
  /**
   * <pre>
   * Configuration to track optional cluster stats.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
   * @return The trackClusterStats.
   */
  io.envoyproxy.envoy.config.cluster.v3.TrackClusterStats getTrackClusterStats();
  /**
   * <pre>
   * Configuration to track optional cluster stats.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.TrackClusterStatsOrBuilder getTrackClusterStatsOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * Preconnect configuration for this cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
   * @return Whether the preconnectPolicy field is set.
   */
  boolean hasPreconnectPolicy();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Preconnect configuration for this cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
   * @return The preconnectPolicy.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicy getPreconnectPolicy();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Preconnect configuration for this cluster.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.PreconnectPolicyOrBuilder getPreconnectPolicyOrBuilder();

  /**
   * <pre>
   * If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
   * connection pool for every downstream connection
   * </pre>
   *
   * <code>bool connection_pool_per_downstream_connection = 51;</code>
   * @return The connectionPoolPerDownstreamConnection.
   */
  boolean getConnectionPoolPerDownstreamConnection();

  public io.envoyproxy.envoy.config.cluster.v3.Cluster.ClusterDiscoveryTypeCase getClusterDiscoveryTypeCase();

  public io.envoyproxy.envoy.config.cluster.v3.Cluster.LbConfigCase getLbConfigCase();
}
