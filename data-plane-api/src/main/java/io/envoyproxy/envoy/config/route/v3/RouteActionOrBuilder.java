// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/route/v3/route_components.proto

package io.envoyproxy.envoy.config.route.v3;

public interface RouteActionOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.route.v3.RouteAction)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Indicates the upstream cluster to which the request should be routed
   * to.
   * </pre>
   *
   * <code>string cluster = 1 [(.validate.rules) = { ... }</code>
   * @return Whether the cluster field is set.
   */
  boolean hasCluster();
  /**
   * <pre>
   * Indicates the upstream cluster to which the request should be routed
   * to.
   * </pre>
   *
   * <code>string cluster = 1 [(.validate.rules) = { ... }</code>
   * @return The cluster.
   */
  java.lang.String getCluster();
  /**
   * <pre>
   * Indicates the upstream cluster to which the request should be routed
   * to.
   * </pre>
   *
   * <code>string cluster = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for cluster.
   */
  com.google.protobuf.ByteString
      getClusterBytes();

  /**
   * <pre>
   * Envoy will determine the cluster to route to by reading the value of the
   * HTTP header named by cluster_header from the request headers. If the
   * header is not found or the referenced cluster does not exist, Envoy will
   * return a 404 response.
   * .. attention::
   *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
   *   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
   * .. note::
   *   If the header appears multiple times only the first value is used.
   * </pre>
   *
   * <code>string cluster_header = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the clusterHeader field is set.
   */
  boolean hasClusterHeader();
  /**
   * <pre>
   * Envoy will determine the cluster to route to by reading the value of the
   * HTTP header named by cluster_header from the request headers. If the
   * header is not found or the referenced cluster does not exist, Envoy will
   * return a 404 response.
   * .. attention::
   *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
   *   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
   * .. note::
   *   If the header appears multiple times only the first value is used.
   * </pre>
   *
   * <code>string cluster_header = 2 [(.validate.rules) = { ... }</code>
   * @return The clusterHeader.
   */
  java.lang.String getClusterHeader();
  /**
   * <pre>
   * Envoy will determine the cluster to route to by reading the value of the
   * HTTP header named by cluster_header from the request headers. If the
   * header is not found or the referenced cluster does not exist, Envoy will
   * return a 404 response.
   * .. attention::
   *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
   *   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
   * .. note::
   *   If the header appears multiple times only the first value is used.
   * </pre>
   *
   * <code>string cluster_header = 2 [(.validate.rules) = { ... }</code>
   * @return The bytes for clusterHeader.
   */
  com.google.protobuf.ByteString
      getClusterHeaderBytes();

  /**
   * <pre>
   * Multiple upstream clusters can be specified for a given route. The
   * request is routed to one of the upstream clusters based on weights
   * assigned to each cluster. See
   * :ref:`traffic splitting &lt;config_http_conn_man_route_table_traffic_splitting_split&gt;`
   * for additional documentation.
   * </pre>
   *
   * <code>.envoy.config.route.v3.WeightedCluster weighted_clusters = 3;</code>
   * @return Whether the weightedClusters field is set.
   */
  boolean hasWeightedClusters();
  /**
   * <pre>
   * Multiple upstream clusters can be specified for a given route. The
   * request is routed to one of the upstream clusters based on weights
   * assigned to each cluster. See
   * :ref:`traffic splitting &lt;config_http_conn_man_route_table_traffic_splitting_split&gt;`
   * for additional documentation.
   * </pre>
   *
   * <code>.envoy.config.route.v3.WeightedCluster weighted_clusters = 3;</code>
   * @return The weightedClusters.
   */
  io.envoyproxy.envoy.config.route.v3.WeightedCluster getWeightedClusters();
  /**
   * <pre>
   * Multiple upstream clusters can be specified for a given route. The
   * request is routed to one of the upstream clusters based on weights
   * assigned to each cluster. See
   * :ref:`traffic splitting &lt;config_http_conn_man_route_table_traffic_splitting_split&gt;`
   * for additional documentation.
   * </pre>
   *
   * <code>.envoy.config.route.v3.WeightedCluster weighted_clusters = 3;</code>
   */
  io.envoyproxy.envoy.config.route.v3.WeightedClusterOrBuilder getWeightedClustersOrBuilder();

  /**
   * <pre>
   * The HTTP status code to use when configured cluster is not found.
   * The default response code is 503 Service Unavailable.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for clusterNotFoundResponseCode.
   */
  int getClusterNotFoundResponseCodeValue();
  /**
   * <pre>
   * The HTTP status code to use when configured cluster is not found.
   * The default response code is 503 Service Unavailable.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20 [(.validate.rules) = { ... }</code>
   * @return The clusterNotFoundResponseCode.
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode getClusterNotFoundResponseCode();

  /**
   * <pre>
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what's set in this field will be considered
   * for load balancing. If using :ref:`weighted_clusters
   * &lt;envoy_api_field_config.route.v3.RouteAction.weighted_clusters&gt;`, metadata will be merged, with values
   * provided there taking precedence. The filter name should be specified as *envoy.lb*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata_match = 4;</code>
   * @return Whether the metadataMatch field is set.
   */
  boolean hasMetadataMatch();
  /**
   * <pre>
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what's set in this field will be considered
   * for load balancing. If using :ref:`weighted_clusters
   * &lt;envoy_api_field_config.route.v3.RouteAction.weighted_clusters&gt;`, metadata will be merged, with values
   * provided there taking precedence. The filter name should be specified as *envoy.lb*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata_match = 4;</code>
   * @return The metadataMatch.
   */
  io.envoyproxy.envoy.config.core.v3.Metadata getMetadataMatch();
  /**
   * <pre>
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what's set in this field will be considered
   * for load balancing. If using :ref:`weighted_clusters
   * &lt;envoy_api_field_config.route.v3.RouteAction.weighted_clusters&gt;`, metadata will be merged, with values
   * provided there taking precedence. The filter name should be specified as *envoy.lb*.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata_match = 4;</code>
   */
  io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder getMetadataMatchOrBuilder();

  /**
   * <pre>
   * Indicates that during forwarding, the matched prefix (or path) should be
   * swapped with this value. This option allows application URLs to be rooted
   * at a different path from those exposed at the reverse proxy layer. The router filter will
   * place the original path before rewrite into the :ref:`x-envoy-original-path
   * &lt;config_http_filters_router_x-envoy-original-path&gt;` header.
   * Only one of *prefix_rewrite* or
   * :ref:`regex_rewrite &lt;envoy_api_field_config.route.v3.RouteAction.regex_rewrite&gt;`
   * may be specified.
   * .. attention::
   *   Pay careful attention to the use of trailing slashes in the
   *   :ref:`route's match &lt;envoy_api_field_config.route.v3.Route.match&gt;` prefix value.
   *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
   *   rewriting *&#47;prefix* to *&#47;&#42; and *&#47;prefix/etc* to *&#47;etc* cannot be done in a single
   *   :ref:`Route &lt;envoy_api_msg_config.route.v3.Route&gt;`, as shown by the below config entries:
   *   .. code-block:: yaml
   *     - match:
   *         prefix: "/prefix/"
   *       route:
   *         prefix_rewrite: "/"
   *     - match:
   *         prefix: "/prefix"
   *       route:
   *         prefix_rewrite: "/"
   *   Having above entries in the config, requests to *&#47;prefix* will be stripped to *&#47;&#42;, while
   *   requests to *&#47;prefix/etc* will be stripped to *&#47;etc*.
   * </pre>
   *
   * <code>string prefix_rewrite = 5 [(.validate.rules) = { ... }</code>
   * @return The prefixRewrite.
   */
  java.lang.String getPrefixRewrite();
  /**
   * <pre>
   * Indicates that during forwarding, the matched prefix (or path) should be
   * swapped with this value. This option allows application URLs to be rooted
   * at a different path from those exposed at the reverse proxy layer. The router filter will
   * place the original path before rewrite into the :ref:`x-envoy-original-path
   * &lt;config_http_filters_router_x-envoy-original-path&gt;` header.
   * Only one of *prefix_rewrite* or
   * :ref:`regex_rewrite &lt;envoy_api_field_config.route.v3.RouteAction.regex_rewrite&gt;`
   * may be specified.
   * .. attention::
   *   Pay careful attention to the use of trailing slashes in the
   *   :ref:`route's match &lt;envoy_api_field_config.route.v3.Route.match&gt;` prefix value.
   *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
   *   rewriting *&#47;prefix* to *&#47;&#42; and *&#47;prefix/etc* to *&#47;etc* cannot be done in a single
   *   :ref:`Route &lt;envoy_api_msg_config.route.v3.Route&gt;`, as shown by the below config entries:
   *   .. code-block:: yaml
   *     - match:
   *         prefix: "/prefix/"
   *       route:
   *         prefix_rewrite: "/"
   *     - match:
   *         prefix: "/prefix"
   *       route:
   *         prefix_rewrite: "/"
   *   Having above entries in the config, requests to *&#47;prefix* will be stripped to *&#47;&#42;, while
   *   requests to *&#47;prefix/etc* will be stripped to *&#47;etc*.
   * </pre>
   *
   * <code>string prefix_rewrite = 5 [(.validate.rules) = { ... }</code>
   * @return The bytes for prefixRewrite.
   */
  com.google.protobuf.ByteString
      getPrefixRewriteBytes();

  /**
   * <pre>
   * Indicates that during forwarding, portions of the path that match the
   * pattern should be rewritten, even allowing the substitution of capture
   * groups from the pattern into the new path as specified by the rewrite
   * substitution string. This is useful to allow application paths to be
   * rewritten in a way that is aware of segments with variable content like
   * identifiers. The router filter will place the original path as it was
   * before the rewrite into the :ref:`x-envoy-original-path
   * &lt;config_http_filters_router_x-envoy-original-path&gt;` header.
   * Only one of :ref:`prefix_rewrite &lt;envoy_api_field_config.route.v3.RouteAction.prefix_rewrite&gt;`
   * or *regex_rewrite* may be specified.
   * Examples using Google's `RE2 &lt;https://github.com/google/re2&gt;`_ engine:
   * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
   *   string of ``&#92;2/instance/&#92;1`` would transform ``/service/foo/v1/api``
   *   into ``/v1/api/instance/foo``.
   * * The pattern ``one`` paired with a substitution string of ``two`` would
   *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
   * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
   *   ``&#92;1two&#92;2`` would replace only the first occurrence of ``one``,
   *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
   * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
   *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
   *   ``/aaa/yyy/bbb``.
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32;</code>
   * @return Whether the regexRewrite field is set.
   */
  boolean hasRegexRewrite();
  /**
   * <pre>
   * Indicates that during forwarding, portions of the path that match the
   * pattern should be rewritten, even allowing the substitution of capture
   * groups from the pattern into the new path as specified by the rewrite
   * substitution string. This is useful to allow application paths to be
   * rewritten in a way that is aware of segments with variable content like
   * identifiers. The router filter will place the original path as it was
   * before the rewrite into the :ref:`x-envoy-original-path
   * &lt;config_http_filters_router_x-envoy-original-path&gt;` header.
   * Only one of :ref:`prefix_rewrite &lt;envoy_api_field_config.route.v3.RouteAction.prefix_rewrite&gt;`
   * or *regex_rewrite* may be specified.
   * Examples using Google's `RE2 &lt;https://github.com/google/re2&gt;`_ engine:
   * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
   *   string of ``&#92;2/instance/&#92;1`` would transform ``/service/foo/v1/api``
   *   into ``/v1/api/instance/foo``.
   * * The pattern ``one`` paired with a substitution string of ``two`` would
   *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
   * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
   *   ``&#92;1two&#92;2`` would replace only the first occurrence of ``one``,
   *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
   * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
   *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
   *   ``/aaa/yyy/bbb``.
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32;</code>
   * @return The regexRewrite.
   */
  io.envoyproxy.envoy.type.matcher.v3.RegexMatchAndSubstitute getRegexRewrite();
  /**
   * <pre>
   * Indicates that during forwarding, portions of the path that match the
   * pattern should be rewritten, even allowing the substitution of capture
   * groups from the pattern into the new path as specified by the rewrite
   * substitution string. This is useful to allow application paths to be
   * rewritten in a way that is aware of segments with variable content like
   * identifiers. The router filter will place the original path as it was
   * before the rewrite into the :ref:`x-envoy-original-path
   * &lt;config_http_filters_router_x-envoy-original-path&gt;` header.
   * Only one of :ref:`prefix_rewrite &lt;envoy_api_field_config.route.v3.RouteAction.prefix_rewrite&gt;`
   * or *regex_rewrite* may be specified.
   * Examples using Google's `RE2 &lt;https://github.com/google/re2&gt;`_ engine:
   * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
   *   string of ``&#92;2/instance/&#92;1`` would transform ``/service/foo/v1/api``
   *   into ``/v1/api/instance/foo``.
   * * The pattern ``one`` paired with a substitution string of ``two`` would
   *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
   * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
   *   ``&#92;1two&#92;2`` would replace only the first occurrence of ``one``,
   *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
   * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
   *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
   *   ``/aaa/yyy/bbb``.
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32;</code>
   */
  io.envoyproxy.envoy.type.matcher.v3.RegexMatchAndSubstituteOrBuilder getRegexRewriteOrBuilder();

  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * this value.
   * </pre>
   *
   * <code>string host_rewrite_literal = 6 [(.validate.rules) = { ... }</code>
   * @return Whether the hostRewriteLiteral field is set.
   */
  boolean hasHostRewriteLiteral();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * this value.
   * </pre>
   *
   * <code>string host_rewrite_literal = 6 [(.validate.rules) = { ... }</code>
   * @return The hostRewriteLiteral.
   */
  java.lang.String getHostRewriteLiteral();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * this value.
   * </pre>
   *
   * <code>string host_rewrite_literal = 6 [(.validate.rules) = { ... }</code>
   * @return The bytes for hostRewriteLiteral.
   */
  com.google.protobuf.ByteString
      getHostRewriteLiteralBytes();

  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * the hostname of the upstream host chosen by the cluster manager. This
   * option is applicable only when the destination cluster for a route is of
   * type *strict_dns* or *logical_dns*. Setting this to true with other cluster
   * types has no effect.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue auto_host_rewrite = 7;</code>
   * @return Whether the autoHostRewrite field is set.
   */
  boolean hasAutoHostRewrite();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * the hostname of the upstream host chosen by the cluster manager. This
   * option is applicable only when the destination cluster for a route is of
   * type *strict_dns* or *logical_dns*. Setting this to true with other cluster
   * types has no effect.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue auto_host_rewrite = 7;</code>
   * @return The autoHostRewrite.
   */
  com.google.protobuf.BoolValue getAutoHostRewrite();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * the hostname of the upstream host chosen by the cluster manager. This
   * option is applicable only when the destination cluster for a route is of
   * type *strict_dns* or *logical_dns*. Setting this to true with other cluster
   * types has no effect.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue auto_host_rewrite = 7;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getAutoHostRewriteOrBuilder();

  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with the content of given
   * downstream or :ref:`custom &lt;config_http_conn_man_headers_custom_request_headers&gt;` header.
   * If header value is empty, host header is left intact.
   * .. attention::
   *   Pay attention to the potential security implications of using this option. Provided header
   *   must come from trusted source.
   * .. note::
   *   If the header appears multiple times only the first value is used.
   * </pre>
   *
   * <code>string host_rewrite_header = 29 [(.validate.rules) = { ... }</code>
   * @return Whether the hostRewriteHeader field is set.
   */
  boolean hasHostRewriteHeader();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with the content of given
   * downstream or :ref:`custom &lt;config_http_conn_man_headers_custom_request_headers&gt;` header.
   * If header value is empty, host header is left intact.
   * .. attention::
   *   Pay attention to the potential security implications of using this option. Provided header
   *   must come from trusted source.
   * .. note::
   *   If the header appears multiple times only the first value is used.
   * </pre>
   *
   * <code>string host_rewrite_header = 29 [(.validate.rules) = { ... }</code>
   * @return The hostRewriteHeader.
   */
  java.lang.String getHostRewriteHeader();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with the content of given
   * downstream or :ref:`custom &lt;config_http_conn_man_headers_custom_request_headers&gt;` header.
   * If header value is empty, host header is left intact.
   * .. attention::
   *   Pay attention to the potential security implications of using this option. Provided header
   *   must come from trusted source.
   * .. note::
   *   If the header appears multiple times only the first value is used.
   * </pre>
   *
   * <code>string host_rewrite_header = 29 [(.validate.rules) = { ... }</code>
   * @return The bytes for hostRewriteHeader.
   */
  com.google.protobuf.ByteString
      getHostRewriteHeaderBytes();

  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * the result of the regex substitution executed on path value with query and fragment removed.
   * This is useful for transitioning variable content between path segment and subdomain.
   * For example with the following config:
   *   .. code-block:: yaml
   *     host_rewrite_path_regex:
   *       pattern:
   *         google_re2: {}
   *         regex: "^/(.+)/.+$"
   *       substitution: &#92;1
   * Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`.
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35;</code>
   * @return Whether the hostRewritePathRegex field is set.
   */
  boolean hasHostRewritePathRegex();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * the result of the regex substitution executed on path value with query and fragment removed.
   * This is useful for transitioning variable content between path segment and subdomain.
   * For example with the following config:
   *   .. code-block:: yaml
   *     host_rewrite_path_regex:
   *       pattern:
   *         google_re2: {}
   *         regex: "^/(.+)/.+$"
   *       substitution: &#92;1
   * Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`.
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35;</code>
   * @return The hostRewritePathRegex.
   */
  io.envoyproxy.envoy.type.matcher.v3.RegexMatchAndSubstitute getHostRewritePathRegex();
  /**
   * <pre>
   * Indicates that during forwarding, the host header will be swapped with
   * the result of the regex substitution executed on path value with query and fragment removed.
   * This is useful for transitioning variable content between path segment and subdomain.
   * For example with the following config:
   *   .. code-block:: yaml
   *     host_rewrite_path_regex:
   *       pattern:
   *         google_re2: {}
   *         regex: "^/(.+)/.+$"
   *       substitution: &#92;1
   * Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`.
   * </pre>
   *
   * <code>.envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35;</code>
   */
  io.envoyproxy.envoy.type.matcher.v3.RegexMatchAndSubstituteOrBuilder getHostRewritePathRegexOrBuilder();

  /**
   * <pre>
   * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
   * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
   * processed and when the upstream response has been completely processed. A value of 0 will
   * disable the route's timeout.
   * .. note::
   *   This timeout includes all retries. See also
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *   :ref:`retry overview &lt;arch_overview_http_routing_retry&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 8;</code>
   * @return Whether the timeout field is set.
   */
  boolean hasTimeout();
  /**
   * <pre>
   * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
   * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
   * processed and when the upstream response has been completely processed. A value of 0 will
   * disable the route's timeout.
   * .. note::
   *   This timeout includes all retries. See also
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *   :ref:`retry overview &lt;arch_overview_http_routing_retry&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 8;</code>
   * @return The timeout.
   */
  com.google.protobuf.Duration getTimeout();
  /**
   * <pre>
   * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
   * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
   * processed and when the upstream response has been completely processed. A value of 0 will
   * disable the route's timeout.
   * .. note::
   *   This timeout includes all retries. See also
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *   :ref:`retry overview &lt;arch_overview_http_routing_retry&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 8;</code>
   */
  com.google.protobuf.DurationOrBuilder getTimeoutOrBuilder();

  /**
   * <pre>
   * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
   * although the connection manager wide :ref:`stream_idle_timeout
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
   * connection manager stream idle timeout is configured.
   * The idle timeout is distinct to :ref:`timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;`, which provides an upper bound
   * on the upstream response time; :ref:`idle_timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;` instead bounds the amount
   * of time the request's stream may be idle.
   * After header decoding, the idle timeout will apply on downstream and
   * upstream request events. Each time an encode/decode event for headers or
   * data is processed for the stream, the timer will be reset. If the timeout
   * fires, the stream is terminated with a 408 Request Timeout error code if no
   * upstream response header has been received, otherwise a stream reset
   * occurs.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration idle_timeout = 24;</code>
   * @return Whether the idleTimeout field is set.
   */
  boolean hasIdleTimeout();
  /**
   * <pre>
   * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
   * although the connection manager wide :ref:`stream_idle_timeout
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
   * connection manager stream idle timeout is configured.
   * The idle timeout is distinct to :ref:`timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;`, which provides an upper bound
   * on the upstream response time; :ref:`idle_timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;` instead bounds the amount
   * of time the request's stream may be idle.
   * After header decoding, the idle timeout will apply on downstream and
   * upstream request events. Each time an encode/decode event for headers or
   * data is processed for the stream, the timer will be reset. If the timeout
   * fires, the stream is terminated with a 408 Request Timeout error code if no
   * upstream response header has been received, otherwise a stream reset
   * occurs.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration idle_timeout = 24;</code>
   * @return The idleTimeout.
   */
  com.google.protobuf.Duration getIdleTimeout();
  /**
   * <pre>
   * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
   * although the connection manager wide :ref:`stream_idle_timeout
   * &lt;envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
   * connection manager stream idle timeout is configured.
   * The idle timeout is distinct to :ref:`timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;`, which provides an upper bound
   * on the upstream response time; :ref:`idle_timeout
   * &lt;envoy_api_field_config.route.v3.RouteAction.idle_timeout&gt;` instead bounds the amount
   * of time the request's stream may be idle.
   * After header decoding, the idle timeout will apply on downstream and
   * upstream request events. Each time an encode/decode event for headers or
   * data is processed for the stream, the timer will be reset. If the timeout
   * fires, the stream is terminated with a 408 Request Timeout error code if no
   * upstream response header has been received, otherwise a stream reset
   * occurs.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration idle_timeout = 24;</code>
   */
  com.google.protobuf.DurationOrBuilder getIdleTimeoutOrBuilder();

  /**
   * <pre>
   * Indicates that the route has a retry policy. Note that if this is set,
   * it'll take precedence over the virtual host level retry policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   * </pre>
   *
   * <code>.envoy.config.route.v3.RetryPolicy retry_policy = 9;</code>
   * @return Whether the retryPolicy field is set.
   */
  boolean hasRetryPolicy();
  /**
   * <pre>
   * Indicates that the route has a retry policy. Note that if this is set,
   * it'll take precedence over the virtual host level retry policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   * </pre>
   *
   * <code>.envoy.config.route.v3.RetryPolicy retry_policy = 9;</code>
   * @return The retryPolicy.
   */
  io.envoyproxy.envoy.config.route.v3.RetryPolicy getRetryPolicy();
  /**
   * <pre>
   * Indicates that the route has a retry policy. Note that if this is set,
   * it'll take precedence over the virtual host level retry policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   * </pre>
   *
   * <code>.envoy.config.route.v3.RetryPolicy retry_policy = 9;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RetryPolicyOrBuilder getRetryPolicyOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
   * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
   * most internal one becomes the enforced policy). :ref:`Retry policy &lt;envoy_api_field_config.route.v3.VirtualHost.retry_policy&gt;`
   * should not be set if this field is used.
   * </pre>
   *
   * <code>.google.protobuf.Any retry_policy_typed_config = 33;</code>
   * @return Whether the retryPolicyTypedConfig field is set.
   */
  boolean hasRetryPolicyTypedConfig();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
   * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
   * most internal one becomes the enforced policy). :ref:`Retry policy &lt;envoy_api_field_config.route.v3.VirtualHost.retry_policy&gt;`
   * should not be set if this field is used.
   * </pre>
   *
   * <code>.google.protobuf.Any retry_policy_typed_config = 33;</code>
   * @return The retryPolicyTypedConfig.
   */
  com.google.protobuf.Any getRetryPolicyTypedConfig();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
   * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
   * most internal one becomes the enforced policy). :ref:`Retry policy &lt;envoy_api_field_config.route.v3.VirtualHost.retry_policy&gt;`
   * should not be set if this field is used.
   * </pre>
   *
   * <code>.google.protobuf.Any retry_policy_typed_config = 33;</code>
   */
  com.google.protobuf.AnyOrBuilder getRetryPolicyTypedConfigOrBuilder();

  /**
   * <pre>
   * Indicates that the route has request mirroring policies.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.route.v3.RouteAction.RequestMirrorPolicy> 
      getRequestMirrorPoliciesList();
  /**
   * <pre>
   * Indicates that the route has request mirroring policies.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.RequestMirrorPolicy getRequestMirrorPolicies(int index);
  /**
   * <pre>
   * Indicates that the route has request mirroring policies.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;</code>
   */
  int getRequestMirrorPoliciesCount();
  /**
   * <pre>
   * Indicates that the route has request mirroring policies.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.route.v3.RouteAction.RequestMirrorPolicyOrBuilder> 
      getRequestMirrorPoliciesOrBuilderList();
  /**
   * <pre>
   * Indicates that the route has request mirroring policies.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.RequestMirrorPolicyOrBuilder getRequestMirrorPoliciesOrBuilder(
      int index);

  /**
   * <pre>
   * Optionally specifies the :ref:`routing priority &lt;arch_overview_http_routing_priority&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RoutingPriority priority = 11 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for priority.
   */
  int getPriorityValue();
  /**
   * <pre>
   * Optionally specifies the :ref:`routing priority &lt;arch_overview_http_routing_priority&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RoutingPriority priority = 11 [(.validate.rules) = { ... }</code>
   * @return The priority.
   */
  io.envoyproxy.envoy.config.core.v3.RoutingPriority getPriority();

  /**
   * <pre>
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RateLimit rate_limits = 13;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.route.v3.RateLimit> 
      getRateLimitsList();
  /**
   * <pre>
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RateLimit rate_limits = 13;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RateLimit getRateLimits(int index);
  /**
   * <pre>
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RateLimit rate_limits = 13;</code>
   */
  int getRateLimitsCount();
  /**
   * <pre>
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RateLimit rate_limits = 13;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.route.v3.RateLimitOrBuilder> 
      getRateLimitsOrBuilderList();
  /**
   * <pre>
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RateLimit rate_limits = 13;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RateLimitOrBuilder getRateLimitsOrBuilder(
      int index);

  /**
   * <pre>
   * Specifies if the rate limit filter should include the virtual host rate
   * limits. By default, if the route configured rate limits, the virtual host
   * :ref:`rate_limits &lt;envoy_api_field_config.route.v3.VirtualHost.rate_limits&gt;` are not applied to the
   * request.
   * This field is deprecated. Please use :ref:`vh_rate_limits &lt;envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue include_vh_rate_limits = 14 [deprecated = true];</code>
   * @return Whether the includeVhRateLimits field is set.
   */
  @java.lang.Deprecated boolean hasIncludeVhRateLimits();
  /**
   * <pre>
   * Specifies if the rate limit filter should include the virtual host rate
   * limits. By default, if the route configured rate limits, the virtual host
   * :ref:`rate_limits &lt;envoy_api_field_config.route.v3.VirtualHost.rate_limits&gt;` are not applied to the
   * request.
   * This field is deprecated. Please use :ref:`vh_rate_limits &lt;envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue include_vh_rate_limits = 14 [deprecated = true];</code>
   * @return The includeVhRateLimits.
   */
  @java.lang.Deprecated com.google.protobuf.BoolValue getIncludeVhRateLimits();
  /**
   * <pre>
   * Specifies if the rate limit filter should include the virtual host rate
   * limits. By default, if the route configured rate limits, the virtual host
   * :ref:`rate_limits &lt;envoy_api_field_config.route.v3.VirtualHost.rate_limits&gt;` are not applied to the
   * request.
   * This field is deprecated. Please use :ref:`vh_rate_limits &lt;envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue include_vh_rate_limits = 14 [deprecated = true];</code>
   */
  @java.lang.Deprecated com.google.protobuf.BoolValueOrBuilder getIncludeVhRateLimitsOrBuilder();

  /**
   * <pre>
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.route.v3.RouteAction.HashPolicy> 
      getHashPolicyList();
  /**
   * <pre>
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.HashPolicy getHashPolicy(int index);
  /**
   * <pre>
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;</code>
   */
  int getHashPolicyCount();
  /**
   * <pre>
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.route.v3.RouteAction.HashPolicyOrBuilder> 
      getHashPolicyOrBuilderList();
  /**
   * <pre>
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   * </pre>
   *
   * <code>repeated .envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.HashPolicyOrBuilder getHashPolicyOrBuilder(
      int index);

  /**
   * <pre>
   * Indicates that the route has a CORS policy.
   * </pre>
   *
   * <code>.envoy.config.route.v3.CorsPolicy cors = 17;</code>
   * @return Whether the cors field is set.
   */
  boolean hasCors();
  /**
   * <pre>
   * Indicates that the route has a CORS policy.
   * </pre>
   *
   * <code>.envoy.config.route.v3.CorsPolicy cors = 17;</code>
   * @return The cors.
   */
  io.envoyproxy.envoy.config.route.v3.CorsPolicy getCors();
  /**
   * <pre>
   * Indicates that the route has a CORS policy.
   * </pre>
   *
   * <code>.envoy.config.route.v3.CorsPolicy cors = 17;</code>
   */
  io.envoyproxy.envoy.config.route.v3.CorsPolicyOrBuilder getCorsOrBuilder();

  /**
   * <pre>
   * Deprecated by :ref:`grpc_timeout_header_max &lt;envoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max&gt;`
   * If present, and the request is a gRPC request, use the
   * `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&gt;`_,
   * or its default value (infinity) instead of
   * :ref:`timeout &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;`, but limit the applied timeout
   * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
   * gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
   * and gRPC requests time out like any other requests using
   * :ref:`timeout &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;` or its default.
   * This can be used to prevent unexpected upstream request timeouts due to potentially long
   * time gaps between gRPC request and response in gRPC streaming mode.
   * .. note::
   *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
   *    precedence over `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&gt;`_, when
   *    both are present. See also
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *    :ref:`retry overview &lt;arch_overview_http_routing_retry&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_grpc_timeout = 23 [deprecated = true];</code>
   * @return Whether the maxGrpcTimeout field is set.
   */
  @java.lang.Deprecated boolean hasMaxGrpcTimeout();
  /**
   * <pre>
   * Deprecated by :ref:`grpc_timeout_header_max &lt;envoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max&gt;`
   * If present, and the request is a gRPC request, use the
   * `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&gt;`_,
   * or its default value (infinity) instead of
   * :ref:`timeout &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;`, but limit the applied timeout
   * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
   * gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
   * and gRPC requests time out like any other requests using
   * :ref:`timeout &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;` or its default.
   * This can be used to prevent unexpected upstream request timeouts due to potentially long
   * time gaps between gRPC request and response in gRPC streaming mode.
   * .. note::
   *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
   *    precedence over `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&gt;`_, when
   *    both are present. See also
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *    :ref:`retry overview &lt;arch_overview_http_routing_retry&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_grpc_timeout = 23 [deprecated = true];</code>
   * @return The maxGrpcTimeout.
   */
  @java.lang.Deprecated com.google.protobuf.Duration getMaxGrpcTimeout();
  /**
   * <pre>
   * Deprecated by :ref:`grpc_timeout_header_max &lt;envoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max&gt;`
   * If present, and the request is a gRPC request, use the
   * `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&gt;`_,
   * or its default value (infinity) instead of
   * :ref:`timeout &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;`, but limit the applied timeout
   * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
   * gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
   * and gRPC requests time out like any other requests using
   * :ref:`timeout &lt;envoy_api_field_config.route.v3.RouteAction.timeout&gt;` or its default.
   * This can be used to prevent unexpected upstream request timeouts due to potentially long
   * time gaps between gRPC request and response in gRPC streaming mode.
   * .. note::
   *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
   *    precedence over `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&gt;`_, when
   *    both are present. See also
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *    :ref:`retry overview &lt;arch_overview_http_routing_retry&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_grpc_timeout = 23 [deprecated = true];</code>
   */
  @java.lang.Deprecated com.google.protobuf.DurationOrBuilder getMaxGrpcTimeoutOrBuilder();

  /**
   * <pre>
   * Deprecated by :ref:`grpc_timeout_header_offset &lt;envoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset&gt;`.
   * If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
   * the provided duration from the header. This is useful in allowing Envoy to set its global
   * timeout to be less than that of the deadline imposed by the calling client, which makes it more
   * likely that Envoy will handle the timeout instead of having the call canceled by the client.
   * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
   * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
   * infinity).
   * </pre>
   *
   * <code>.google.protobuf.Duration grpc_timeout_offset = 28 [deprecated = true];</code>
   * @return Whether the grpcTimeoutOffset field is set.
   */
  @java.lang.Deprecated boolean hasGrpcTimeoutOffset();
  /**
   * <pre>
   * Deprecated by :ref:`grpc_timeout_header_offset &lt;envoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset&gt;`.
   * If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
   * the provided duration from the header. This is useful in allowing Envoy to set its global
   * timeout to be less than that of the deadline imposed by the calling client, which makes it more
   * likely that Envoy will handle the timeout instead of having the call canceled by the client.
   * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
   * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
   * infinity).
   * </pre>
   *
   * <code>.google.protobuf.Duration grpc_timeout_offset = 28 [deprecated = true];</code>
   * @return The grpcTimeoutOffset.
   */
  @java.lang.Deprecated com.google.protobuf.Duration getGrpcTimeoutOffset();
  /**
   * <pre>
   * Deprecated by :ref:`grpc_timeout_header_offset &lt;envoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset&gt;`.
   * If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
   * the provided duration from the header. This is useful in allowing Envoy to set its global
   * timeout to be less than that of the deadline imposed by the calling client, which makes it more
   * likely that Envoy will handle the timeout instead of having the call canceled by the client.
   * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
   * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
   * infinity).
   * </pre>
   *
   * <code>.google.protobuf.Duration grpc_timeout_offset = 28 [deprecated = true];</code>
   */
  @java.lang.Deprecated com.google.protobuf.DurationOrBuilder getGrpcTimeoutOffsetOrBuilder();

  /**
   * <code>repeated .envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.route.v3.RouteAction.UpgradeConfig> 
      getUpgradeConfigsList();
  /**
   * <code>repeated .envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.UpgradeConfig getUpgradeConfigs(int index);
  /**
   * <code>repeated .envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;</code>
   */
  int getUpgradeConfigsCount();
  /**
   * <code>repeated .envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.route.v3.RouteAction.UpgradeConfigOrBuilder> 
      getUpgradeConfigsOrBuilderList();
  /**
   * <code>repeated .envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.UpgradeConfigOrBuilder getUpgradeConfigsOrBuilder(
      int index);

  /**
   * <pre>
   * If present, Envoy will try to follow an upstream redirect response instead of proxying the
   * response back to the downstream. An upstream redirect response is defined
   * by :ref:`redirect_response_codes
   * &lt;envoy_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes&gt;`.
   * </pre>
   *
   * <code>.envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy = 34;</code>
   * @return Whether the internalRedirectPolicy field is set.
   */
  boolean hasInternalRedirectPolicy();
  /**
   * <pre>
   * If present, Envoy will try to follow an upstream redirect response instead of proxying the
   * response back to the downstream. An upstream redirect response is defined
   * by :ref:`redirect_response_codes
   * &lt;envoy_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes&gt;`.
   * </pre>
   *
   * <code>.envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy = 34;</code>
   * @return The internalRedirectPolicy.
   */
  io.envoyproxy.envoy.config.route.v3.InternalRedirectPolicy getInternalRedirectPolicy();
  /**
   * <pre>
   * If present, Envoy will try to follow an upstream redirect response instead of proxying the
   * response back to the downstream. An upstream redirect response is defined
   * by :ref:`redirect_response_codes
   * &lt;envoy_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes&gt;`.
   * </pre>
   *
   * <code>.envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy = 34;</code>
   */
  io.envoyproxy.envoy.config.route.v3.InternalRedirectPolicyOrBuilder getInternalRedirectPolicyOrBuilder();

  /**
   * <code>.envoy.config.route.v3.RouteAction.InternalRedirectAction internal_redirect_action = 26 [deprecated = true];</code>
   * @return The enum numeric value on the wire for internalRedirectAction.
   */
  @java.lang.Deprecated int getInternalRedirectActionValue();
  /**
   * <code>.envoy.config.route.v3.RouteAction.InternalRedirectAction internal_redirect_action = 26 [deprecated = true];</code>
   * @return The internalRedirectAction.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.route.v3.RouteAction.InternalRedirectAction getInternalRedirectAction();

  /**
   * <pre>
   * An internal redirect is handled, iff the number of previous internal redirects that a
   * downstream request has encountered is lower than this value, and
   * :ref:`internal_redirect_action &lt;envoy_api_field_config.route.v3.RouteAction.internal_redirect_action&gt;`
   * is set to :ref:`HANDLE_INTERNAL_REDIRECT
   * &lt;envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT&gt;`
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or has
   * :ref:`internal_redirect_action &lt;envoy_api_field_config.route.v3.RouteAction.internal_redirect_action&gt;`
   * set to
   * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
   * &lt;envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT&gt;`
   * will pass the redirect back to downstream.
   * If not specified, at most one redirect will be followed.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_internal_redirects = 31 [deprecated = true];</code>
   * @return Whether the maxInternalRedirects field is set.
   */
  @java.lang.Deprecated boolean hasMaxInternalRedirects();
  /**
   * <pre>
   * An internal redirect is handled, iff the number of previous internal redirects that a
   * downstream request has encountered is lower than this value, and
   * :ref:`internal_redirect_action &lt;envoy_api_field_config.route.v3.RouteAction.internal_redirect_action&gt;`
   * is set to :ref:`HANDLE_INTERNAL_REDIRECT
   * &lt;envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT&gt;`
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or has
   * :ref:`internal_redirect_action &lt;envoy_api_field_config.route.v3.RouteAction.internal_redirect_action&gt;`
   * set to
   * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
   * &lt;envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT&gt;`
   * will pass the redirect back to downstream.
   * If not specified, at most one redirect will be followed.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_internal_redirects = 31 [deprecated = true];</code>
   * @return The maxInternalRedirects.
   */
  @java.lang.Deprecated com.google.protobuf.UInt32Value getMaxInternalRedirects();
  /**
   * <pre>
   * An internal redirect is handled, iff the number of previous internal redirects that a
   * downstream request has encountered is lower than this value, and
   * :ref:`internal_redirect_action &lt;envoy_api_field_config.route.v3.RouteAction.internal_redirect_action&gt;`
   * is set to :ref:`HANDLE_INTERNAL_REDIRECT
   * &lt;envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT&gt;`
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or has
   * :ref:`internal_redirect_action &lt;envoy_api_field_config.route.v3.RouteAction.internal_redirect_action&gt;`
   * set to
   * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
   * &lt;envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT&gt;`
   * will pass the redirect back to downstream.
   * If not specified, at most one redirect will be followed.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_internal_redirects = 31 [deprecated = true];</code>
   */
  @java.lang.Deprecated com.google.protobuf.UInt32ValueOrBuilder getMaxInternalRedirectsOrBuilder();

  /**
   * <pre>
   * Indicates that the route has a hedge policy. Note that if this is set,
   * it'll take precedence over the virtual host level hedge policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   * </pre>
   *
   * <code>.envoy.config.route.v3.HedgePolicy hedge_policy = 27;</code>
   * @return Whether the hedgePolicy field is set.
   */
  boolean hasHedgePolicy();
  /**
   * <pre>
   * Indicates that the route has a hedge policy. Note that if this is set,
   * it'll take precedence over the virtual host level hedge policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   * </pre>
   *
   * <code>.envoy.config.route.v3.HedgePolicy hedge_policy = 27;</code>
   * @return The hedgePolicy.
   */
  io.envoyproxy.envoy.config.route.v3.HedgePolicy getHedgePolicy();
  /**
   * <pre>
   * Indicates that the route has a hedge policy. Note that if this is set,
   * it'll take precedence over the virtual host level hedge policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   * </pre>
   *
   * <code>.envoy.config.route.v3.HedgePolicy hedge_policy = 27;</code>
   */
  io.envoyproxy.envoy.config.route.v3.HedgePolicyOrBuilder getHedgePolicyOrBuilder();

  /**
   * <pre>
   * Specifies the maximum stream duration for this route.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration = 36;</code>
   * @return Whether the maxStreamDuration field is set.
   */
  boolean hasMaxStreamDuration();
  /**
   * <pre>
   * Specifies the maximum stream duration for this route.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration = 36;</code>
   * @return The maxStreamDuration.
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.MaxStreamDuration getMaxStreamDuration();
  /**
   * <pre>
   * Specifies the maximum stream duration for this route.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration = 36;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteAction.MaxStreamDurationOrBuilder getMaxStreamDurationOrBuilder();

  public io.envoyproxy.envoy.config.route.v3.RouteAction.ClusterSpecifierCase getClusterSpecifierCase();

  public io.envoyproxy.envoy.config.route.v3.RouteAction.HostRewriteSpecifierCase getHostRewriteSpecifierCase();
}
