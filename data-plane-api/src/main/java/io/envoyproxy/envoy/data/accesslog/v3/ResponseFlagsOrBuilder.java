// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/data/accesslog/v3/accesslog.proto

package io.envoyproxy.envoy.data.accesslog.v3;

public interface ResponseFlagsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.data.accesslog.v3.ResponseFlags)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Indicates local server healthcheck failed.
   * </pre>
   *
   * <code>bool failed_local_healthcheck = 1;</code>
   * @return The failedLocalHealthcheck.
   */
  boolean getFailedLocalHealthcheck();

  /**
   * <pre>
   * Indicates there was no healthy upstream.
   * </pre>
   *
   * <code>bool no_healthy_upstream = 2;</code>
   * @return The noHealthyUpstream.
   */
  boolean getNoHealthyUpstream();

  /**
   * <pre>
   * Indicates an there was an upstream request timeout.
   * </pre>
   *
   * <code>bool upstream_request_timeout = 3;</code>
   * @return The upstreamRequestTimeout.
   */
  boolean getUpstreamRequestTimeout();

  /**
   * <pre>
   * Indicates local codec level reset was sent on the stream.
   * </pre>
   *
   * <code>bool local_reset = 4;</code>
   * @return The localReset.
   */
  boolean getLocalReset();

  /**
   * <pre>
   * Indicates remote codec level reset was received on the stream.
   * </pre>
   *
   * <code>bool upstream_remote_reset = 5;</code>
   * @return The upstreamRemoteReset.
   */
  boolean getUpstreamRemoteReset();

  /**
   * <pre>
   * Indicates there was a local reset by a connection pool due to an initial connection failure.
   * </pre>
   *
   * <code>bool upstream_connection_failure = 6;</code>
   * @return The upstreamConnectionFailure.
   */
  boolean getUpstreamConnectionFailure();

  /**
   * <pre>
   * Indicates the stream was reset due to an upstream connection termination.
   * </pre>
   *
   * <code>bool upstream_connection_termination = 7;</code>
   * @return The upstreamConnectionTermination.
   */
  boolean getUpstreamConnectionTermination();

  /**
   * <pre>
   * Indicates the stream was reset because of a resource overflow.
   * </pre>
   *
   * <code>bool upstream_overflow = 8;</code>
   * @return The upstreamOverflow.
   */
  boolean getUpstreamOverflow();

  /**
   * <pre>
   * Indicates no route was found for the request.
   * </pre>
   *
   * <code>bool no_route_found = 9;</code>
   * @return The noRouteFound.
   */
  boolean getNoRouteFound();

  /**
   * <pre>
   * Indicates that the request was delayed before proxying.
   * </pre>
   *
   * <code>bool delay_injected = 10;</code>
   * @return The delayInjected.
   */
  boolean getDelayInjected();

  /**
   * <pre>
   * Indicates that the request was aborted with an injected error code.
   * </pre>
   *
   * <code>bool fault_injected = 11;</code>
   * @return The faultInjected.
   */
  boolean getFaultInjected();

  /**
   * <pre>
   * Indicates that the request was rate-limited locally.
   * </pre>
   *
   * <code>bool rate_limited = 12;</code>
   * @return The rateLimited.
   */
  boolean getRateLimited();

  /**
   * <pre>
   * Indicates if the request was deemed unauthorized and the reason for it.
   * </pre>
   *
   * <code>.envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details = 13;</code>
   * @return Whether the unauthorizedDetails field is set.
   */
  boolean hasUnauthorizedDetails();
  /**
   * <pre>
   * Indicates if the request was deemed unauthorized and the reason for it.
   * </pre>
   *
   * <code>.envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details = 13;</code>
   * @return The unauthorizedDetails.
   */
  io.envoyproxy.envoy.data.accesslog.v3.ResponseFlags.Unauthorized getUnauthorizedDetails();
  /**
   * <pre>
   * Indicates if the request was deemed unauthorized and the reason for it.
   * </pre>
   *
   * <code>.envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details = 13;</code>
   */
  io.envoyproxy.envoy.data.accesslog.v3.ResponseFlags.UnauthorizedOrBuilder getUnauthorizedDetailsOrBuilder();

  /**
   * <pre>
   * Indicates that the request was rejected because there was an error in rate limit service.
   * </pre>
   *
   * <code>bool rate_limit_service_error = 14;</code>
   * @return The rateLimitServiceError.
   */
  boolean getRateLimitServiceError();

  /**
   * <pre>
   * Indicates the stream was reset due to a downstream connection termination.
   * </pre>
   *
   * <code>bool downstream_connection_termination = 15;</code>
   * @return The downstreamConnectionTermination.
   */
  boolean getDownstreamConnectionTermination();

  /**
   * <pre>
   * Indicates that the upstream retry limit was exceeded, resulting in a downstream error.
   * </pre>
   *
   * <code>bool upstream_retry_limit_exceeded = 16;</code>
   * @return The upstreamRetryLimitExceeded.
   */
  boolean getUpstreamRetryLimitExceeded();

  /**
   * <pre>
   * Indicates that the stream idle timeout was hit, resulting in a downstream 408.
   * </pre>
   *
   * <code>bool stream_idle_timeout = 17;</code>
   * @return The streamIdleTimeout.
   */
  boolean getStreamIdleTimeout();

  /**
   * <pre>
   * Indicates that the request was rejected because an envoy request header failed strict
   * validation.
   * </pre>
   *
   * <code>bool invalid_envoy_request_headers = 18;</code>
   * @return The invalidEnvoyRequestHeaders.
   */
  boolean getInvalidEnvoyRequestHeaders();

  /**
   * <pre>
   * Indicates there was an HTTP protocol error on the downstream request.
   * </pre>
   *
   * <code>bool downstream_protocol_error = 19;</code>
   * @return The downstreamProtocolError.
   */
  boolean getDownstreamProtocolError();

  /**
   * <pre>
   * Indicates there was a max stream duration reached on the upstream request.
   * </pre>
   *
   * <code>bool upstream_max_stream_duration_reached = 20;</code>
   * @return The upstreamMaxStreamDurationReached.
   */
  boolean getUpstreamMaxStreamDurationReached();

  /**
   * <pre>
   * Indicates the response was served from a cache filter.
   * </pre>
   *
   * <code>bool response_from_cache_filter = 21;</code>
   * @return The responseFromCacheFilter.
   */
  boolean getResponseFromCacheFilter();

  /**
   * <pre>
   * Indicates that a filter configuration is not available.
   * </pre>
   *
   * <code>bool no_filter_config_found = 22;</code>
   * @return The noFilterConfigFound.
   */
  boolean getNoFilterConfigFound();

  /**
   * <pre>
   * Indicates that request or connection exceeded the downstream connection duration.
   * </pre>
   *
   * <code>bool duration_timeout = 23;</code>
   * @return The durationTimeout.
   */
  boolean getDurationTimeout();
}
