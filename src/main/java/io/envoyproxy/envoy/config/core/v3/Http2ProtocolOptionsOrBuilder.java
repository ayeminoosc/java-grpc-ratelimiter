// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/core/v3/protocol.proto

package io.envoyproxy.envoy.config.core.v3;

public interface Http2ProtocolOptionsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.Http2ProtocolOptions)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * `Maximum table size &lt;https://httpwg.org/specs/rfc7541.html#rfc.section.4.2&gt;`_
   * (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
   * range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
   * compression.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value hpack_table_size = 1;</code>
   * @return Whether the hpackTableSize field is set.
   */
  boolean hasHpackTableSize();
  /**
   * <pre>
   * `Maximum table size &lt;https://httpwg.org/specs/rfc7541.html#rfc.section.4.2&gt;`_
   * (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
   * range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
   * compression.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value hpack_table_size = 1;</code>
   * @return The hpackTableSize.
   */
  com.google.protobuf.UInt32Value getHpackTableSize();
  /**
   * <pre>
   * `Maximum table size &lt;https://httpwg.org/specs/rfc7541.html#rfc.section.4.2&gt;`_
   * (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
   * range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
   * compression.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value hpack_table_size = 1;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getHpackTableSizeOrBuilder();

  /**
   * <pre>
   * `Maximum concurrent streams &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2&gt;`_
   * allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
   * and defaults to 2147483647.
   * For upstream connections, this also limits how many streams Envoy will initiate concurrently
   * on a single connection. If the limit is reached, Envoy may queue requests or establish
   * additional connections (as allowed per circuit breaker limits).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_concurrent_streams = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the maxConcurrentStreams field is set.
   */
  boolean hasMaxConcurrentStreams();
  /**
   * <pre>
   * `Maximum concurrent streams &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2&gt;`_
   * allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
   * and defaults to 2147483647.
   * For upstream connections, this also limits how many streams Envoy will initiate concurrently
   * on a single connection. If the limit is reached, Envoy may queue requests or establish
   * additional connections (as allowed per circuit breaker limits).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_concurrent_streams = 2 [(.validate.rules) = { ... }</code>
   * @return The maxConcurrentStreams.
   */
  com.google.protobuf.UInt32Value getMaxConcurrentStreams();
  /**
   * <pre>
   * `Maximum concurrent streams &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2&gt;`_
   * allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
   * and defaults to 2147483647.
   * For upstream connections, this also limits how many streams Envoy will initiate concurrently
   * on a single connection. If the limit is reached, Envoy may queue requests or establish
   * additional connections (as allowed per circuit breaker limits).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_concurrent_streams = 2 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxConcurrentStreamsOrBuilder();

  /**
   * <pre>
   * `Initial stream-level flow-control window
   * &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2&gt;`_ size. Valid values range from 65535
   * (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
   * (256 * 1024 * 1024).
   * NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
   * window size now, so it's also the minimum.
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the codec buffers.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_stream_window_size = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the initialStreamWindowSize field is set.
   */
  boolean hasInitialStreamWindowSize();
  /**
   * <pre>
   * `Initial stream-level flow-control window
   * &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2&gt;`_ size. Valid values range from 65535
   * (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
   * (256 * 1024 * 1024).
   * NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
   * window size now, so it's also the minimum.
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the codec buffers.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_stream_window_size = 3 [(.validate.rules) = { ... }</code>
   * @return The initialStreamWindowSize.
   */
  com.google.protobuf.UInt32Value getInitialStreamWindowSize();
  /**
   * <pre>
   * `Initial stream-level flow-control window
   * &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2&gt;`_ size. Valid values range from 65535
   * (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
   * (256 * 1024 * 1024).
   * NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
   * window size now, so it's also the minimum.
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the codec buffers.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_stream_window_size = 3 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getInitialStreamWindowSizeOrBuilder();

  /**
   * <pre>
   * Similar to *initial_stream_window_size*, but for connection-level flow-control
   * window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_connection_window_size = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the initialConnectionWindowSize field is set.
   */
  boolean hasInitialConnectionWindowSize();
  /**
   * <pre>
   * Similar to *initial_stream_window_size*, but for connection-level flow-control
   * window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_connection_window_size = 4 [(.validate.rules) = { ... }</code>
   * @return The initialConnectionWindowSize.
   */
  com.google.protobuf.UInt32Value getInitialConnectionWindowSize();
  /**
   * <pre>
   * Similar to *initial_stream_window_size*, but for connection-level flow-control
   * window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_connection_window_size = 4 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getInitialConnectionWindowSizeOrBuilder();

  /**
   * <pre>
   * Allows proxying Websocket and other upgrades over H2 connect.
   * </pre>
   *
   * <code>bool allow_connect = 5;</code>
   * @return The allowConnect.
   */
  boolean getAllowConnect();

  /**
   * <pre>
   * [#not-implemented-hide:] Hiding until envoy has full metadata support.
   * Still under implementation. DO NOT USE.
   * Allows metadata. See [metadata
   * docs](https://github.com/envoyproxy/envoy/blob/master/source/docs/h2_metadata.md) for more
   * information.
   * </pre>
   *
   * <code>bool allow_metadata = 6;</code>
   * @return The allowMetadata.
   */
  boolean getAllowMetadata();

  /**
   * <pre>
   * Limit the number of pending outbound downstream frames of all types (frames that are waiting to
   * be written into the socket). Exceeding this limit triggers flood mitigation and connection is
   * terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
   * to flood mitigation. The default limit is 10000.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_outbound_frames = 7 [(.validate.rules) = { ... }</code>
   * @return Whether the maxOutboundFrames field is set.
   */
  boolean hasMaxOutboundFrames();
  /**
   * <pre>
   * Limit the number of pending outbound downstream frames of all types (frames that are waiting to
   * be written into the socket). Exceeding this limit triggers flood mitigation and connection is
   * terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
   * to flood mitigation. The default limit is 10000.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_outbound_frames = 7 [(.validate.rules) = { ... }</code>
   * @return The maxOutboundFrames.
   */
  com.google.protobuf.UInt32Value getMaxOutboundFrames();
  /**
   * <pre>
   * Limit the number of pending outbound downstream frames of all types (frames that are waiting to
   * be written into the socket). Exceeding this limit triggers flood mitigation and connection is
   * terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
   * to flood mitigation. The default limit is 10000.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_outbound_frames = 7 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxOutboundFramesOrBuilder();

  /**
   * <pre>
   * Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
   * preventing high memory utilization when receiving continuous stream of these frames. Exceeding
   * this limit triggers flood mitigation and connection is terminated. The
   * ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
   * mitigation. The default limit is 1000.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_outbound_control_frames = 8 [(.validate.rules) = { ... }</code>
   * @return Whether the maxOutboundControlFrames field is set.
   */
  boolean hasMaxOutboundControlFrames();
  /**
   * <pre>
   * Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
   * preventing high memory utilization when receiving continuous stream of these frames. Exceeding
   * this limit triggers flood mitigation and connection is terminated. The
   * ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
   * mitigation. The default limit is 1000.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_outbound_control_frames = 8 [(.validate.rules) = { ... }</code>
   * @return The maxOutboundControlFrames.
   */
  com.google.protobuf.UInt32Value getMaxOutboundControlFrames();
  /**
   * <pre>
   * Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
   * preventing high memory utilization when receiving continuous stream of these frames. Exceeding
   * this limit triggers flood mitigation and connection is terminated. The
   * ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
   * mitigation. The default limit is 1000.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_outbound_control_frames = 8 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxOutboundControlFramesOrBuilder();

  /**
   * <pre>
   * Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
   * empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
   * might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
   * stat tracks the number of connections terminated due to flood mitigation.
   * Setting this to 0 will terminate connection upon receiving first frame with an empty payload
   * and no end stream flag. The default limit is 1.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9;</code>
   * @return Whether the maxConsecutiveInboundFramesWithEmptyPayload field is set.
   */
  boolean hasMaxConsecutiveInboundFramesWithEmptyPayload();
  /**
   * <pre>
   * Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
   * empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
   * might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
   * stat tracks the number of connections terminated due to flood mitigation.
   * Setting this to 0 will terminate connection upon receiving first frame with an empty payload
   * and no end stream flag. The default limit is 1.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9;</code>
   * @return The maxConsecutiveInboundFramesWithEmptyPayload.
   */
  com.google.protobuf.UInt32Value getMaxConsecutiveInboundFramesWithEmptyPayload();
  /**
   * <pre>
   * Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
   * empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
   * might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
   * stat tracks the number of connections terminated due to flood mitigation.
   * Setting this to 0 will terminate connection upon receiving first frame with an empty payload
   * and no end stream flag. The default limit is 1.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxConsecutiveInboundFramesWithEmptyPayloadOrBuilder();

  /**
   * <pre>
   * Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
   * of PRIORITY frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 100.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10;</code>
   * @return Whether the maxInboundPriorityFramesPerStream field is set.
   */
  boolean hasMaxInboundPriorityFramesPerStream();
  /**
   * <pre>
   * Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
   * of PRIORITY frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 100.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10;</code>
   * @return The maxInboundPriorityFramesPerStream.
   */
  com.google.protobuf.UInt32Value getMaxInboundPriorityFramesPerStream();
  /**
   * <pre>
   * Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
   * of PRIORITY frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 100.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxInboundPriorityFramesPerStreamOrBuilder();

  /**
   * <pre>
   * Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
   * of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *     1 + 2 * (inbound_streams +
   *              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 10.
   * Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
   * but more complex implementations that try to estimate available bandwidth require at least 2.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11 [(.validate.rules) = { ... }</code>
   * @return Whether the maxInboundWindowUpdateFramesPerDataFrameSent field is set.
   */
  boolean hasMaxInboundWindowUpdateFramesPerDataFrameSent();
  /**
   * <pre>
   * Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
   * of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *     1 + 2 * (inbound_streams +
   *              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 10.
   * Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
   * but more complex implementations that try to estimate available bandwidth require at least 2.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11 [(.validate.rules) = { ... }</code>
   * @return The maxInboundWindowUpdateFramesPerDataFrameSent.
   */
  com.google.protobuf.UInt32Value getMaxInboundWindowUpdateFramesPerDataFrameSent();
  /**
   * <pre>
   * Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
   * of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *     1 + 2 * (inbound_streams +
   *              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 10.
   * Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
   * but more complex implementations that try to estimate available bandwidth require at least 2.
   * NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
   * `envoy.reloadable_features.upstream_http2_flood_checks` flag.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxInboundWindowUpdateFramesPerDataFrameSentOrBuilder();

  /**
   * <pre>
   * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
   * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
   * when this option is enabled, only the offending stream is terminated.
   * This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message&gt;`
   * iff present.
   * This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1&gt;`_ for details.
   * </pre>
   *
   * <code>bool stream_error_on_invalid_http_messaging = 12 [deprecated = true];</code>
   * @return The streamErrorOnInvalidHttpMessaging.
   */
  @java.lang.Deprecated boolean getStreamErrorOnInvalidHttpMessaging();

  /**
   * <pre>
   * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
   * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
   * when this option is enabled, only the offending stream is terminated.
   * This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message&gt;`
   * See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1&gt;`_ for details.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 14;</code>
   * @return Whether the overrideStreamErrorOnInvalidHttpMessage field is set.
   */
  boolean hasOverrideStreamErrorOnInvalidHttpMessage();
  /**
   * <pre>
   * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
   * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
   * when this option is enabled, only the offending stream is terminated.
   * This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message&gt;`
   * See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1&gt;`_ for details.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 14;</code>
   * @return The overrideStreamErrorOnInvalidHttpMessage.
   */
  com.google.protobuf.BoolValue getOverrideStreamErrorOnInvalidHttpMessage();
  /**
   * <pre>
   * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
   * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
   * when this option is enabled, only the offending stream is terminated.
   * This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message&gt;`
   * See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1&gt;`_ for details.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 14;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getOverrideStreamErrorOnInvalidHttpMessageOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   * .. code-block:: text
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   * See `IANA HTTP/2 Settings
   * &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings&gt;`_ for
   * standardized identifiers.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter> 
      getCustomSettingsParametersList();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   * .. code-block:: text
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   * See `IANA HTTP/2 Settings
   * &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings&gt;`_ for
   * standardized identifiers.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;</code>
   */
  io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter getCustomSettingsParameters(int index);
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   * .. code-block:: text
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   * See `IANA HTTP/2 Settings
   * &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings&gt;`_ for
   * standardized identifiers.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;</code>
   */
  int getCustomSettingsParametersCount();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   * .. code-block:: text
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   * See `IANA HTTP/2 Settings
   * &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings&gt;`_ for
   * standardized identifiers.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.SettingsParameterOrBuilder> 
      getCustomSettingsParametersOrBuilderList();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   * .. code-block:: text
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   * See `IANA HTTP/2 Settings
   * &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings&gt;`_ for
   * standardized identifiers.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;</code>
   */
  io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.SettingsParameterOrBuilder getCustomSettingsParametersOrBuilder(
      int index);

  /**
   * <pre>
   * Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
   * does not respond within the configured timeout, the connection will be aborted.
   * </pre>
   *
   * <code>.envoy.config.core.v3.KeepaliveSettings connection_keepalive = 15;</code>
   * @return Whether the connectionKeepalive field is set.
   */
  boolean hasConnectionKeepalive();
  /**
   * <pre>
   * Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
   * does not respond within the configured timeout, the connection will be aborted.
   * </pre>
   *
   * <code>.envoy.config.core.v3.KeepaliveSettings connection_keepalive = 15;</code>
   * @return The connectionKeepalive.
   */
  io.envoyproxy.envoy.config.core.v3.KeepaliveSettings getConnectionKeepalive();
  /**
   * <pre>
   * Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
   * does not respond within the configured timeout, the connection will be aborted.
   * </pre>
   *
   * <code>.envoy.config.core.v3.KeepaliveSettings connection_keepalive = 15;</code>
   */
  io.envoyproxy.envoy.config.core.v3.KeepaliveSettingsOrBuilder getConnectionKeepaliveOrBuilder();
}
